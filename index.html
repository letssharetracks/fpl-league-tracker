<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPL League Tracker - The 5lb League</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'PremierSans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(180deg, #37003c 0%, #2d0032 50%, #1a001d 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(90deg, #00ff85, #04f5ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .subtitle {
            text-align: center;
            color: #b8b8b8;
            margin-bottom: 30px;
            font-weight: 500;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .control-group {
            background: rgba(255,255,255,0.08);
            padding: 15px 20px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .control-group label {
            margin-right: 10px;
            color: #e8e8e8;
            font-weight: 500;
        }
        select {
            padding: 8px 15px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(55, 0, 60, 0.8);
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }
        select:hover {
            border-color: #00ff85;
        }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 20px;
        }
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        /* Mobile optimizations */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            h1 {
                font-size: 1.4rem;
                margin-bottom: 5px;
            }
            .controls {
                flex-direction: column;
                gap: 10px;
            }
            .control-group {
                width: 100%;
                padding: 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                align-items: center;
            }
            .control-group label {
                width: 100%;
                margin-bottom: 5px;
                font-size: 12px;
            }
            .view-btn {
                padding: 12px 14px;
                font-size: 11px;
                flex: 1;
                min-width: 80px;
                text-align: center;
            }
            select {
                padding: 12px 10px;
                font-size: 14px;
                flex: 1;
                min-width: 70px;
            }
            .btn {
                padding: 12px 16px;
                font-size: 11px;
                flex: 1;
                min-width: 60px;
            }
            .chart-container {
                padding: 10px;
                min-height: 350px;
            }
            .sidebar {
                max-height: 400px;
                padding: 10px;
            }
            .sidebar h3 {
                font-size: 12px;
            }
            .player-toggle {
                padding: 12px 10px;
                gap: 6px;
            }
            .player-toggle input {
                width: 20px;
                height: 20px;
            }
            .player-toggle .rank {
                font-size: 12px;
                min-width: 50px;
            }
            .player-toggle .player-name {
                font-size: 14px;
            }
            .player-toggle .points {
                font-size: 13px;
            }
            .player-toggle .color-dot {
                width: 10px;
                height: 10px;
            }
            #playerSearch {
                padding: 12px;
                font-size: 14px;
            }
            .btn-group {
                gap: 8px;
            }
            .btn-group .btn {
                flex: 1;
                min-width: 70px;
            }
            #statusBar {
                padding: 12px;
                font-size: 14px;
            }
            .setup-box {
                padding: 20px;
                margin: 20px auto;
            }
            .setup-box h2 {
                font-size: 1rem;
            }
            #teamIdInput {
                width: 120px;
                padding: 14px 12px;
            }
            .player-toggle .expand-icon {
                font-size: 14px;
                opacity: 1;
            }
            .player-details {
                padding: 12px 15px;
                font-size: 14px;
            }
            .detail-row {
                padding: 6px 0;
            }
        }
        .chart-container {
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            padding: 20px;
            min-height: 500px;
            border: 1px solid rgba(255,255,255,0.1);
            overflow: visible;
        }
        .chart-container canvas {
            overflow: visible !important;
        }
        .sidebar {
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            padding: 15px;
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .sidebar h3 {
            margin-bottom: 12px;
            color: #00ff85;
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: sticky;
            top: 0;
            background: linear-gradient(180deg, rgba(55,0,60,1) 0%, rgba(55,0,60,0.95) 100%);
            padding: 8px 0;
        }
        .btn-group {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .btn {
            padding: 8px 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .btn-select-all {
            background: linear-gradient(135deg, #00ff85, #00d970);
            color: #37003c;
        }
        .btn-clear-all {
            background: linear-gradient(135deg, #e90052, #c70045);
            color: #fff;
        }
        .btn-top-10 {
            background: linear-gradient(135deg, #04f5ff, #00d4e6);
            color: #37003c;
        }
        .view-btn {
            padding: 10px 18px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            background: rgba(55, 0, 60, 0.6);
            color: #b8b8b8;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .view-btn:hover {
            background: rgba(55, 0, 60, 0.9);
            color: #fff;
            border-color: #00ff85;
        }
        .view-btn.active {
            background: linear-gradient(135deg, #00ff85, #00d970);
            color: #37003c;
            border-color: #00ff85;
            font-weight: 700;
        }
        .player-list {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        .player-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
            border-left: 4px solid transparent;
        }
        .player-toggle:hover {
            background: rgba(0,255,133,0.1);
            transform: translateX(3px);
        }
        .player-toggle.selected {
            background: rgba(0,255,133,0.08);
        }
        .player-toggle input {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #00ff85;
        }
        .player-toggle .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
            border: 2px solid rgba(255,255,255,0.3);
        }
        .player-toggle .rank {
            font-size: 11px;
            color: #888;
            min-width: 40px;
            white-space: nowrap;
            font-weight: 600;
        }
        .player-toggle .player-name {
            flex: 1;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-weight: 500;
        }
        .player-toggle .points {
            font-weight: 700;
            color: #00ff85;
            font-size: 12px;
        }
        .player-toggle .expand-icon {
            font-size: 12px;
            opacity: 0.6;
            margin-left: 5px;
        }
        .player-wrapper {
            margin-bottom: 3px;
        }
        .player-details {
            background: rgba(0,0,0,0.3);
            padding: 10px 12px;
            margin: 0 0 5px 0;
            border-radius: 0 0 6px 6px;
            border-left: 4px solid #04f5ff;
            font-size: 12px;
        }
        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .detail-row:last-child {
            border-bottom: none;
        }
        .loading {
            text-align: center;
            padding: 50px;
            font-size: 16px;
            color: #b8b8b8;
        }
        /* Setup screen */
        .setup-box {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 40px;
            max-width: 500px;
            margin: 50px auto;
            border: 1px solid rgba(255,255,255,0.1);
            text-align: center;
        }
        .league-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        .league-option:hover {
            background: rgba(0,255,133,0.1);
            border-color: rgba(0,255,133,0.3);
        }
        .league-option .league-name {
            font-weight: 600;
            color: #fff;
        }
        .league-option .league-info {
            font-size: 12px;
            color: #888;
        }
        /* Scrollbar styling */
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }
        .sidebar::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2);
            border-radius: 3px;
        }
        .sidebar::-webkit-scrollbar-thumb {
            background: #00ff85;
            border-radius: 3px;
        }
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #00d970;
        }
    </style>
</head>
<body>
    <!-- Setup Screen -->
    <div id="setupScreen" class="container" style="display: none;">
        <h1>FPL League Tracker</h1>
        <p class="subtitle">Track your Fantasy Premier League mini-leagues</p>

        <div class="setup-box">
            <h2 style="color: #00ff85; margin-bottom: 15px; font-size: 1.2rem;">Enter Your FPL Team ID</h2>
            <p style="color: #b8b8b8; margin-bottom: 20px; font-size: 13px;">
                Find your Team ID in your FPL URL:<br>
                <code style="background: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 4px; display: inline-block; margin-top: 8px;">
                    fantasy.premierleague.com/entry/<span style="color: #00ff85;">XXXXXX</span>/event/1
                </code>
            </p>
            <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <input type="text" id="teamIdInput" placeholder="Your Team ID"
                       style="width: 150px; padding: 12px 15px; border-radius: 6px; border: 2px solid rgba(0,255,133,0.3); background: rgba(55,0,60,0.8); color: #fff; font-size: 16px; text-align: center;">
                <button class="btn btn-select-all" onclick="lookupTeamLeagues()" style="padding: 12px 25px; font-size: 14px;">
                    Find My Leagues
                </button>
            </div>
            <div id="setupError" style="color: #ff4757; margin-top: 15px; display: none;"></div>
            <div id="setupLoading" style="color: #04f5ff; margin-top: 15px; display: none;">Loading your leagues...</div>

            <div id="leaguesList" style="margin-top: 25px; display: none;">
                <h3 style="color: #00ff85; margin-bottom: 15px; font-size: 1rem;">Your Leagues</h3>
                <div id="leaguesContainer" style="max-height: 300px; overflow-y: auto;"></div>
            </div>
        </div>

        <p style="text-align: center; margin-top: 30px; color: #666; font-size: 12px;">
            <a href="#" onclick="skipSetup()" style="color: #04f5ff;">Skip setup and enter League ID manually</a>
        </p>
    </div>

    <!-- Main App -->
    <div id="mainApp" class="container" style="display: none;">
        <h1>FPL League Tracker</h1>

        <div class="controls">
            <div class="control-group">
                <label>League:</label>
                <select id="leagueSelect" onchange="selectLeague()" style="padding: 8px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2); background: rgba(55,0,60,0.8); color: #fff; font-size: 13px; max-width: 200px; cursor: pointer;">
                </select>
                <span style="margin: 0 10px; color: #666;">or</span>
                <input type="text" id="leagueId" placeholder="League ID" style="width: 80px; padding: 8px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2); background: rgba(55,0,60,0.8); color: #fff; font-size: 13px;">
                <button class="btn btn-top-10" onclick="loadNewLeague()" style="margin-left: 5px;">Load</button>
                <button class="btn btn-clear-all" onclick="clearAllCaches()" style="margin-left: 10px;" title="Clear all cached data">Reset All</button>
                <button class="btn btn-select-all" id="refreshLiveBtn" onclick="refreshLiveData()" style="margin-left: 10px;" title="Refresh live gameweek data">Refresh Live</button>
                <button class="btn btn-clear-all" onclick="changeTeam()" style="margin-left: 10px;" title="Change Team ID">Change Team</button>
            </div>
            <div class="control-group">
                <label>View:</label>
                <div style="display: inline-flex; gap: 5px;">
                    <button class="view-btn active" id="btn-total" onclick="setChartType('total')">Total Points</button>
                    <button class="view-btn" id="btn-weekly" onclick="setChartType('weekly')">Weekly</button>
                    <button class="view-btn" id="btn-rank" onclick="setChartType('rank')">Position</button>
                </div>
            </div>
            <div class="control-group">
                <label>Weeks:</label>
                <select id="weekStart" onchange="updateWeekRange()" style="padding: 8px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2); background: rgba(55,0,60,0.8); color: #fff; font-size: 13px; width: 70px;">
                </select>
                <span style="margin: 0 5px; color: #666;">to</span>
                <select id="weekEnd" onchange="updateWeekRange()" style="padding: 8px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2); background: rgba(55,0,60,0.8); color: #fff; font-size: 13px; width: 70px;">
                </select>
                <button class="btn btn-top-10" onclick="resetWeekRange()" style="margin-left: 5px;">All</button>
            </div>
        </div>

        <div id="statusBar" style="display: none; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px; text-align: center;">
            <span id="statusText" style="color: #04f5ff;">Loading...</span>
        </div>

        <div class="main-content">
            <div class="chart-container">
                <canvas id="mainChart"></canvas>
            </div>

            <div class="sidebar">
                <h3>Toggle Players</h3>
                <input type="text" id="playerSearch" placeholder="Search players..."
                       oninput="filterPlayers(this.value)"
                       style="width: 100%; padding: 8px 12px; margin-bottom: 10px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2); background: rgba(55,0,60,0.8); color: #fff; font-size: 13px;">
                <div class="btn-group">
                    <button class="btn btn-top-10" onclick="selectTop10()">Top 10</button>
                    <button class="btn btn-select-all" onclick="selectAll()">All</button>
                    <button class="btn btn-clear-all" onclick="clearAll()">Clear</button>
                    <button class="btn btn-top-10" id="selectFilteredBtn" onclick="selectFiltered()" style="display: none;">Select Filtered</button>
                </div>
                <div class="player-list" id="playerToggles">
                    <div class="loading">
                        <div id="loadingText">Loading...</div>
                        <div style="margin-top: 10px;">
                            <div id="loadingPercent" style="font-size: 20px; color: #00ff88;">0%</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let LEAGUE_ID = null;
        let allPlayers = [];
        let playerHistories = {};
        let chart = null;
        let selectedEntries = new Set();
        let leagueName = '';
        let currentChartType = 'total';
        let hoveredEntry = null;
        let currentGameweek = null;
        let gameweekFinished = true;
        let livePoints = {};
        let livePositions = {};
        let currentFilter = '';
        let userTeamId = null;
        let userLeagues = [];
        let weekRangeStart = 1;
        let weekRangeEnd = 38;

        // Default Team ID for development (Dominic Mackie)
        const DEFAULT_TEAM_ID = null; // Set to null for production - users enter their own Team ID

        // CORS Proxy for FPL API requests - with fallbacks
        const CORS_PROXIES = [
            'https://api.codetabs.com/v1/proxy?quest=',
            'https://api.allorigins.win/raw?url=',
            'https://corsproxy.io/?'
        ];
        let currentProxyIndex = 0;
        let CORS_PROXY = CORS_PROXIES[0];

        let fetchRetryCount = 0;
        const MAX_FETCH_RETRIES = 3;

        async function fetchWithFallback(url, isRetry = false) {
            for (let i = 0; i < CORS_PROXIES.length; i++) {
                const proxyIndex = (currentProxyIndex + i) % CORS_PROXIES.length;
                const proxy = CORS_PROXIES[proxyIndex];
                try {
                    // allorigins and corsproxy need encoded URL, codetabs does not
                    const needsEncoding = proxy.includes('allorigins') || proxy.includes('corsproxy');
                    const fullUrl = proxy + (needsEncoding ? encodeURIComponent(url) : url);
                    console.log(`Trying proxy ${proxyIndex}: ${proxy.split('/')[2]}`);
                    const response = await fetch(fullUrl);
                    if (response.ok) {
                        currentProxyIndex = proxyIndex; // Remember working proxy
                        CORS_PROXY = proxy;
                        console.log(`Proxy ${proxyIndex} succeeded`);
                        fetchRetryCount = 0; // Reset retry count on success
                        return response;
                    }
                    console.warn(`Proxy ${proxyIndex} returned ${response.status}`);
                } catch (e) {
                    console.warn(`Proxy ${proxyIndex} failed:`, e.message);
                }
            }
            throw new Error('All proxies failed - FPL API may be temporarily unavailable');
        }

        // Initialize app
        function initApp() {
            // Check if user has saved Team ID
            const savedTeamId = localStorage.getItem('fpl_team_id');
            const savedLeagues = localStorage.getItem('fpl_user_leagues');

            if (savedTeamId && savedLeagues) {
                userTeamId = savedTeamId;
                userLeagues = JSON.parse(savedLeagues);
                showMainApp();
            } else if (DEFAULT_TEAM_ID) {
                // Auto-lookup for development
                document.getElementById('teamIdInput').value = DEFAULT_TEAM_ID;
                lookupTeamLeagues();
            } else {
                showSetupScreen();
            }
        }

        function showSetupScreen() {
            document.getElementById('setupScreen').style.display = 'block';
            document.getElementById('mainApp').style.display = 'none';
        }

        function showMainApp() {
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('mainApp').style.display = 'block';
            populateLeagueDropdown();
            if (userLeagues.length > 0 && !LEAGUE_ID) {
                LEAGUE_ID = userLeagues[0].id;
            }
            loadAllData();
        }

        async function lookupTeamLeagues() {
            const teamId = document.getElementById('teamIdInput').value.trim();
            if (!teamId || isNaN(teamId)) {
                showSetupError('Please enter a valid Team ID');
                return;
            }

            document.getElementById('setupError').style.display = 'none';
            document.getElementById('setupLoading').style.display = 'block';
            document.getElementById('leaguesList').style.display = 'none';

            try {
                const url = `https://fantasy.premierleague.com/api/entry/${teamId}/`;
                const response = await fetchWithFallback(url);
                if (!response.ok) {
                    throw new Error('Team not found');
                }
                const data = await response.json();

                // Extract only user-created mini-leagues (not official FPL leagues)
                const classicLeagues = data.leagues?.classic || [];
                userLeagues = classicLeagues
                    .filter(l => l.league_type === 'x') // Only user-created mini-leagues
                    .map(l => ({
                        id: l.id,
                        name: l.name,
                        rank: l.entry_rank,
                        lastRank: l.entry_last_rank
                    }));

                if (userLeagues.length === 0) {
                    showSetupError('No mini-leagues found for this Team ID');
                    document.getElementById('setupLoading').style.display = 'none';
                    return;
                }

                // Save to localStorage
                userTeamId = teamId;
                localStorage.setItem('fpl_team_id', teamId);
                localStorage.setItem('fpl_user_leagues', JSON.stringify(userLeagues));

                // Go straight to first league
                document.getElementById('setupLoading').style.display = 'none';
                LEAGUE_ID = userLeagues[0].id;
                showMainApp();

            } catch (e) {
                console.error('Team lookup failed:', e);
                showSetupError('Could not find team. Check your Team ID and try again.');
                document.getElementById('setupLoading').style.display = 'none';
            }
        }

        function showSetupError(message) {
            const errorEl = document.getElementById('setupError');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function displayLeaguesList() {
            const container = document.getElementById('leaguesContainer');
            container.innerHTML = userLeagues.map(league => `
                <div class="league-option" onclick="selectSetupLeague(${league.id}, '${league.name.replace(/'/g, "\\'")}')">
                    <div>
                        <div class="league-name">${league.name}</div>
                        <div class="league-info">Your rank: #${league.rank || '?'}${league.isPublic ? ' (Public)' : ''}</div>
                    </div>
                    <span style="color: #00ff85;">→</span>
                </div>
            `).join('');
            document.getElementById('leaguesList').style.display = 'block';
        }

        function showStatus(message, isError = false) {
            const bar = document.getElementById('statusBar');
            const text = document.getElementById('statusText');
            if (bar && text) {
                text.textContent = message;
                text.style.color = isError ? '#ff4757' : '#04f5ff';
                bar.style.display = 'block';
            }
        }

        function hideStatus() {
            const bar = document.getElementById('statusBar');
            if (bar) bar.style.display = 'none';
        }

        function selectSetupLeague(leagueId, leagueName) {
            LEAGUE_ID = leagueId;
            showMainApp();
        }

        function populateLeagueDropdown() {
            const select = document.getElementById('leagueSelect');
            select.innerHTML = userLeagues.map(league =>
                `<option value="${league.id}">${league.name}</option>`
            ).join('');
            if (LEAGUE_ID) {
                select.value = LEAGUE_ID;
            }
        }

        function skipSetup() {
            // Show main app with empty dropdown
            userLeagues = [];
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('mainApp').style.display = 'block';
            document.getElementById('leagueSelect').innerHTML = '<option value="">Enter League ID →</option>';
        }

        function changeTeam() {
            localStorage.removeItem('fpl_team_id');
            localStorage.removeItem('fpl_user_leagues');
            userTeamId = null;
            userLeagues = [];
            LEAGUE_ID = null;
            showSetupScreen();
        }

        // Cache functions
        function getCacheKey(leagueId) {
            return `fpl_cache_${leagueId}`;
        }

        function loadFromCache(leagueId) {
            try {
                const cached = localStorage.getItem(getCacheKey(leagueId));
                if (cached) {
                    const data = JSON.parse(cached);
                    // Verify cache is for correct league and not expired (1 hour)
                    if (data.timestamp && Date.now() - data.timestamp < 3600000) {
                        // Validate league ID matches
                        if (data.leagueId && data.leagueId !== leagueId) {
                            console.warn('Cache league ID mismatch, clearing:', data.leagueId, 'vs', leagueId);
                            localStorage.removeItem(getCacheKey(leagueId));
                            return null;
                        }
                        console.log('Using cached data from', new Date(data.timestamp).toLocaleTimeString());
                        return data;
                    }
                }
            } catch (e) {
                console.warn('Cache read error:', e);
                localStorage.removeItem(getCacheKey(leagueId));
            }
            return null;
        }

        function saveToCache(leagueId, players, histories) {
            try {
                const data = {
                    timestamp: Date.now(),
                    players: players,
                    histories: histories
                };
                localStorage.setItem(getCacheKey(leagueId), JSON.stringify(data));
                console.log('Data cached for league', leagueId);
            } catch (e) {
                console.warn('Cache write error:', e);
            }
        }

        function setChartType(type) {
            currentChartType = type;
            // Update button states
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('btn-' + type).classList.add('active');
            updateChart();
        }

        function loadNewLeague() {
            const newId = document.getElementById('leagueId').value.trim();
            if (newId && !isNaN(newId)) {
                LEAGUE_ID = parseInt(newId);
                resetAndLoad();
            }
        }

        function selectLeague() {
            const select = document.getElementById('leagueSelect');
            const newLeagueId = parseInt(select.value);
            console.log('Selected league from dropdown:', newLeagueId, select.options[select.selectedIndex].text);
            LEAGUE_ID = newLeagueId;
            resetAndLoad();
        }

        function clearCacheAndReload() {
            console.log('Clearing cache for league:', LEAGUE_ID);
            localStorage.removeItem(getCacheKey(LEAGUE_ID));
            resetAndLoad();
        }

        function clearAllCaches() {
            console.log('Clearing ALL FPL caches');
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('fpl_cache_')) {
                    keysToRemove.push(key);
                }
            }
            keysToRemove.forEach(key => localStorage.removeItem(key));
            console.log('Cleared', keysToRemove.length, 'cache entries');
            resetAndLoad();
        }

        let isLoading = false;
        let loadingLeagueId = null;

        function resetAndLoad() {
            console.log('=== Switching to league:', LEAGUE_ID, '===');
            loadingLeagueId = LEAGUE_ID; // Track which league we're loading
            allPlayers = [];
            playerHistories = {};
            selectedEntries = new Set();
            hoveredEntry = null;
            livePoints = {};
            livePositions = {};
            livePlayerScores = null; // Reset live scores cache
            if (chart) chart.destroy();
            chart = null;
            document.getElementById('playerToggles').innerHTML = '<div class="loading"><div id="loadingText">Loading...</div><div style="margin-top: 10px;"><div id="loadingPercent" style="font-size: 20px; color: #00ff88;">0%</div></div></div>';
            loadAllData();
        }

        // High-contrast, colorblind-friendly palette (12 distinct colors)
        const colors = [
            '#FF6B6B', // Coral red
            '#4ECDC4', // Teal
            '#FFE66D', // Yellow
            '#6C5CE7', // Purple
            '#FF9F43', // Orange
            '#26DE81', // Green
            '#54A0FF', // Blue
            '#FF6EB4', // Pink
            '#A0522D', // Brown
            '#00D2D3', // Cyan
            '#8B5CF6', // Violet
            '#10B981', // Emerald
        ];

        async function fetchLeagueStandings() {
            console.log('fetchLeagueStandings for LEAGUE_ID:', LEAGUE_ID);
            const players = [];
            let page = 1;
            let hasNext = true;

            while (hasNext) {
                const url = `https://fantasy.premierleague.com/api/leagues-classic/${LEAGUE_ID}/standings/?page_standings=${page}`;
                const response = await fetchWithFallback(url);
                const data = await response.json();

                // Get league name from first page
                if (page === 1 && data.league) {
                    leagueName = data.league.name;
                    console.log('League name from API:', leagueName);
                    document.title = 'FPL Tracker - ' + leagueName;
                }

                players.push(...data.standings.results);
                hasNext = data.standings.has_next;
                page++;
            }

            return players;
        }

        async function fetchPlayerHistory(entryId, retries = 2) {
            const url = `https://fantasy.premierleague.com/api/entry/${entryId}/history/`;
            for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                    const response = await fetch(CORS_PROXY + url);
                    if (!response.ok) {
                        console.error(`HTTP error for entry ${entryId}: ${response.status}`);
                        if (attempt < retries) {
                            await new Promise(r => setTimeout(r, 500));
                            continue;
                        }
                        return null;
                    }
                    const text = await response.text();
                    const data = JSON.parse(text);
                    if (!data.current) {
                        console.error(`No 'current' field for entry ${entryId}:`, Object.keys(data));
                        return null;
                    }
                    return data.current;
                } catch (e) {
                    console.error(`Attempt ${attempt + 1} failed for entry ${entryId}:`, e.message);
                    if (attempt < retries) {
                        await new Promise(r => setTimeout(r, 500));
                        continue;
                    }
                    return null;
                }
            }
            return null;
        }

        async function fetchBootstrapStatic() {
            try {
                const url = 'https://fantasy.premierleague.com/api/bootstrap-static/';
                const response = await fetch(CORS_PROXY + url);
                const data = await response.json();

                // Log all gameweeks for debugging
                const gws = data.events.map(e => ({ id: e.id, is_current: e.is_current, is_next: e.is_next, finished: e.finished, deadline: e.deadline_time }));
                console.log('Gameweeks:', gws.filter(g => g.is_current || g.is_next));

                // Find current gameweek
                const currentGw = data.events.find(e => e.is_current);
                const nextGw = data.events.find(e => e.is_next);

                // Check if "next" gameweek has actually started (deadline passed)
                if (nextGw) {
                    const deadline = new Date(nextGw.deadline_time);
                    const now = new Date();
                    if (now > deadline) {
                        // Next GW deadline has passed, so it's actually the active one
                        currentGameweek = nextGw.id;
                        gameweekFinished = nextGw.finished;
                        console.log('Using NEXT gameweek (deadline passed):', currentGameweek, gameweekFinished ? '(finished)' : '(in progress)');
                        return { gameweek: nextGw.id, finished: nextGw.finished, isNext: true };
                    }
                }

                if (currentGw) {
                    currentGameweek = currentGw.id;
                    gameweekFinished = currentGw.finished;
                    console.log('Current gameweek:', currentGameweek, gameweekFinished ? '(finished)' : '(in progress)');
                    return { gameweek: currentGw.id, finished: currentGw.finished, isNext: false };
                }

                // Fallback to next - 1
                if (nextGw) {
                    currentGameweek = nextGw.id - 1;
                    return { gameweek: nextGw.id - 1, finished: true, isNext: true };
                }
                return null;
            } catch (e) {
                console.error('Failed to fetch bootstrap-static:', e);
                return null;
            }
        }

        // Cache for live player scores (fetched once per refresh)
        let livePlayerScores = null;

        async function fetchLivePlayerScores(gameweek) {
            if (livePlayerScores) return livePlayerScores;
            try {
                const url = `https://fantasy.premierleague.com/api/event/${gameweek}/live/`;
                const response = await fetch(CORS_PROXY + url);
                if (!response.ok) return null;
                const data = await response.json();
                // Build map of element_id -> total_points
                livePlayerScores = {};
                data.elements.forEach(el => {
                    livePlayerScores[el.id] = el.stats.total_points;
                });
                console.log('Fetched live scores for', Object.keys(livePlayerScores).length, 'players');
                return livePlayerScores;
            } catch (e) {
                console.error('Failed to fetch live player scores:', e);
                return null;
            }
        }

        async function fetchLivePoints(entryId, gameweek) {
            try {
                // Get manager's picks
                const url = `https://fantasy.premierleague.com/api/entry/${entryId}/event/${gameweek}/picks/`;
                const response = await fetch(CORS_PROXY + url);
                if (!response.ok) return null;
                const data = await response.json();
                const h = data.entry_history;

                // Get live player scores
                const playerScores = await fetchLivePlayerScores(gameweek);

                // Calculate live points from picks
                let calculatedPoints = 0;
                if (playerScores && data.picks) {
                    for (const pick of data.picks) {
                        // Only count players in starting 11 (position 1-11)
                        if (pick.position <= 11) {
                            const playerPoints = playerScores[pick.element] || 0;
                            calculatedPoints += playerPoints * pick.multiplier;
                        }
                    }
                }

                // Use calculated points if API points is 0 (not yet updated)
                const points = h.points > 0 ? h.points : calculatedPoints;
                const transferCost = h.event_transfers_cost || 0;
                const netPoints = points - transferCost;

                // Get active chip (bboost, 3xc, freehit, wildcard)
                const activeChip = data.active_chip || null;

                return {
                    points: points,
                    netPoints: netPoints,
                    transferCost: transferCost,
                    totalPoints: h.total_points,
                    rank: h.rank,
                    chip: activeChip
                };
            } catch (e) {
                console.error(`Failed to fetch live points for ${entryId}:`, e);
                return null;
            }
        }

        async function refreshLiveData() {
            if (!currentGameweek || allPlayers.length === 0) {
                console.log('refreshLiveData skipped: currentGameweek=', currentGameweek, 'allPlayers.length=', allPlayers.length);
                return;
            }

            console.log('Refreshing live data for GW', currentGameweek, '- fetching for', allPlayers.length, 'players');
            const refreshBtn = document.getElementById('refreshLiveBtn');
            if (refreshBtn) {
                refreshBtn.textContent = 'Updating...';
                refreshBtn.disabled = true;
            }

            // Clear cached player scores to get fresh data
            livePlayerScores = null;

            const newLivePoints = {};

            // Fetch live data for ALL players so sidebar shows complete info
            for (let i = 0; i < allPlayers.length; i++) {
                const player = allPlayers[i];
                const live = await fetchLivePoints(player.entry, currentGameweek);
                if (live) {
                    newLivePoints[player.entry] = {
                        points: live.points,
                        netPoints: live.netPoints,
                        transferCost: live.transferCost,
                        totalPoints: live.totalPoints,
                        chip: live.chip,
                        isLive: true
                    };
                }

                // Update progress
                if (refreshBtn && i % 5 === 0) {
                    refreshBtn.textContent = `${Math.round((i / allPlayers.length) * 100)}%`;
                }

                await new Promise(r => setTimeout(r, 50)); // Faster delay for bulk fetch
            }

            livePoints = newLivePoints;
            console.log('Live data fetched for', Object.keys(newLivePoints).length, 'players');

            // Calculate previous GW positions (before current GW started)
            // We need to find the gameweek BEFORE the current one
            const prevGwIndex = currentGameweek - 2; // e.g., if current is GW24, we want index 22 (GW23)

            const prevGwRankings = allPlayers.map(p => {
                const history = playerHistories[p.entry] || [];
                // Get the total points at end of previous gameweek (not current)
                const prevGwData = prevGwIndex >= 0 && history[prevGwIndex] ? history[prevGwIndex] : null;
                const prevTotal = prevGwData ? prevGwData.total_points : 0;
                return { entry: p.entry, prevTotal };
            }).sort((a, b) => b.prevTotal - a.prevTotal);

            const prevPositions = {};
            prevGwRankings.forEach((item, idx) => {
                prevPositions[item.entry] = idx + 1;
            });

            // Debug: show previous positions
            const prevPosDebug = prevGwRankings.slice(0, 10).map((r, i) => {
                const player = allPlayers.find(p => p.entry === r.entry);
                return `#${i+1}: ${player ? player.player_name : r.entry} (${r.prevTotal} pts)`;
            });
            console.log('Previous GW positions (end of GW' + (currentGameweek - 1) + '):', prevPosDebug);

            // Calculate live positions using: previous total + current GW live points
            const liveRankings = allPlayers.map(p => {
                const live = newLivePoints[p.entry];
                const history = playerHistories[p.entry] || [];
                // Get previous total (before current GW) - use prevGwIndex
                const prevGwData = prevGwIndex >= 0 && history[prevGwIndex] ? history[prevGwIndex] : null;
                const previousTotal = prevGwData ? prevGwData.total_points : 0;
                // Add live GW points (net of hits)
                const liveTotal = live ? previousTotal + live.netPoints : previousTotal;
                return { entry: p.entry, total: liveTotal, oldRank: prevPositions[p.entry] || p.rank, liveGwPoints: live ? live.netPoints : 0 };
            }).sort((a, b) => b.total - a.total);

            // Debug: show live rankings with names
            const liveDebug = liveRankings.slice(0, 10).map((r, i) => {
                const player = allPlayers.find(p => p.entry === r.entry);
                return `#${i+1}: ${player ? player.player_name : r.entry} (${r.total} pts, was #${r.oldRank}, GW+${r.liveGwPoints})`;
            });
            console.log('Live rankings (GW' + currentGameweek + '):', liveDebug);

            livePositions = {};
            liveRankings.forEach((item, idx) => {
                const newRank = idx + 1;
                const movement = item.oldRank - newRank; // positive = moved up
                livePositions[item.entry] = { position: newRank, movement };
            });

            if (refreshBtn) {
                refreshBtn.textContent = 'Refresh Live';
                refreshBtn.disabled = false;
            }

            console.log('Live data updated:', Object.keys(livePoints).length, 'players');
            renderPlayerToggles();
            if (currentFilter) filterPlayers(currentFilter);
            updateChart();
        }

        async function loadAllData() {
            const targetLeague = LEAGUE_ID;
            isLoading = true;
            try {
                showStatus('Loading league data...');
                console.log('Loading data for league:', LEAGUE_ID);

                // Abort if league changed
                if (LEAGUE_ID !== targetLeague) {
                    console.log('League changed, aborting load');
                    return;
                }

                // Fetch current gameweek info
                await fetchBootstrapStatic();

                // Check cache first
                const cached = loadFromCache(LEAGUE_ID);
                console.log('Cache result:', cached ? `found (${cached.leagueName}, ${cached.players?.length} players)` : 'not found');
                if (cached && cached.players && cached.players.length > 0) {
                    allPlayers = cached.players;
                    playerHistories = cached.histories || {};
                    leagueName = cached.leagueName || 'FPL League';
                    console.log('Using cached league:', leagueName, 'with', allPlayers.length, 'players');
                    document.title = 'FPL Tracker - ' + leagueName;

                    // Select top 10 by default
                    allPlayers.slice(0, 10).forEach(p => selectedEntries.add(p.entry));

                    // Populate week range selectors
                    weekRangeEnd = currentGameweek || 38;
                    populateWeekSelectors();

                    renderPlayerToggles();
                    updateChart();
                    hideStatus();

                    // Auto-fetch live data for current gameweek
                    if (currentGameweek) {
                        console.log('Auto-fetching live data for GW', currentGameweek, gameweekFinished ? '(finished)' : '(in progress)');
                        showStatus('Fetching live scores...');
                        refreshLiveData().then(hideStatus);
                    }

                    // Refresh in background
                    document.getElementById('loadingText').textContent = 'Updating...';
                    document.getElementById('loadingPercent').textContent = '';
                    fetchFreshData();
                    return;
                }

                document.getElementById('loadingText').textContent = 'Loading league...';
                await fetchFreshData();

            } catch (error) {
                console.error('Error loading data:', error);
                fetchRetryCount++;

                if (fetchRetryCount < MAX_FETCH_RETRIES) {
                    const retryDelay = fetchRetryCount * 2000; // 2s, 4s, 6s
                    showStatus(`Error loading. Retrying in ${retryDelay/1000}s... (attempt ${fetchRetryCount + 1}/${MAX_FETCH_RETRIES})`, true);
                    console.log(`Auto-retry ${fetchRetryCount}/${MAX_FETCH_RETRIES} in ${retryDelay}ms`);

                    setTimeout(() => {
                        if (LEAGUE_ID === targetLeague) {
                            loadAllData();
                        }
                    }, retryDelay);
                } else {
                    showStatus('Error loading league data. Please try again later.', true);
                    fetchRetryCount = 0; // Reset for next manual attempt
                    if (allPlayers.length === 0) {
                        document.getElementById('playerToggles').innerHTML =
                            '<div class="loading">Error loading after multiple attempts. <br><button class="btn btn-top-10" onclick="fetchRetryCount=0; resetAndLoad();" style="margin-top: 10px;">Try Again</button></div>';
                    }
                }
            } finally {
                isLoading = false;
            }
        }

        async function fetchFreshData() {
            const fetchingLeagueId = LEAGUE_ID; // Capture current league at start
            try {
                console.log('Fetching fresh data for league:', fetchingLeagueId);
                const freshPlayers = await fetchLeagueStandings();
                freshPlayers.sort((a, b) => a.rank - b.rank);

                const freshHistories = {};
                let loadedCount = 0;
                const failedPlayers = [];

                for (let i = 0; i < freshPlayers.length; i++) {
                    // Abort if league changed during loading
                    if (LEAGUE_ID !== fetchingLeagueId) {
                        console.log('League changed during load, aborting');
                        return;
                    }
                    const player = freshPlayers[i];
                    try {
                        const history = await fetchPlayerHistory(player.entry);
                        if (history && Array.isArray(history) && history.length > 0) {
                            freshHistories[player.entry] = history;
                            loadedCount++;
                            console.log(`✓ ${player.player_name}: ${history.length} gameweeks`);
                        } else {
                            // Use cached history if available
                            if (playerHistories[player.entry] && playerHistories[player.entry].length > 0) {
                                freshHistories[player.entry] = playerHistories[player.entry];
                                console.log(`○ ${player.player_name}: using cached data`);
                            } else {
                                console.warn(`✗ Empty history for ${player.player_name} (entry: ${player.entry})`);
                                freshHistories[player.entry] = [];
                                failedPlayers.push(player.player_name);
                            }
                        }
                    } catch (e) {
                        // Use cached history if available
                        if (playerHistories[player.entry] && playerHistories[player.entry].length > 0) {
                            freshHistories[player.entry] = playerHistories[player.entry];
                            console.log(`○ ${player.player_name}: using cached data (error)`);
                        } else {
                            console.error(`✗ Failed to load ${player.player_name}:`, e);
                            freshHistories[player.entry] = [];
                            failedPlayers.push(player.player_name);
                        }
                    }

                    const percent = Math.round(((i + 1) / freshPlayers.length) * 100);
                    const loadingPercent = document.getElementById('loadingPercent');
                    const loadingText = document.getElementById('loadingText');
                    if (loadingPercent) loadingPercent.textContent = percent + '%';
                    if (loadingText) loadingText.textContent = `Loading ${i + 1}/${freshPlayers.length}`;

                    // Small delay to avoid rate limiting
                    await new Promise(resolve => setTimeout(resolve, 150));
                }

                console.log(`=== SUMMARY: Loaded ${loadedCount}/${freshPlayers.length} player histories ===`);
                if (failedPlayers.length > 0) {
                    console.warn('Failed players:', failedPlayers);
                }

                // Check if user switched leagues during fetch - abort if so
                if (LEAGUE_ID !== fetchingLeagueId) {
                    console.warn('League changed during fetch, discarding results for', fetchingLeagueId);
                    return;
                }

                // Update global state
                allPlayers = freshPlayers;
                playerHistories = freshHistories;

                // Save to cache (include league ID for validation)
                const cacheData = {
                    timestamp: Date.now(),
                    leagueId: fetchingLeagueId,
                    players: allPlayers,
                    histories: playerHistories,
                    leagueName: leagueName
                };
                localStorage.setItem(getCacheKey(fetchingLeagueId), JSON.stringify(cacheData));
                console.log('Data cached for league', fetchingLeagueId, 'with', allPlayers.length, 'players');

                // If first load (no selection yet), select top 10
                if (selectedEntries.size === 0) {
                    allPlayers.slice(0, 10).forEach(p => selectedEntries.add(p.entry));
                }

                // Populate week range selectors
                weekRangeEnd = currentGameweek || 38;
                populateWeekSelectors();

                renderPlayerToggles();
                if (currentFilter) filterPlayers(currentFilter);
                updateChart();
                hideStatus();

                // Auto-fetch live data for current gameweek
                if (currentGameweek) {
                    console.log('Auto-fetching live data after fresh load for GW', currentGameweek);
                    showStatus('Fetching live scores...');
                    refreshLiveData().then(hideStatus);
                }

            } catch (error) {
                console.error('Error fetching fresh data:', error);
                showStatus('Error loading data. Using cached data if available.', true);
                // If we have data (cached or partial), keep using it and render
                if (allPlayers.length > 0) {
                    console.log('Keeping existing data due to error');
                    renderPlayerToggles();
                    if (currentFilter) filterPlayers(currentFilter);
                    updateChart();
                } else {
                    document.getElementById('playerToggles').innerHTML =
                        '<div class="loading">Error loading. Refresh page.</div>';
                }
            }
        }

        function renderPlayerToggles() {
            const container = document.getElementById('playerToggles');
            if (!allPlayers || allPlayers.length === 0) {
                container.innerHTML = '<div class="loading">No players found</div>';
                return;
            }
            console.log('Rendering', allPlayers.length, 'player toggles');

            // Sort players by live position if available, otherwise by API rank
            const sortedPlayers = [...allPlayers].sort((a, b) => {
                const posA = livePositions[a.entry] ? livePositions[a.entry].position : a.rank;
                const posB = livePositions[b.entry] ? livePositions[b.entry].position : b.rank;
                return posA - posB;
            });

            container.innerHTML = sortedPlayers.map((player) => {
                const isSelected = selectedEntries.has(player.entry);
                // Use original index for consistent colors
                const originalIndex = allPlayers.findIndex(p => p.entry === player.entry);
                const color = colors[originalIndex % colors.length];
                const live = livePoints[player.entry];
                const posData = livePositions[player.entry];

                // Calculate display values
                let pointsDisplay = player.total;
                let liveIndicator = '';
                let movementIndicator = '';

                // Use live position if available, otherwise API rank
                const displayRank = posData ? posData.position : player.rank;

                if (live && live.isLive) {
                    // Calculate projected total
                    const projectedTotal = player.total + live.netPoints;

                    // Build detailed tooltip
                    const chipAbbrev = { 'bboost': 'BB', '3xc': 'TC', 'freehit': 'FH', 'wildcard': 'WC' };
                    let tooltipParts = [
                        `GW${currentGameweek} Points: ${live.points}`,
                        `Hit Taken: ${live.transferCost > 0 ? '-' + live.transferCost : '0'}`,
                        `Net GW Points: ${live.netPoints}`,
                        `Chip Used: ${live.chip ? chipAbbrev[live.chip] || live.chip : 'None'}`,
                        `---`,
                        `Base Total: ${player.total}`,
                        `Projected Total: ${projectedTotal}`
                    ];
                    const tooltip = tooltipParts.join('\n');

                    // Style: orange if hit, cyan if chip, green otherwise
                    let pointStyle = 'color: #00ff85;';
                    if (live.transferCost > 0) pointStyle = 'color: #ffaa00;';
                    if (live.chip) pointStyle = 'color: #04f5ff;';

                    // Chip badge (chipAbbrev already defined above)
                    let chipBadge = '';
                    if (live.chip) {
                        chipBadge = `<span style="background: #04f5ff; color: #37003c; font-size: 8px; padding: 1px 3px; border-radius: 3px; margin-left: 3px; font-weight: bold;">${chipAbbrev[live.chip] || live.chip}</span>`;
                    }

                    // Hit indicator badge (show if hit taken)
                    let hitBadge = '';
                    if (live.transferCost > 0) {
                        hitBadge = `<span style="background: #ffaa00; color: #37003c; font-size: 8px; padding: 1px 3px; border-radius: 3px; margin-left: 3px; font-weight: bold;">-${live.transferCost}</span>`;
                    }

                    // Show: base total (GW pts) -> use projected as main display
                    pointsDisplay = projectedTotal;
                    liveIndicator = `<span style="${pointStyle} font-size: 10px; margin-left: 4px; cursor: help;" title="${tooltip}">(GW +${live.netPoints})</span>${hitBadge}${chipBadge}`;
                }

                if (posData && posData.movement !== 0) {
                    if (posData.movement > 0) {
                        movementIndicator = `<span style="color: #00ff88; font-size: 10px;">▲${posData.movement}</span>`;
                    } else {
                        movementIndicator = `<span style="color: #ff4757; font-size: 10px;">▼${Math.abs(posData.movement)}</span>`;
                    }
                }

                // Build expandable detail section for mobile
                let detailSection = '';
                if (live && live.isLive) {
                    const projectedTotal = player.total + live.netPoints;
                    const chipAbbrev = { 'bboost': 'Bench Boost', '3xc': 'Triple Captain', 'freehit': 'Free Hit', 'wildcard': 'Wildcard' };
                    detailSection = `
                    <div class="player-details" id="details-${player.entry}" style="display: none;">
                        <div class="detail-row"><span>GW${currentGameweek} Points:</span><span style="color: #00ff85;">${live.points}</span></div>
                        ${live.transferCost > 0 ? `<div class="detail-row"><span>Hit Taken:</span><span style="color: #ffaa00;">-${live.transferCost}</span></div>` : ''}
                        <div class="detail-row"><span>Net GW Points:</span><span style="color: #04f5ff;">${live.netPoints}</span></div>
                        ${live.chip ? `<div class="detail-row"><span>Chip:</span><span style="color: #04f5ff;">${chipAbbrev[live.chip] || live.chip}</span></div>` : ''}
                        <div class="detail-row"><span>Projected Total:</span><span style="font-weight: bold;">${projectedTotal}</span></div>
                    </div>`;
                }

                return `
                <div class="player-wrapper">
                    <label class="player-toggle ${isSelected ? 'selected' : ''}" id="toggle-${player.entry}"
                           onmouseenter="hoverPlayer(${player.entry})"
                           onmouseleave="hoverPlayer(null)"
                           onclick="toggleDetails(${player.entry}, event)"
                           style="border-left: 4px solid ${isSelected ? color : 'transparent'};">
                        <input type="checkbox"
                               data-entry="${player.entry}"
                               ${isSelected ? 'checked' : ''}
                               onchange="togglePlayer(${player.entry}, this.checked)">
                        <span class="rank">#${displayRank} ${movementIndicator}</span>
                        <span class="color-dot" style="background: ${color}; box-shadow: 0 0 4px ${color};"></span>
                        <span class="player-name" title="${player.player_name} - ${player.entry_name}">${player.player_name}</span>
                        <span class="points">${pointsDisplay}${liveIndicator}</span>
                        ${live && live.isLive ? '<span class="expand-icon">ℹ️</span>' : ''}
                    </label>
                    ${detailSection}
                </div>
            `}).join('');
        }

        function toggleDetails(entryId, event) {
            // Don't toggle if clicking the checkbox
            if (event.target.type === 'checkbox') return;

            const details = document.getElementById(`details-${entryId}`);
            if (details) {
                const isVisible = details.style.display !== 'none';
                // Hide all other details
                document.querySelectorAll('.player-details').forEach(d => d.style.display = 'none');
                // Toggle this one
                details.style.display = isVisible ? 'none' : 'block';
            }
        }

        function hoverPlayer(entryId) {
            if (hoveredEntry !== entryId) {
                hoveredEntry = entryId;
                updateChart();
            }
        }

        function togglePlayer(entryId, isChecked) {
            if (isChecked) {
                selectedEntries.add(entryId);
            } else {
                selectedEntries.delete(entryId);
            }

            // Update visual state
            const toggle = document.getElementById(`toggle-${entryId}`);
            if (toggle) {
                toggle.classList.toggle('selected', isChecked);
                const playerIndex = allPlayers.findIndex(p => p.entry === entryId);
                const color = colors[playerIndex % colors.length];
                toggle.style.borderLeftColor = isChecked ? color : 'transparent';
            }

            updateChart();
        }

        function updateChart() {
            const selectedPlayers = allPlayers.filter(p => selectedEntries.has(p.entry));
            const chartType = currentChartType;

            if (selectedPlayers.length === 0) {
                if (chart) chart.destroy();
                chart = null;
                return;
            }

            // Get histories only for selected players in current league
            const selectedHistories = selectedPlayers.map(p => playerHistories[p.entry]).filter(h => h && h.length > 0);

            if (selectedHistories.length === 0) {
                console.warn('No history data available');
                return;
            }

            let maxGameweeks = Math.max(...selectedHistories.map(h => h.length));

            // If we have live data, add one more gameweek
            const hasAnyLiveData = Object.keys(livePoints).length > 0 && currentGameweek;
            if (hasAnyLiveData && currentGameweek > maxGameweeks) {
                maxGameweeks = currentGameweek;
            }

            // Apply week range filter
            const rangeStart = weekRangeStart;
            const rangeEnd = Math.min(weekRangeEnd, maxGameweeks);

            const labels = [];
            for (let gwNum = rangeStart; gwNum <= rangeEnd; gwNum++) {
                if (hasAnyLiveData && gwNum === currentGameweek) {
                    labels.push(`GW${gwNum} ⚡`);
                } else {
                    labels.push(`GW${gwNum}`);
                }
            }

            // Pre-calculate all positions for rank mode (need all players, not just selected)
            const allPositions = {};
            if (chartType === 'rank') {
                for (let gwIdx = 0; gwIdx < maxGameweeks; gwIdx++) {
                    // Get all players' totals at this gameweek
                    const gwTotals = allPlayers.map(p => {
                        const h = playerHistories[p.entry];
                        return {
                            entry: p.entry,
                            total: h && h[gwIdx] ? h[gwIdx].total_points : 0
                        };
                    }).sort((a, b) => b.total - a.total);

                    // Assign positions
                    gwTotals.forEach((item, idx) => {
                        if (!allPositions[item.entry]) allPositions[item.entry] = [];
                        allPositions[item.entry][gwIdx] = idx + 1;
                    });
                }
            }

            // Calculate final values for label positioning (use last gameweek for all)
            const finalValues = selectedPlayers.map(player => {
                const history = playerHistories[player.entry] || [];
                if (history.length === 0) return { player, value: 0 };
                // Use the actual last gameweek data for value calculation
                const lastIdx = Math.min(history.length - 1, maxGameweeks - 1);
                const lastGw = history[lastIdx];
                let value;
                if (chartType === 'rank') {
                    // Use position at the final gameweek
                    value = allPositions[player.entry] ? allPositions[player.entry][maxGameweeks - 1] || allPositions[player.entry][lastIdx] : 999;
                } else {
                    value = chartType === 'total' ? (lastGw ? lastGw.total_points : 0) : (lastGw ? lastGw.points : 0);
                }
                return { player, value };
            }).sort((a, b) => chartType === 'rank' ? a.value - b.value : b.value - a.value);

            // Assign label offsets to prevent overlap
            const labelOffsets = {};
            finalValues.forEach((item, idx) => {
                // Alternate labels up/down when close together
                labelOffsets[item.player.entry] = (idx % 2 === 0) ? -5 : 15;
            });

            const datasets = selectedPlayers.map((player) => {
                const history = playerHistories[player.entry] || [];
                const playerIndex = allPlayers.findIndex(p => p.entry === player.entry);
                let data = [];

                if (history.length === 0) {
                    console.warn(`No history for ${player.player_name}`);
                    return null;
                }

                // Check for live data
                const live = livePoints[player.entry];
                const hasLiveData = live && live.isLive && currentGameweek;

                if (chartType === 'total') {
                    data = history.map(gw => gw ? gw.total_points : null);
                    // For live gameweek, calculate projected total: previous GW total + live net points
                    if (hasLiveData && currentGameweek) {
                        // Get previous GW total (last entry in history, or second-to-last if history includes current GW)
                        const prevGwIdx = currentGameweek - 2; // e.g., GW23 when current is GW24
                        const prevTotal = prevGwIdx >= 0 && history[prevGwIdx] ? history[prevGwIdx].total_points : (data.length > 0 ? data[data.length - 1] : 0);
                        const projectedTotal = prevTotal + live.netPoints;

                        // Replace or add the projected total for current GW
                        if (data.length >= currentGameweek) {
                            data[currentGameweek - 1] = projectedTotal;
                        } else {
                            while (data.length < currentGameweek - 1) {
                                data.push(data.length > 0 ? data[data.length - 1] : null);
                            }
                            data.push(projectedTotal);
                        }
                    }
                } else if (chartType === 'weekly') {
                    data = history.map(gw => gw ? gw.points : null);
                    // For current live gameweek, use our calculated netPoints (includes hits)
                    if (hasLiveData && currentGameweek) {
                        // If history includes current GW with 0/wrong value, replace it
                        if (data.length >= currentGameweek) {
                            data[currentGameweek - 1] = live.netPoints;
                        } else {
                            // Add live netPoints for current GW
                            while (data.length < currentGameweek - 1) {
                                data.push(null);
                            }
                            data.push(live.netPoints);
                        }
                    }
                } else if (chartType === 'rank') {
                    // Use pre-calculated positions
                    data = allPositions[player.entry] ? [...allPositions[player.entry]] : [];
                    // For live gameweek, replace or add the live position
                    if (hasLiveData && livePositions[player.entry]) {
                        const livePos = livePositions[player.entry].position;
                        // If data already has current GW, replace it; otherwise add it
                        if (data.length >= currentGameweek) {
                            data[currentGameweek - 1] = livePos;
                        } else {
                            // Pad if needed and add live position
                            while (data.length < currentGameweek - 1) {
                                data.push(data.length > 0 ? data[data.length - 1] : null);
                            }
                            data.push(livePos);
                        }
                    }
                }

                // Pad data array to maxGameweeks so all labels align at the end
                while (data.length < maxGameweeks) {
                    data.push(data.length > 0 ? data[data.length - 1] : null);
                }

                // Slice data to week range (0-indexed: rangeStart-1 to rangeEnd)
                data = data.slice(rangeStart - 1, rangeEnd);

                const isHovered = hoveredEntry === player.entry;
                const isDimmed = hoveredEntry !== null && !isHovered;
                const baseColor = colors[playerIndex % colors.length];

                // Create point styles array - last point is live if we have live data
                const pointRadii = data.map((_, idx) => {
                    if (hasLiveData && idx === data.length - 1) {
                        return 8; // Larger for live point
                    }
                    return isHovered ? 5 : (isDimmed ? 2 : 3);
                });

                const pointBgColors = data.map((_, idx) => {
                    if (hasLiveData && idx === data.length - 1) {
                        return '#00ff88'; // Green for live point
                    }
                    return isDimmed ? baseColor + '40' : baseColor;
                });

                const pointBorderColors = data.map((_, idx) => {
                    if (hasLiveData && idx === data.length - 1) {
                        return '#ffffff'; // White border for live point
                    }
                    return isDimmed ? baseColor + '40' : baseColor;
                });

                const pointBorderWidths = data.map((_, idx) => {
                    if (hasLiveData && idx === data.length - 1) {
                        return 2; // Thicker border for live point
                    }
                    return 1;
                });

                return {
                    label: player.player_name,
                    data: data,
                    borderColor: isDimmed ? baseColor + '40' : baseColor,
                    backgroundColor: baseColor + '20',
                    fill: false,
                    tension: 0.2,
                    pointRadius: pointRadii,
                    pointBackgroundColor: pointBgColors,
                    pointBorderColor: pointBorderColors,
                    pointBorderWidth: pointBorderWidths,
                    pointHoverRadius: 8,
                    borderWidth: isHovered ? 4 : (isDimmed ? 1 : 2.5),
                    datalabels: {
                        display: false // Using custom endLabels plugin instead
                    }
                };
            }).filter(d => d !== null);

            if (datasets.length === 0) {
                console.warn('No valid datasets');
                return;
            }

            if (chart) chart.destroy();

            const ctx = document.getElementById('mainChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                plugins: [ChartDataLabels, {
                    id: 'endLabels',
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;

                        chart.data.datasets.forEach((dataset, i) => {
                            const meta = chart.getDatasetMeta(i);
                            if (!meta.hidden && meta.data.length > 0) {
                                // Find the last point with valid data
                                let lastPoint = null;
                                for (let j = meta.data.length - 1; j >= 0; j--) {
                                    const point = meta.data[j];
                                    const dataValue = dataset.data[j];
                                    if (point && dataValue !== null && dataValue !== undefined &&
                                        !isNaN(point.x) && !isNaN(point.y)) {
                                        lastPoint = point;
                                        break;
                                    }
                                }

                                if (lastPoint) {
                                    const x = lastPoint.x + 10;
                                    // Clamp y to stay within chart area with some padding
                                    let y = lastPoint.y;
                                    const minY = chartArea.top + 10;
                                    const maxY = chartArea.bottom - 10;
                                    if (y < minY) y = minY;
                                    if (y > maxY) y = maxY;

                                    const firstName = dataset.label.split(' ')[0];

                                    // Find player's position movement
                                    const player = selectedPlayers.find(p => p.player_name === dataset.label);
                                    const posData = player ? livePositions[player.entry] : null;
                                    let movementText = '';
                                    let movementColor = '';
                                    if (posData && posData.movement !== 0) {
                                        if (posData.movement > 0) {
                                            movementText = ' ▲' + posData.movement;
                                            movementColor = '#00ff85';
                                        } else {
                                            movementText = ' ▼' + Math.abs(posData.movement);
                                            movementColor = '#ff4757';
                                        }
                                    }

                                    ctx.save();
                                    ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';

                                    // Draw name with stroke for visibility
                                    ctx.fillStyle = dataset.borderColor;
                                    ctx.strokeStyle = '#37003c';
                                    ctx.lineWidth = 3;
                                    ctx.strokeText(firstName, x, y + 3);
                                    ctx.fillText(firstName, x, y + 3);

                                    // Draw movement indicator
                                    if (movementText) {
                                        const nameWidth = ctx.measureText(firstName).width;
                                        ctx.fillStyle = movementColor;
                                        ctx.strokeText(movementText, x + nameWidth, y + 3);
                                        ctx.fillText(movementText, x + nameWidth, y + 3);
                                    }

                                    ctx.restore();
                                }
                            }
                        });
                    }
                }],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            right: 100,
                            top: 10
                        }
                    },
                    clip: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: (items) => items[0].label,
                                label: (item) => `${item.dataset.label}: ${item.raw}`
                            }
                        },
                        datalabels: {
                            display: false // Using custom endLabels plugin
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#888', maxRotation: 45 },
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            clip: false
                        },
                        y: {
                            reverse: chartType === 'rank',
                            min: chartType === 'rank' ? 1 : undefined,
                            max: chartType === 'rank' ? allPlayers.length : undefined,
                            ticks: {
                                color: '#888',
                                stepSize: chartType === 'rank' ? 1 : undefined,
                                callback: function(value) {
                                    if (chartType === 'rank') {
                                        return Number.isInteger(value) ? value : '';
                                    }
                                    return value;
                                }
                            },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            title: {
                                display: true,
                                text: chartType === 'total' ? 'Total Points' :
                                      chartType === 'weekly' ? 'Weekly Points' : 'League Position',
                                color: '#888'
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }

        function selectAll() {
            selectedEntries = new Set(allPlayers.map(p => p.entry));
            renderPlayerToggles();
            if (currentFilter) filterPlayers(currentFilter);
            updateChart();
        }

        function clearAll() {
            selectedEntries = new Set();
            renderPlayerToggles();
            if (currentFilter) filterPlayers(currentFilter);
            updateChart();
        }

        function selectTop10() {
            selectedEntries = new Set(allPlayers.slice(0, 10).map(p => p.entry));
            renderPlayerToggles();
            if (currentFilter) filterPlayers(currentFilter);
            updateChart();
        }

        function filterPlayers(searchTerm) {
            currentFilter = searchTerm.toLowerCase().trim();
            const toggles = document.querySelectorAll('.player-toggle');
            let visibleCount = 0;

            toggles.forEach(toggle => {
                const playerName = toggle.querySelector('.player-name').textContent.toLowerCase();
                const teamName = toggle.querySelector('.player-name').title?.toLowerCase() || '';
                const matches = playerName.includes(currentFilter) || teamName.includes(currentFilter);
                toggle.style.display = matches ? '' : 'none';
                if (matches) visibleCount++;
            });

            // Show/hide "Select Filtered" button
            const selectFilteredBtn = document.getElementById('selectFilteredBtn');
            if (selectFilteredBtn) {
                selectFilteredBtn.style.display = currentFilter && visibleCount > 0 ? '' : 'none';
                selectFilteredBtn.textContent = `Select (${visibleCount})`;
            }
        }

        function selectFiltered() {
            if (!currentFilter) return;
            const filter = currentFilter;
            allPlayers.forEach(player => {
                const playerName = player.player_name.toLowerCase();
                const teamName = (player.entry_name || '').toLowerCase();
                if (playerName.includes(filter) || teamName.includes(filter)) {
                    selectedEntries.add(player.entry);
                }
            });
            renderPlayerToggles();
            filterPlayers(currentFilter); // Re-apply filter after render
            updateChart();
        }

        function populateWeekSelectors() {
            const maxGw = currentGameweek || 38;
            const startSelect = document.getElementById('weekStart');
            const endSelect = document.getElementById('weekEnd');

            startSelect.innerHTML = '';
            endSelect.innerHTML = '';

            for (let i = 1; i <= maxGw; i++) {
                startSelect.innerHTML += `<option value="${i}">GW${i}</option>`;
                endSelect.innerHTML += `<option value="${i}">GW${i}</option>`;
            }

            startSelect.value = weekRangeStart;
            endSelect.value = Math.min(weekRangeEnd, maxGw);
            weekRangeEnd = Math.min(weekRangeEnd, maxGw);
        }

        function updateWeekRange() {
            const start = parseInt(document.getElementById('weekStart').value);
            const end = parseInt(document.getElementById('weekEnd').value);

            if (start > end) {
                document.getElementById('weekEnd').value = start;
                weekRangeEnd = start;
            } else {
                weekRangeEnd = end;
            }
            weekRangeStart = start;
            updateChart();
        }

        function resetWeekRange() {
            weekRangeStart = 1;
            weekRangeEnd = currentGameweek || 38;
            document.getElementById('weekStart').value = 1;
            document.getElementById('weekEnd').value = weekRangeEnd;
            updateChart();
        }

        // Start app
        initApp();
    </script>
</body>
</html>
