<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPL League Tracker</title>
    <meta name="description" content="Track your Fantasy Premier League mini-leagues with live scores, charts, auto-sub predictions, and bonus point tracking.">

    <!-- Preconnect to external domains for faster loading -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://fpl-proxy.dom-mackie.workers.dev" crossorigin>
    <link rel="preconnect" href="https://site.api.espn.com" crossorigin>
    <link rel="dns-prefetch" href="https://fantasy.premierleague.com">

    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%2337003c' width='100' height='100' rx='15'/><path d='M20 70 L35 45 L50 55 L65 30 L80 40' stroke='%2300ff85' stroke-width='6' fill='none' stroke-linecap='round' stroke-linejoin='round'/><circle cx='80' cy='40' r='6' fill='%2304f5ff'/></svg>">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'PremierSans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(180deg, #37003c 0%, #2d0032 50%, #1a001d 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(90deg, #00ff85, #04f5ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .subtitle {
            text-align: center;
            color: #b8b8b8;
            margin-bottom: 30px;
            font-weight: 500;
        }
        .fixture-ticker {
            background: rgba(0,0,0,0.4);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding: 8px 0;
            margin-bottom: 15px;
            overflow: hidden;
            position: relative;
        }
        .ticker-wrapper {
            display: flex;
            animation: ticker-scroll 120s linear infinite;
            width: max-content;
        }
        .ticker-wrapper:hover {
            animation-play-state: paused;
        }
        .fixture-item {
            display: inline-flex;
            align-items: center;
            padding: 0 20px;
            white-space: nowrap;
            font-size: 12px;
            border-right: 1px solid rgba(255,255,255,0.2);
        }
        .fixture-item:last-child {
            border-right: none;
        }
        .fixture-teams {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .fixture-score {
            font-weight: 700;
            color: #fff;
            margin: 0 6px;
            font-size: 11px;
        }
        .fixture-status {
            font-size: 10px;
            margin-left: 8px;
            padding: 2px 6px;
            border-radius: 3px;
        }
        .fixture-status.live {
            background: #e90052;
            color: #fff;
        }
        .fixture-status.ft {
            background: #00ff85;
            color: #37003c;
        }
        .fixture-status.upcoming {
            background: rgba(255,255,255,0.2);
            color: #b8b8b8;
        }
        .team-abbr {
            color: #b8b8b8;
            font-weight: 500;
            font-size: 11px;
        }
        .team-abbr.home {
            color: #fff;
        }
        .goal-scorers {
            font-size: 10px;
            color: #00ff85;
            margin-left: 8px;
            white-space: nowrap;
        }
        @keyframes ticker-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        @media (max-width: 480px) {
            .fixture-ticker {
                padding: 6px 0;
                margin-bottom: 10px;
            }
            .fixture-item {
                font-size: 10px;
                padding: 0 12px;
            }
            .team-abbr {
                font-size: 10px;
            }
            .fixture-score {
                font-size: 10px;
            }
            .fixture-status {
                font-size: 9px;
            }
            .goal-scorers {
                font-size: 9px;
            }
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: nowrap;
            justify-content: center;
            align-items: center;
        }
        @media (max-width: 1100px) {
            .controls {
                flex-wrap: wrap;
            }
        }

        .control-group {
            background: rgba(255,255,255,0.08);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-wrap: nowrap;
            gap: 6px;
            align-items: center;
        }
        .control-group label {
            margin-right: 10px;
            color: #e8e8e8;
            font-weight: 500;
        }
        select {
            padding: 8px 15px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(55, 0, 60, 0.8);
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }
        select:hover {
            border-color: #00ff85;
        }
        /* Elite option styling */
        select option[value="elite"] {
            background: linear-gradient(90deg, #37003c, #1a001d);
            color: #ffd700;
            font-weight: 600;
        }
        /* Elite player toggle styling */
        .player-toggle.elite-player {
            border-left: 4px solid #ffd700 !important;
            background: rgba(255, 215, 0, 0.08);
        }
        .player-toggle.elite-player .player-name {
            color: #ffd700;
        }
        .player-toggle.user-player {
            border-left: 4px solid #00ff85 !important;
            background: rgba(0, 255, 133, 0.15);
        }
        .player-toggle.user-player .player-name {
            color: #00ff85;
            font-weight: bold;
        }
        .elite-badge {
            font-size: 8px;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 5px;
            font-weight: 600;
        }
        .elite-badge.legend {
            background: #ffd700;
            color: #37003c;
        }
        .elite-badge.creator {
            background: #04f5ff;
            color: #37003c;
        }
        .elite-badge.celebrity {
            background: #ff6b6b;
            color: #fff;
        }
        .elite-badge.you {
            background: #00ff85;
            color: #37003c;
        }
        /* Info tooltip for elite */
        .elite-info {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            border-radius: 50%;
            color: #ffd700;
            font-size: 11px;
            font-weight: bold;
            cursor: help;
            margin-left: 8px;
            position: relative;
        }
        .elite-info:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: normal;
            white-space: nowrap;
            z-index: 1000;
            border: 1px solid #ffd700;
        }
        .elite-info:hover::before {
            content: '';
            position: absolute;
            bottom: 115%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #ffd700;
            z-index: 1000;
        }
        .separator {
            color: #666;
            margin: 0 5px;
        }
        .league-id-input {
            width: 80px;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(55,0,60,0.8);
            color: #fff;
            font-size: 13px;
        }
        .week-select {
            width: 70px;
        }
        .view-btns {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        .control-group-league {
            flex: 1 1 auto;
            flex-wrap: nowrap;
        }
        @media (max-width: 900px) {
            .control-group-league {
                flex-wrap: wrap;
            }
        }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
        }
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .sidebar {
                max-height: 450px;
            }
        }

        /* Table View styles */
        .table-view {
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            max-width: 100%;
        }
        .league-table {
            width: 100%;
            min-width: 800px;
            border-collapse: collapse;
            font-size: 13px;
        }
        .league-table th {
            text-align: left;
            padding: 12px 10px;
            border-bottom: 2px solid rgba(0,255,133,0.3);
            color: #00ff85;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 0.5px;
        }
        .league-table td {
            padding: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            vertical-align: middle;
        }
        .league-table tbody tr:hover {
            background: rgba(255,255,255,0.05);
        }
        .league-table tbody tr.my-team {
            background: rgba(0,255,133,0.1);
        }
        .league-table .col-rank {
            width: 40px;
            text-align: center;
            font-weight: 600;
            color: #04f5ff;
        }
        .league-table .col-move {
            width: 30px;
            text-align: center;
            font-size: 11px;
        }
        .league-table .col-name {
            min-width: 150px;
        }
        .league-table .col-gw {
            width: 80px;
            text-align: right;
            font-weight: 600;
        }
        .league-table th.sortable {
            cursor: pointer;
            user-select: none;
        }
        .league-table th.sortable:hover {
            background: rgba(255,255,255,0.15);
        }
        .league-table .col-total {
            width: 70px;
            text-align: right;
            font-weight: 700;
            color: #fff;
        }
        .league-table .col-gap {
            width: 45px;
            text-align: right;
            font-size: 10px;
            color: #ff6b6b;
        }
        .league-table .col-captain {
            min-width: 70px;
            max-width: 85px;
            font-size: 11px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .league-table .col-status {
            width: 90px;
            font-size: 11px;
        }
        .league-table .col-chip {
            width: 60px;
            text-align: center;
            font-size: 11px;
        }
        .league-table .col-autosub {
            min-width: 80px;
            max-width: 100px;
            font-size: 10px;
        }
        .league-table .col-bps {
            min-width: 120px;
            max-width: 150px;
            font-size: 10px;
        }
        .league-table .col-or {
            width: 80px;
            text-align: right;
            font-size: 11px;
            color: #888;
        }
        .league-table .chip-badge {
            background: rgba(0,255,133,0.2);
            color: #00ff85;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
        }
        .league-table .autosub-info {
            color: #04f5ff;
        }
        .league-table .bonus-live {
            color: #ffaa00;
        }
        .league-table .col-defcon {
            min-width: 80px;
            max-width: 100px;
            font-size: 10px;
        }
        .league-table .defcon-pts {
            color: #e056fd;
            font-weight: 500;
        }
        .league-table .bps-pts {
            color: #ffaa00;
            font-weight: 500;
        }
        .league-table .team-name {
            font-weight: 500;
            color: #fff;
        }
        .league-table .manager-name {
            font-size: 11px;
            color: #888;
        }
        .league-table .hit {
            color: #ffaa00;
            font-size: 11px;
        }
        .league-table .captain-pts {
            color: #00ff85;
            font-size: 11px;
        }
        .league-table .vc-active {
            color: #04f5ff;
            font-size: 10px;
        }
        .league-table .status-playing {
            color: #ff4757;
        }
        .league-table .status-toplay {
            color: #888;
        }
        .league-table .status-done {
            color: #00ff85;
        }
        .league-table .move-up {
            color: #00ff85;
        }
        .league-table .move-down {
            color: #ff4757;
        }
        /* Mobile: All columns visible, table scrolls horizontally */
        @media (max-width: 768px) {
            .league-table {
                font-size: 11px;
            }
            .league-table th, .league-table td {
                padding: 6px 5px;
                white-space: nowrap;
            }
            .table-view {
                padding: 8px;
                margin: 0 -10px;
            }
        }
        @media (max-width: 600px) {
            .league-table {
                font-size: 10px;
            }
            .league-table th, .league-table td {
                padding: 5px 4px;
            }
            .league-table .col-name {
                min-width: 70px;
                max-width: 105px;
            }
            .league-table .team-name {
                max-width: 100px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                font-size: 10px;
            }
            .league-table .manager-name {
                display: block;
                font-size: 8px;
                color: #666;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
        }

        /* Expandable row details for mobile */
        .row-details {
            background: rgba(0,0,0,0.3);
        }
        .row-details td {
            padding: 0 !important;
        }
        .row-details-content {
            padding: 10px 15px;
            font-size: 12px;
        }
        .detail-item {
            display: grid;
            grid-template-columns: 10ch 1fr;
            gap: 0.6em;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .detail-item:last-child {
            border-bottom: none;
        }
        .detail-item.has-sub-items {
            border-bottom: none;
            padding-bottom: 2px;
        }
        .detail-label {
            color: #888;
        }
        .detail-sub-item {
            display: grid;
            grid-template-columns: 10ch 1fr;
            gap: 0.6em;
            padding: 2px 0;
        }
        .detail-sub-item.last-sub-item {
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 4px;
        }
        .chip-active {
            color: #04f5ff;
        }
        .autosub-in {
            color: #04f5ff;
        }
        .points-gained {
            color: #ffaa00;
        }
        .defcon-player {
            color: #e056fd;
        }
        .defcon-points {
            color: #e056fd;
        }
        .bps-player {
            color: #ffaa00;
        }
        .bps-bonus {
            color: #ffaa00;
        }
        .rank-value {
            color: #888;
        }

        /* Mobile narrow screens - show key columns only, tap for details */
        @media (max-width: 480px) {
            .league-table {
                min-width: unset !important;
                width: 100% !important;
            }
            .league-table th, .league-table td {
                padding: 6px 4px !important;
                font-size: 11px;
            }
            .league-table .col-chip,
            .league-table .col-autosub,
            .league-table .col-bps,
            .league-table .col-defcon,
            .league-table .col-status,
            .league-table .col-or {
                display: none !important;
            }
            .league-table .col-rank { width: 5% !important; }
            .league-table .col-move { width: 7% !important; }
            .league-table .col-name { width: 26% !important; }
            .league-table .col-gw { width: 11% !important; }
            .league-table .col-total { width: 13% !important; }
            .league-table .col-gap { width: 10% !important; }
            .league-table .col-captain { width: 28% !important; }
            .league-table tr {
                cursor: pointer;
            }
            .league-table tbody tr:active {
                background: rgba(0,255,133,0.1);
            }
        }

        /* Landscape mobile - fit all columns without scroll */
        @media (max-height: 500px) and (orientation: landscape) {
            .league-table {
                font-size: 10px;
                min-width: unset;
                width: 100%;
            }
            .league-table th, .league-table td {
                padding: 4px 3px;
                white-space: nowrap;
            }
            .league-table .col-rank { width: 20px; }
            .league-table .col-move { width: 22px; }
            .league-table .col-name { min-width: 60px; max-width: 80px; overflow: hidden; text-overflow: ellipsis; }
            .league-table .col-gw { width: 35px; }
            .league-table .col-total { width: 42px; }
            .league-table .col-gap { width: 30px; }
            .league-table .col-captain { max-width: 60px; overflow: hidden; text-overflow: ellipsis; }
            .league-table .col-chip { width: 22px; }
            .league-table .col-autosub { max-width: 55px; overflow: hidden; text-overflow: ellipsis; }
            .league-table .col-bps { width: 28px; }
            .league-table .col-defcon { max-width: 60px; overflow: hidden; text-overflow: ellipsis; }
            .league-table .col-status { width: 45px; }
            .league-table .col-or { width: 50px; }
            .league-table .manager-name { display: block; font-size: 8px; color: #888; }
            .league-table .team-name { font-size: 9px; }
            .table-view { padding: 5px; margin: 0; }
            .controls { padding: 5px; gap: 5px; }
            .control-group { padding: 5px 8px; }
            h1 { font-size: 1.2rem; margin-bottom: 5px; }
        }

        /* Landscape mode on mobile - fill the screen */
        @media (max-width: 900px) and (orientation: landscape) {
            body {
                padding: 5px;
            }
            .table-view {
                width: 100vw;
                margin-left: -5px;
                margin-right: -5px;
                padding: 5px;
                border-radius: 0;
                max-height: calc(100vh - 60px);
                overflow-y: auto;
            }
            .league-table {
                width: 100%;
                min-width: unset;
            }
            .controls {
                padding: 3px 5px;
                gap: 5px;
            }
            .control-group {
                padding: 5px 8px;
            }
            h1 {
                font-size: 1rem;
                margin-bottom: 3px;
            }
            .control-group label {
                display: none;
            }
        }

        /* Back to top button - always visible on desktop, scroll-triggered on mobile */
        #backToTop {
            display: flex;
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff85, #04f5ff);
            color: #37003c;
            border: none;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 255, 133, 0.3);
            transition: transform 0.2s, box-shadow 0.2s, opacity 0.2s;
        }
        #backToTop:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 255, 133, 0.5);
        }
        @media (max-width: 768px) {
            #backToTop {
                width: 40px;
                height: 40px;
                font-size: 20px;
                bottom: 20px;
                right: 20px;
                display: none; /* Hidden by default on mobile */
            }
            #backToTop.visible {
                display: flex;
            }
        }

        /* Footer styles */
        .site-footer {
            margin-top: 40px;
            padding: 30px 20px 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            background: rgba(55, 0, 60, 0.3);
        }
        .footer-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 30px;
            margin-bottom: 25px;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
        }
        .footer-section h4 {
            color: #00ff85;
            margin-bottom: 10px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .footer-section p {
            color: #888;
            font-size: 12px;
            line-height: 1.5;
        }
        .footer-section ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .footer-section ul li {
            color: #888;
            font-size: 12px;
            padding: 3px 0;
        }
        .footer-section ul li::before {
            content: "✓ ";
            color: #00ff85;
        }
        .coffee-btn {
            display: inline-block;
            margin-top: 10px;
            padding: 8px 16px;
            background: linear-gradient(135deg, #ffdd00, #ffaa00);
            color: #1a1a2e;
            text-decoration: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 12px;
            transition: all 0.2s;
        }
        .coffee-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 221, 0, 0.3);
        }
        .footer-bottom {
            text-align: center;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.05);
        }
        .footer-bottom p {
            color: #666;
            font-size: 12px;
            margin: 0;
        }

        /* Tablet optimizations */
        @media (max-width: 768px) {
            .controls {
                gap: 10px;
            }
            .control-group {
                padding: 12px 15px;
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                align-items: center;
            }
            .control-group:first-child {
                width: 100%;
            }
            .control-group:first-child > * {
                flex-shrink: 0;
            }
            .control-group:first-child .btn {
                padding: 8px 12px;
                font-size: 11px;
            }
            #leagueSelect {
                max-width: 150px;
            }
            .view-btn {
                padding: 8px 12px;
                font-size: 11px;
            }
            h1 {
                font-size: 1.6rem;
            }
        }

        /* Mobile optimizations */
        @media (max-width: 600px) {
            body {
                padding: 5px;
            }
            .table-view {
                padding: 3px;
                margin: 0;
                border-radius: 8px;
            }
            h1 {
                font-size: 1.4rem;
                margin-bottom: 5px;
            }
            .controls {
                flex-direction: column;
                gap: 10px;
            }
            .control-group {
                width: 100%;
                padding: 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                align-items: center;
            }
            .control-group label {
                width: 100%;
                margin-bottom: 5px;
                font-size: 12px;
            }
            .view-btn {
                padding: 12px 14px;
                font-size: 11px;
                flex: 1;
                min-width: 80px;
                text-align: center;
            }
            select {
                padding: 12px 10px;
                font-size: 14px;
                flex: 1;
                min-width: 70px;
            }
            .btn {
                padding: 12px 16px;
                font-size: 11px;
                flex: 1;
                min-width: 60px;
            }
            .chart-container {
                padding: 10px;
                min-height: 350px;
            }
            .sidebar {
                max-height: 400px;
                padding: 10px;
            }
            .sidebar h3 {
                font-size: 12px;
            }
            .player-toggle {
                padding: 12px 10px;
                gap: 6px;
            }
            .player-toggle input {
                width: 20px;
                height: 20px;
            }
            .player-toggle .rank {
                font-size: 12px;
                min-width: 50px;
            }
            .player-toggle .player-name {
                min-width: 70px;
                flex: 1 1 70px;
            }
            .player-toggle .toggle-team-name {
                font-size: 12px;
            }
            .player-toggle .toggle-manager-name {
                font-size: 9px;
            }
            .player-toggle .points {
                font-size: 11px;
                flex: 0 0 auto;
            }
            .player-toggle .color-dot {
                width: 10px;
                height: 10px;
            }
            #playerSearch {
                padding: 12px;
                font-size: 14px;
            }
            .btn-group {
                gap: 8px;
            }
            .btn-group .btn {
                flex: 1;
                min-width: 70px;
            }
            #statusBar {
                padding: 12px;
                font-size: 14px;
            }
            .setup-box {
                padding: 20px;
                margin: 20px auto;
            }
            .setup-box h2 {
                font-size: 1rem;
            }
            #teamIdInput {
                width: 120px;
                padding: 14px 12px;
            }
            .player-toggle .expand-icon {
                font-size: 14px;
                opacity: 1;
            }
            .player-details {
                padding: 10px 12px;
                font-size: 12px;
            }
            .detail-row {
                padding: 4px 0;
            }
            .detail-row.sub-row {
                font-size: 11px;
            }
            .footer-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            .footer-section {
                text-align: center;
            }
            .coffee-btn {
                width: 100%;
                text-align: center;
            }
        }
        .chart-container {
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            padding: 20px;
            min-height: 500px;
            border: 1px solid rgba(255,255,255,0.1);
            overflow: visible;
        }
        .chart-container canvas {
            overflow: visible !important;
        }
        .sidebar {
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            padding: 15px;
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .sidebar h3 {
            margin-bottom: 12px;
            color: #00ff85;
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: sticky;
            top: 0;
            background: linear-gradient(180deg, rgba(55,0,60,1) 0%, rgba(55,0,60,0.95) 100%);
            padding: 8px 0;
        }
        .btn-group {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .btn {
            padding: 8px 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .btn-select-all {
            background: linear-gradient(135deg, #00ff85, #00d970);
            color: #37003c;
        }
        .btn-clear-all {
            background: linear-gradient(135deg, #e90052, #c70045);
            color: #fff;
        }
        .btn-top-10 {
            background: linear-gradient(135deg, #04f5ff, #00d4e6);
            color: #37003c;
        }
        .btn-star {
            background: transparent;
            border: none;
            font-size: 20px;
            cursor: pointer;
            padding: 0 5px;
            color: #888;
            transition: all 0.2s;
        }
        .btn-star:hover {
            color: #ffcc00;
            transform: scale(1.2);
        }
        .btn-star.active {
            color: #ffcc00;
        }
        .view-btn {
            padding: 10px 18px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            background: rgba(55, 0, 60, 0.6);
            color: #b8b8b8;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        .view-btn:hover {
            background: rgba(55, 0, 60, 0.9);
            color: #fff;
            border-color: #00ff85;
        }
        .view-btn .btn-icon {
            font-size: 14px;
            line-height: 1;
        }
        .view-btn.active {
            background: linear-gradient(135deg, #00ff85, #00d970);
            color: #37003c;
            border-color: #00ff85;
            font-weight: 700;
        }
        .auto-sub-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: rgba(55, 0, 60, 0.6);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            font-size: 11px;
            color: #b8b8b8;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .auto-sub-toggle:hover {
            border-color: #00ff85;
        }
        .auto-sub-toggle.active {
            background: rgba(0, 255, 133, 0.15);
            border-color: #00ff85;
            color: #00ff85;
        }
        .toggle-switch {
            width: 32px;
            height: 18px;
            background: rgba(255,255,255,0.2);
            border-radius: 9px;
            position: relative;
            transition: all 0.2s;
        }
        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            background: #888;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.2s;
        }
        .auto-sub-toggle.active .toggle-switch {
            background: #00ff85;
        }
        .auto-sub-toggle.active .toggle-switch::after {
            left: 16px;
            background: #37003c;
        }
        .player-list {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        .player-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 10px;
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
            border-left: 4px solid transparent;
            flex-wrap: wrap;
        }
        .player-toggle:hover {
            background: rgba(0,255,133,0.1);
            transform: translateX(3px);
        }
        .player-toggle.selected {
            background: rgba(0,255,133,0.08);
        }
        .player-toggle input {
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: #00ff85;
            flex-shrink: 0;
        }
        .player-toggle .color-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
            border: 2px solid rgba(255,255,255,0.3);
        }
        .player-toggle .rank {
            font-size: 10px;
            color: #888;
            min-width: 35px;
            max-width: 50px;
            white-space: nowrap;
            font-weight: 600;
        }
        .player-toggle .player-name {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 80px;
            overflow: hidden;
        }
        .player-toggle .toggle-team-name {
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .player-toggle .toggle-manager-name {
            font-size: 10px;
            color: #888;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .player-toggle .points {
            font-weight: 700;
            color: #00ff85;
            font-size: 11px;
            white-space: nowrap;
        }
        .player-toggle .expand-icon {
            font-size: 12px;
            opacity: 0.6;
            margin-left: 5px;
        }
        .player-wrapper {
            margin-bottom: 3px;
        }
        .player-details {
            background: rgba(0,0,0,0.3);
            padding: 8px 10px;
            margin: 0 0 5px 0;
            border-radius: 0 0 6px 6px;
            border-left: 4px solid #04f5ff;
            font-size: 11px;
        }
        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .detail-row:last-child {
            border-bottom: none;
        }
        .detail-row.sub-row {
            font-size: 10px;
            padding: 2px 0;
        }
        .loading {
            text-align: center;
            padding: 50px;
            font-size: 16px;
            color: #b8b8b8;
        }
        /* Setup screen */
        .setup-box {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 40px;
            max-width: 500px;
            margin: 50px auto;
            border: 1px solid rgba(255,255,255,0.1);
            text-align: center;
        }
        .league-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        .league-option:hover {
            background: rgba(0,255,133,0.1);
            border-color: rgba(0,255,133,0.3);
        }
        .league-option .league-name {
            font-weight: 600;
            color: #fff;
        }
        .league-option .league-info {
            font-size: 12px;
            color: #888;
        }
        /* Scrollbar styling */
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }
        .sidebar::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2);
            border-radius: 3px;
        }
        .sidebar::-webkit-scrollbar-thumb {
            background: #00ff85;
            border-radius: 3px;
        }
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #00d970;
        }
        /* Pulse animation for live badge */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Mobile detail modal */
        .mobile-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .mobile-modal.active {
            display: flex;
        }
        .modal-content {
            background: linear-gradient(135deg, #37003c 0%, #2d0036 100%);
            border-radius: 12px;
            padding: 20px;
            width: 90%;
            max-width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(0,255,133,0.3);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }
        .modal-header h3 {
            margin: 0;
            color: #00ff85;
            font-size: 16px;
        }
        .modal-header .team-name {
            font-size: 12px;
            color: #888;
        }
        .modal-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            padding: 0 5px;
        }
        .modal-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 14px;
        }
        .modal-row:last-child {
            border-bottom: none;
        }
        .modal-label {
            color: #888;
        }
        .modal-value {
            color: #fff;
            font-weight: 500;
        }
        .modal-value.highlight {
            color: #00ff85;
        }
        .modal-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }
        .modal-section-title {
            color: #04f5ff;
            font-size: 12px;
            margin-bottom: 8px;
        }

        /* Squad breakdown modal */
        .squad-player {
            display: flex;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.07);
            gap: 8px;
        }
        .squad-player:last-child { border-bottom: none; }
        .squad-player.bench-player { opacity: 0.5; }
        .squad-player.auto-sub-in { opacity: 1; border-left: 2px solid #00ff85; padding-left: 6px; }
        .squad-player.auto-sub-out { opacity: 0.35; text-decoration: line-through; }
        .pos-badge {
            font-size: 9px;
            font-weight: 700;
            padding: 2px 4px;
            border-radius: 3px;
            min-width: 28px;
            text-align: center;
            color: #fff;
        }
        .pos-gk { background: #e8a900; }
        .pos-def { background: #00c46a; }
        .pos-mid { background: #04b5f5; }
        .pos-fwd { background: #e74c3c; }
        .squad-player-name {
            flex: 1;
            font-size: 13px;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .squad-player-name .captain-badge {
            font-size: 9px;
            font-weight: 700;
            background: #00ff85;
            color: #37003c;
            padding: 1px 4px;
            border-radius: 3px;
            margin-left: 4px;
        }
        .squad-player-name .vc-badge {
            font-size: 9px;
            font-weight: 700;
            background: #04f5ff;
            color: #37003c;
            padding: 1px 4px;
            border-radius: 3px;
            margin-left: 4px;
        }
        .squad-player-name .tc-badge {
            font-size: 9px;
            font-weight: 700;
            background: #e8a900;
            color: #37003c;
            padding: 1px 4px;
            border-radius: 3px;
            margin-left: 4px;
        }
        .squad-player-stats {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            flex-shrink: 0;
        }
        .stat-icon {
            display: inline-flex;
            align-items: center;
            gap: 1px;
            padding: 1px 3px;
            border-radius: 3px;
            font-size: 10px;
        }
        .stat-goal { background: rgba(0,255,133,0.2); color: #00ff85; }
        .stat-assist { background: rgba(4,245,255,0.2); color: #04f5ff; }
        .stat-cs { background: rgba(0,196,106,0.15); color: #00c46a; }
        .stat-yc { background: none; padding: 0; }
        .stat-rc { background: none; padding: 0; }
        .card-icon { display: inline-block; width: 10px; height: 14px; border-radius: 2px; vertical-align: middle; }
        .card-yellow { background: #fc0; }
        .card-red { background: #e74c3c; }
        .stat-save { background: rgba(4,181,245,0.15); color: #04b5f5; }
        .stat-og { background: rgba(231,76,60,0.2); color: #e74c3c; }
        .stat-pen-miss { background: rgba(231,76,60,0.2); color: #e74c3c; }
        .stat-pen-save { background: rgba(0,255,133,0.2); color: #00ff85; }
        .stat-bonus { background: rgba(255,170,0,0.2); color: #ffaa00; }
        .stat-defcon { background: rgba(224,86,253,0.2); color: #e056fd; }
        .squad-player-pts {
            font-size: 14px;
            font-weight: 700;
            color: #00ff85;
            min-width: 28px;
            text-align: right;
        }
        .squad-player-pts.zero-pts { color: #666; }
        .squad-player-mins {
            font-size: 10px;
            color: #666;
            min-width: 28px;
            text-align: right;
        }
        .bench-divider {
            text-align: center;
            color: #888;
            font-size: 11px;
            padding: 8px 0 4px;
            border-top: 1px solid rgba(255,255,255,0.15);
            margin-top: 4px;
        }
        .squad-total-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0 0;
            margin-top: 6px;
            border-top: 1px solid rgba(0,255,133,0.3);
            font-weight: 700;
        }
        .squad-total-label { color: #888; font-size: 13px; }
        .squad-total-pts { color: #00ff85; font-size: 16px; }
        .modal-content.squad-modal { max-width: 420px; }
    </style>
</head>
<body>
    <!-- Mobile Detail Modal -->
    <div id="mobileModal" class="mobile-modal" onclick="closeMobileModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div>
                    <h3 id="modalName"></h3>
                    <div class="team-name" id="modalTeam"></div>
                </div>
                <span id="modalHeaderPts" style="font-size:22px;font-weight:700;color:#00ff85;margin-left:auto;margin-right:12px;"></span>
                <button class="modal-close" onclick="closeMobileModal()">&times;</button>
            </div>
            <div id="modalBody"></div>
        </div>
    </div>

    <!-- Setup Screen -->
    <div id="setupScreen" class="container" style="display: none;">
        <h1>FPL League Tracker</h1>
        <p class="subtitle">Track your Fantasy Premier League mini-leagues</p>

        <div class="setup-box">
            <h2 style="color: #00ff85; margin-bottom: 15px; font-size: 1.2rem;">Enter Your FPL Team ID</h2>
            <p style="color: #b8b8b8; margin-bottom: 20px; font-size: 13px;">
                On FPL, click <strong style="color: #fff;">Points</strong> in the menu. Your ID is the number in the URL:<br>
                <code style="background: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 4px; display: inline-block; margin-top: 8px;">
                    fantasy.premierleague.com/entry/<span style="color: #00ff85;">XXXXXX</span>/event/...
                </code>
            </p>
            <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <input type="text" id="teamIdInput" placeholder="Your Team ID"
                       style="width: 150px; padding: 12px 15px; border-radius: 6px; border: 2px solid rgba(0,255,133,0.3); background: rgba(55,0,60,0.8); color: #fff; font-size: 16px; text-align: center;">
                <button class="btn btn-select-all" onclick="lookupTeamLeagues()" style="padding: 12px 25px; font-size: 14px;">
                    Find My Leagues
                </button>
            </div>
            <div id="setupError" style="color: #ff4757; margin-top: 15px; display: none;"></div>
            <div id="setupLoading" style="color: #04f5ff; margin-top: 15px; display: none;">Loading your leagues...</div>

            <div id="leaguesList" style="margin-top: 25px; display: none;">
                <h3 style="color: #00ff85; margin-bottom: 15px; font-size: 1rem;">Your Leagues</h3>
                <div id="leaguesContainer" style="max-height: 300px; overflow-y: auto;"></div>
            </div>
        </div>

        <p style="text-align: center; margin-top: 30px; color: #666; font-size: 12px;">
            <a href="#" onclick="skipSetup()" style="color: #04f5ff;">Skip setup and enter League ID manually</a>
        </p>
    </div>

    <!-- Main App -->
    <div id="mainApp" class="container" style="display: none;">
        <h1>FPL League Tracker</h1>

        <div class="fixture-ticker" id="fixtureTicker" style="display: none;">
            <div class="ticker-wrapper" id="tickerContent">
                <!-- Fixtures loaded dynamically -->
            </div>
        </div>

        <div class="controls">
            <div class="control-group control-group-league">
                <label>League:</label>
                <select id="leagueSelect" onchange="selectLeague()">
                </select>
                <button class="btn-star" id="defaultLeagueBtn" onclick="toggleDefaultLeague()" title="Set as default league">☆</button>
                <!-- <span class="elite-info" data-tooltip="Select '⭐ vs The Best' to compare against elite FPL managers & creators!">?</span> -->
                <span class="separator">or</span>
                <input type="text" id="leagueId" placeholder="League ID" class="league-id-input">
                <button class="btn btn-top-10" onclick="loadNewLeague()">Load</button>
                <button class="btn btn-clear-all" onclick="clearAllCaches()" title="Clear all cached data">Reset</button>
                <button class="btn btn-select-all" id="refreshLiveBtn" onclick="refreshLiveData()" title="Refresh live gameweek data">Refresh</button>
                <button class="btn btn-select-all" id="findMeBtn" onclick="findMyTeam()" title="Jump to your team in the table" style="background: linear-gradient(135deg, #00ff85, #04f5ff);" disabled>⭐ Find Me</button>
                <button class="btn btn-clear-all" onclick="changeTeam()" title="Go back and enter a different Team ID">Change</button>
            </div>
            <div class="control-group">
                <label>Mode:</label>
                <div class="view-btns">
                    <button class="view-btn active" id="btn-table-view" onclick="setDisplayMode('table')"><span class="btn-icon">📊</span><span>Live</span></button>
                    <button class="view-btn" id="btn-chart-view" onclick="setDisplayMode('chart')"><span class="btn-icon">📈</span><span>Charts</span></button>
                    <button class="auto-sub-toggle active" id="autoSubToggle" onclick="toggleAutoSubs()" title="Include predicted auto-subs in points">
                        <span class="toggle-switch"></span>
                        <span>Auto-Subs</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Chart controls on separate row -->
        <div class="controls chart-controls-row" id="chartControlsRow" style="display: none;">
            <div class="control-group" id="chartTypeControls">
                <label>Chart:</label>
                <div class="view-btns">
                    <button class="view-btn active" id="btn-total" onclick="setChartType('total')">Total</button>
                    <button class="view-btn" id="btn-weekly" onclick="setChartType('weekly')">Weekly</button>
                    <button class="view-btn" id="btn-rank" onclick="setChartType('rank')">Position</button>
                </div>
            </div>
            <div class="control-group" id="weekControls">
                <label>GW:</label>
                <select id="weekStart" onchange="updateWeekRange()" class="week-select">
                </select>
                <span class="separator">to</span>
                <select id="weekEnd" onchange="updateWeekRange()" class="week-select">
                </select>
                <button class="btn btn-top-10" onclick="resetWeekRange()">All</button>
            </div>
        </div>

        <div id="statusBar" style="display: none; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px; text-align: center;">
            <span id="statusText" style="color: #04f5ff;">Loading...</span>
        </div>

        <div class="main-content" style="display: none;">
            <div class="chart-container">
                <canvas id="mainChart"></canvas>
            </div>

            <div class="sidebar">
                <h3>Toggle Players</h3>
                <input type="text" id="playerSearch" placeholder="Search players..."
                       oninput="filterPlayers(this.value)"
                       style="width: 100%; padding: 8px 12px; margin-bottom: 10px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2); background: rgba(55,0,60,0.8); color: #fff; font-size: 13px;">
                <button class="btn btn-top-10" id="selectFilteredBtn" onclick="selectFiltered()" style="display: none;">Select Filtered</button>
                <div style="display: flex; align-items: center; gap: 8px; margin: 8px 0;">
                    <span style="font-size: 11px; color: #888;">1</span>
                    <input type="range" id="topNSlider" min="1" max="500" step="1" value="10"
                           oninput="updateSliderLabel(this.value); this.style.accentColor='#00ff85';"
                           onchange="selectTopN(this.value); this.style.accentColor='#04f5ff';"
                           style="flex: 1; accent-color: #04f5ff; cursor: pointer; height: 24px;">
                    <span id="sliderMaxLabel" style="font-size: 11px; color: #888;">All</span>
                    <span id="sliderValue" style="font-size: 12px; color: #04f5ff; font-weight: 600; min-width: 55px; background: rgba(4,245,255,0.1); padding: 2px 6px; border-radius: 4px;">Top 10</span>
                    <button class="btn btn-clear-all" onclick="clearAll()" style="padding: 4px 10px; font-size: 11px;">Clear</button>
                </div>
                <div class="player-list" id="playerToggles">
                    <div class="loading">
                        <div id="loadingText">Loading...</div>
                        <div style="margin-top: 10px;">
                            <div id="loadingPercent" style="font-size: 20px; color: #00ff88;">0%</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Table View (shown by default - LIVE mode) -->
        <div id="tableView" class="table-view">
            <div id="leagueNotice" style="display: none; text-align: center; padding: 8px; background: rgba(4,245,255,0.1); border-radius: 6px; margin-bottom: 10px; font-size: 11px; color: #04f5ff;">
                Showing <span id="loadedCount">0</span> of <span id="totalCount">0</span> managers.
                <button ontouchend="event.preventDefault(); loadMoreManagers('down');" onclick="loadMoreManagers('down')" style="margin-left: 10px; padding: 6px 14px; background: #04f5ff; color: #37003c; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600; touch-action: manipulation;">Load More</button>
                <button id="loadAllBtn" ontouchend="event.preventDefault(); loadAllManagers();" onclick="loadAllManagers()" style="display: none; margin-left: 8px; padding: 6px 14px; background: linear-gradient(135deg, #ff6b35, #f7931e); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600; touch-action: manipulation;">Load All</button>
            </div>
            <div id="loadAllProgress" style="display: none; text-align: center; padding: 10px; background: rgba(255,107,53,0.1); border-radius: 6px; margin-bottom: 10px;">
                <div style="font-size: 12px; color: #ff6b35; margin-bottom: 6px;">Loading all managers... <span id="loadAllProgressText">0%</span></div>
                <div style="background: rgba(255,255,255,0.1); border-radius: 4px; height: 6px; overflow: hidden;">
                    <div id="loadAllProgressBar" style="background: linear-gradient(90deg, #ff6b35, #f7931e); height: 100%; width: 0%; transition: width 0.3s;"></div>
                </div>
                <button onclick="cancelLoadAll()" style="margin-top: 8px; padding: 4px 12px; background: transparent; color: #ff6b35; border: 1px solid #ff6b35; border-radius: 4px; cursor: pointer; font-size: 11px;">Cancel</button>
            </div>
            <table class="league-table">
                <thead>
                    <tr>
                        <th class="col-rank">#</th>
                        <th class="col-move"></th>
                        <th class="col-name">Team</th>
                        <th class="col-gw sortable" id="sortGw">GW</th>
                        <th class="col-total sortable" id="sortTotal">Total</th>
                        <th class="col-gap">Gap</th>
                        <th class="col-captain">Cpt</th>
                        <th class="col-chip">Chip</th>
                        <th class="col-autosub">Auto-Sub</th>
                        <th class="col-bps">BPS</th>
                        <th class="col-defcon">DEFCON</th>
                        <th class="col-status">Status</th>
                        <th class="col-or">OR</th>
                    </tr>
                </thead>
                <tbody id="leagueTableBody">
                </tbody>
            </table>
            <div id="loadMoreSection" style="display: none; text-align: center; padding: 15px;">
                <button ontouchend="event.preventDefault(); loadMoreManagers('down');" onclick="loadMoreManagers('down')" style="padding: 12px 28px; background: linear-gradient(135deg, #04f5ff, #00ff85); color: #37003c; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; touch-action: manipulation; -webkit-tap-highlight-color: transparent;">Load More Managers</button>
                <button id="loadAllBtn2" ontouchend="event.preventDefault(); loadAllManagers();" onclick="loadAllManagers()" style="display: none; margin-left: 10px; padding: 12px 28px; background: linear-gradient(135deg, #ff6b35, #f7931e); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; touch-action: manipulation; -webkit-tap-highlight-color: transparent;">Load All Managers</button>
                <div style="margin-top: 8px; font-size: 11px; color: #888;">Showing <span id="loadedCount2">0</span> of <span id="totalCount2">0</span></div>
            </div>
        </div>

        <!-- Footer -->
        <footer class="site-footer">
            <div class="footer-content">
                <div class="footer-section">
                    <h4>FPL League Tracker</h4>
                    <p>Track your Fantasy Premier League mini-leagues with live scores, interactive charts, and smart predictions.</p>
                </div>
                <div class="footer-section">
                    <h4>Features</h4>
                    <ul>
                        <li>Live points with auto-subs & vice captain</li>
                        <li>Interactive charts (Total / Weekly / Position)</li>
                        <li>Predicted scores & players yet to play</li>
                        <li>Live bonus tracking during matches</li>
                    </ul>
                </div>
                <div class="footer-section">
                    <h4>Support</h4>
                    <p>If you find this useful, consider buying me a coffee!</p>
                    <a href="https://www.buymeacoffee.com/fplleaguetracker" target="_blank" class="coffee-btn">
                        ☕ Buy Me a Coffee
                    </a>
                </div>
                <div class="footer-section">
                    <h4>Help</h4>
                    <p><a href="how-to-use.html" style="color: #04f5ff;">How to Use</a></p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>Made for FPL managers who want more than just a table.</p>
                <p style="font-size: 0.7rem; margin-top: 8px; opacity: 0.5;">Unofficial tool. Not affiliated with the Premier League.</p>
            </div>
        </footer>

        <!-- Back to top button -->
        <button id="backToTop" onclick="scrollToTop()" title="Back to top">↑</button>
    </div>

    <script>
        // Back to top button - visible on desktop, scroll-triggered on mobile
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Add touch support for back-to-top button
        document.addEventListener('DOMContentLoaded', () => {
            const backToTopBtn = document.getElementById('backToTop');
            if (backToTopBtn) {
                backToTopBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    scrollToTop();
                });
            }
        });

        window.addEventListener('scroll', () => {
            const btn = document.getElementById('backToTop');
            if (btn && window.innerWidth <= 768) {
                // On mobile: show/hide based on scroll
                btn.classList.toggle('visible', window.scrollY > 300);
            }
        });
        // Clean UTM params from URL after page loads (keeps analytics, cleans bookmarks)
        if (window.location.search.includes('utm_')) {
            window.history.replaceState({}, '', window.location.pathname);
        }

        let LEAGUE_ID = null;
        let allPlayers = [];
        let playerHistories = {};
        let chart = null;
        let selectedEntries = new Set();
        let leagueName = '';

        // Memory cache for quick league switching (keeps last 3 leagues in memory)
        const leagueMemoryCache = new Map();
        const MAX_MEMORY_CACHE = 3;

        // Throttle utility for scroll handlers
        function throttle(func, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }
        let currentChartType = 'total';
        let currentDisplayMode = 'table'; // Default to LIVE view
        let hoveredEntry = null;
        let highlightedEntry = null; // Persistent highlight for "Find Me"
        let currentGameweek = null;
        let gameweekFinished = true;
        let livePoints = {};
        let livePositions = {};
        let autoSubsEnabled = true; // Toggle for predicted auto-subs
        let currentFilter = '';
        let sortColumn = 'total'; // Current sort column: 'total', 'gw', 'gap'
        let sortDirection = 'desc'; // 'asc' or 'desc'
        let userTeamId = null;
        let userLeagues = [];
        let weekRangeStart = 1;
        let weekRangeEnd = 38;
        let topOverallTotal = null; // #1 overall's total points
        let transfersCache = {}; // Cache transfer data per entryId

        // Pagination state for large leagues
        let leagueTotalPlayers = 0;     // Total managers in league
        let loadedPages = new Set();    // Which pages we've loaded
        let hasMorePages = true;        // Are there more pages to load?
        let isLoadingMore = false;      // Currently loading more?
        let isLoadingAll = false;       // Currently loading all managers?
        let loadAllCancelled = false;   // Was Load All cancelled?
        let userLeagueRank = null;      // User's rank in current league

        // Update Find Me button state based on whether we know user's position
        function updateFindMeButton() {
            const btn = document.getElementById('findMeBtn');
            if (!btn) return;

            const isReady = userLeagueRank !== null && userTeamId !== null;
            const isMember = userLeagueRank !== null; // null means not fetched or not a member

            if (isReady) {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
                btn.title = `Jump to your position (#${userLeagueRank.toLocaleString()})`;
                btn.innerHTML = `⭐ Find Me`;
            } else if (userTeamId && !isMember) {
                // Still loading or not a member
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
                btn.title = 'Loading your position...';
                btn.innerHTML = `⭐ Find Me`;
            } else {
                // No team ID set
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
                btn.title = 'Set your Team ID first';
            }
        }

        // Match status tracking
        let matchesInProgress = false;  // Are any matches currently live?
        let bonusPending = false;       // Are bonus points being calculated?
        let gwDataConfirmed = false;    // Has API fully updated for GW?

        // Default Team ID for development (Dominic Mackie)
        const DEFAULT_TEAM_ID = null; // Set to null for production - users enter their own Team ID

        // Cloudflare Worker for fast API calls (100k requests/day free)
        const useCloudflareWorker = true;
        const CLOUDFLARE_WORKER = 'https://fpl-proxy.dom-mackie.workers.dev/?path=';
        console.log('Using Cloudflare Worker for fast API calls');

        // ESPN API for live goal data - no API key needed, CORS-friendly
        const ESPN_API_BASE = 'https://site.api.espn.com/apis/site/v2/sports/soccer/eng.1';
        let previousScores = {}; // Track scores to detect goals / VAR removals
        let previousFinished = {}; // Track which matches have finished (for end-of-match re-check)

        // Hardcoded goal data per gameweek - sourced from ESPN
        // GW24: Brighton 1-1 Everton, Leeds 0-4 Arsenal, Wolves 0-2 Bournemouth, Chelsea 3-2 West Ham,
        //       Liverpool 4-1 Newcastle, Villa 0-1 Brentford, Man Utd 3-2 Fulham, Forest 1-1 Palace, Spurs 2-2 Man City
        // GW25: Leeds 3-1 Forest (+ remaining games fetched live from ESPN)
        const HARDCODED_GOALS = {
            24: {
                // Brighton 1-1 Everton
                'brighton': [
                    { player: { name: 'Groß' }, time: { elapsed: 73 }, assist: { name: 'Ayari' } }
                ],
                'everton': [
                    { player: { name: 'Beto' }, time: { elapsed: 97 }, assist: null }
                ],
                // Leeds 0-4 Arsenal
                'leeds': [],
                'arsenal': [
                    { player: { name: 'Zubimendi' }, time: { elapsed: 27 }, assist: { name: 'Madueke' } },
                    { player: { name: 'Darlow (OG)' }, time: { elapsed: 38 }, assist: null },
                    { player: { name: 'Gyökeres' }, time: { elapsed: 70 }, assist: { name: 'Martinelli' } },
                    { player: { name: 'G. Jesus' }, time: { elapsed: 85 }, assist: { name: 'Ødegaard' } }
                ],
                // Wolves 0-2 Bournemouth
                'wolves': [],
                'bournemouth': [
                    { player: { name: 'Kroupi Jr' }, time: { elapsed: 33 }, assist: { name: 'Adli' } },
                    { player: { name: 'A. Scott' }, time: { elapsed: 91 }, assist: { name: 'Rayan' } }
                ],
                // Chelsea 3-2 West Ham
                'chelsea': [
                    { player: { name: 'João Pedro' }, time: { elapsed: 57 }, assist: { name: 'Fofana' } },
                    { player: { name: 'Cucurella' }, time: { elapsed: 70 }, assist: { name: 'Delap' } },
                    { player: { name: 'Enzo' }, time: { elapsed: 92 }, assist: { name: 'João Pedro' } }
                ],
                'west ham': [
                    { player: { name: 'Bowen' }, time: { elapsed: 7 }, assist: null },
                    { player: { name: 'Summerville' }, time: { elapsed: 36 }, assist: { name: 'Wan-Bissaka' } }
                ],
                // Liverpool 4-1 Newcastle
                'liverpool': [
                    { player: { name: 'Ekitiké' }, time: { elapsed: 41 }, assist: { name: 'Wirtz' } },
                    { player: { name: 'Ekitiké' }, time: { elapsed: 43 }, assist: { name: 'Kerkez' } },
                    { player: { name: 'Wirtz' }, time: { elapsed: 67 }, assist: { name: 'Salah' } },
                    { player: { name: 'Konaté' }, time: { elapsed: 93 }, assist: null }
                ],
                'newcastle': [
                    { player: { name: 'Gordon' }, time: { elapsed: 36 }, assist: null }
                ],
                // Aston Villa 0-1 Brentford
                'aston villa': [],
                'brentford': [
                    { player: { name: 'Ouattara' }, time: { elapsed: 46 }, assist: { name: 'Ajer' } }
                ],
                // Man Utd 3-2 Fulham
                'manchester united': [
                    { player: { name: 'Casemiro' }, time: { elapsed: 25 }, assist: { name: 'Fernandes' } },
                    { player: { name: 'M. Cunha' }, time: { elapsed: 52 }, assist: { name: 'Casemiro' } },
                    { player: { name: 'Sesko' }, time: { elapsed: 88 }, assist: { name: 'Fernandes' } }
                ],
                'fulham': [
                    { player: { name: 'Jiménez (P)' }, time: { elapsed: 40 }, assist: null },
                    { player: { name: 'Kevin' }, time: { elapsed: 72 }, assist: null }
                ],
                // Forest 1-1 Crystal Palace
                'nottingham forest': [
                    { player: { name: 'Gibbs-White' }, time: { elapsed: 5 }, assist: null }
                ],
                'crystal palace': [
                    { player: { name: 'Sarr (P)' }, time: { elapsed: 47 }, assist: null }
                ],
                // Spurs 2-2 Man City
                'tottenham': [
                    { player: { name: 'Solanke' }, time: { elapsed: 53 }, assist: { name: 'Simons' } },
                    { player: { name: 'Solanke' }, time: { elapsed: 70 }, assist: { name: 'Gallagher' } }
                ],
                'manchester city': [
                    { player: { name: 'Cherki' }, time: { elapsed: 11 }, assist: { name: 'Haaland' } },
                    { player: { name: 'Semenyo' }, time: { elapsed: 44 }, assist: { name: 'B. Silva' } }
                ],
                // Empty for teams not playing
                'leicester': [],
                'ipswich': [],
                'southampton': [],
                // Sunderland 3-0 Burnley (Monday night game)
                'sunderland': [
                    { player: { name: 'Tuanzebe (OG)' }, time: { elapsed: 9 }, assist: { name: 'Brobbey' } },
                    { player: { name: 'Diarra' }, time: { elapsed: 32 }, assist: { name: 'Mukiele' } },
                    { player: { name: 'Talbi' }, time: { elapsed: 72 }, assist: { name: 'Mandava' } }
                ],
                'burnley': []
            },
            25: {
                // Leeds 3-1 Nottingham Forest (Fri 6 Feb)
                'leeds': [
                    { player: { name: 'Bogle' }, time: { elapsed: 26 }, assist: { name: 'Gruev' } },
                    { player: { name: 'Okafor' }, time: { elapsed: 30 }, assist: { name: 'Justin' } },
                    { player: { name: 'Calvert-Lewin' }, time: { elapsed: 49 }, assist: { name: 'Gruev' } }
                ],
                'nottingham forest': [
                    { player: { name: 'Lucca' }, time: { elapsed: 86 }, assist: { name: 'Hutchinson' } }
                ]
            }
        };

        // Goal scorers cache - populated after gameweek is determined
        let cachedGoalScorers = {};

        // Merge hardcoded + localStorage goal data (called after currentGameweek is set)
        function loadGoalScorersForGameweek(gw) {
            try {
                // HARDCODED data has accurate minutes - load it FIRST as primary source
                const hardcodedForGw = HARDCODED_GOALS[gw] || {};
                cachedGoalScorers = {};

                // Load hardcoded data first (has proper minutes and assists)
                let hardcodedCount = 0;
                Object.keys(hardcodedForGw).forEach(team => {
                    if (hardcodedForGw[team] && hardcodedForGw[team].length > 0) {
                        cachedGoalScorers[team] = hardcodedForGw[team];
                        hardcodedCount++;
                    }
                });
                console.log(`Loaded ${hardcodedCount} teams from hardcoded data for GW${gw}`);

                // Then merge localStorage/API data ONLY for teams not in hardcoded
                const stored = localStorage.getItem('fpl_goal_scorers');
                if (stored) {
                    const parsed = JSON.parse(stored);
                    if (parsed.gameweek === gw && parsed.data) {
                        let mergedCount = 0;
                        Object.keys(parsed.data).forEach(team => {
                            // Only use localStorage if no hardcoded data for this team
                            if (!cachedGoalScorers[team] || cachedGoalScorers[team].length === 0) {
                                if (parsed.data[team] && parsed.data[team].length > 0) {
                                    cachedGoalScorers[team] = parsed.data[team];
                                    mergedCount++;
                                }
                            }
                        });
                        console.log(`Merged ${mergedCount} additional teams from localStorage`);
                    }
                }
                console.log('Goal scorers available for:', Object.keys(cachedGoalScorers).filter(k => cachedGoalScorers[k].length > 0));
            } catch (e) {
                console.warn('Could not load goal scorers:', e);
            }
        }

        // Function to save goal scorers to localStorage
        function saveGoalScorersToStorage() {
            try {
                localStorage.setItem('fpl_goal_scorers', JSON.stringify({
                    gameweek: currentGameweek,
                    data: cachedGoalScorers,
                    updated: Date.now()
                }));
            } catch (e) {
                console.warn('Could not save goal scorers:', e);
            }
        }

        // Build goal scorer data from FPL live stats (players with goals/assists)
        function buildGoalDataFromFPL() {
            if (!livePlayerData || !bootstrapPlayers || !bootstrapTeams) return;

            const teamGoals = {}; // team name -> array of goals

            Object.keys(livePlayerData).forEach(playerId => {
                const stats = livePlayerData[playerId];
                const playerInfo = bootstrapPlayers[playerId];
                if (!playerInfo || !stats) return;

                const teamId = playerInfo.team;
                const teamName = bootstrapTeams[teamId];
                if (!teamName) return;

                const teamKey = normalizeTeamName(teamName).toLowerCase();
                if (!teamGoals[teamKey]) teamGoals[teamKey] = [];

                // Add goals
                for (let i = 0; i < (stats.goals || 0); i++) {
                    teamGoals[teamKey].push({
                        player: { name: playerInfo.name },
                        time: { elapsed: '?' }, // FPL doesn't give us times
                        assist: null
                    });
                }
            });

            // Merge into cachedGoalScorers (only if we don't already have data)
            let addedCount = 0;
            Object.keys(teamGoals).forEach(team => {
                if (!cachedGoalScorers[team] || cachedGoalScorers[team].length === 0) {
                    if (teamGoals[team].length > 0) {
                        cachedGoalScorers[team] = teamGoals[team];
                        addedCount++;
                    }
                }
            });

            if (addedCount > 0) {
                console.log(`Built goal data from FPL for ${addedCount} teams`);
                saveGoalScorersToStorage();
            }
        }

        // Fallback CORS Proxies for local development only
        const CORS_PROXIES = [
            'https://api.allorigins.win/raw?url=',
            'https://corsproxy.io/?',
            'https://api.codetabs.com/v1/proxy?quest='
        ];
        let currentProxyIndex = 0;
        let CORS_PROXY = CORS_PROXIES[0];
        let lastSuccessfulProxy = null;

        let fetchRetryCount = 0;
        const MAX_FETCH_RETRIES = 3;

        // Concurrent request limiter - lower on mobile for better reliability
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const MAX_CONCURRENT_REQUESTS = isMobile ? 8 : 20;
        let activeRequests = 0;
        const requestQueue = [];
        console.log('Device:', isMobile ? 'Mobile' : 'Desktop', '| Max concurrent:', MAX_CONCURRENT_REQUESTS);

        async function throttledFetch(url, options = {}) {
            return new Promise((resolve, reject) => {
                const executeRequest = async () => {
                    activeRequests++;
                    try {
                        const controller = new AbortController();
                        // Shorter timeout on mobile for faster failover
                        const timeout = isMobile ? 8000 : (options.timeout || 12000);
                        const timeoutId = setTimeout(() => controller.abort(), timeout);
                        const response = await fetch(url, {
                            ...options,
                            signal: controller.signal,
                            keepalive: true
                        });
                        clearTimeout(timeoutId);
                        resolve(response);
                    } catch (e) {
                        reject(e);
                    } finally {
                        activeRequests--;
                        processQueue();
                    }
                };

                if (activeRequests < MAX_CONCURRENT_REQUESTS) {
                    executeRequest();
                } else {
                    requestQueue.push(executeRequest);
                }
            });
        }

        function processQueue() {
            while (requestQueue.length > 0 && activeRequests < MAX_CONCURRENT_REQUESTS) {
                const nextRequest = requestQueue.shift();
                nextRequest();
            }
        }

        // Simple FPL API fetch - uses Cloudflare Worker or CORS proxy
        let workerFailed = false; // Track if Cloudflare Worker is unavailable
        async function fplApiFetch(apiPath) {
            // Try Cloudflare Worker first (unless it previously failed)
            if (useCloudflareWorker && !workerFailed) {
                try {
                    // Strip /api/ prefix since worker adds it
                    const workerPath = apiPath.replace(/^\/api\//, '');
                    const response = await fetch(CLOUDFLARE_WORKER + encodeURIComponent(workerPath));
                    if (response.ok) return response;
                    if (response.status === 429) {
                        console.warn('Cloudflare limit reached, switching to CORS proxy');
                        workerFailed = true;
                    }
                } catch (e) {
                    console.warn('Cloudflare Worker error, falling back to CORS proxy');
                    workerFailed = true;
                }
            }
            // Fallback to CORS proxy
            const url = 'https://fantasy.premierleague.com' + apiPath;
            return fetch(CORS_PROXY + encodeURIComponent(url));
        }

        async function fetchWithFallback(url, isRetry = false) {
            // Extract API path from full URL
            const apiPath = url.replace('https://fantasy.premierleague.com', '');

            // Use Cloudflare Worker if available (much faster!)
            if (useCloudflareWorker && !workerFailed) {
                try {
                    // Strip /api/ prefix since worker adds it
                    const workerPath = apiPath.replace(/^\/api\//, '');
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000);
                    const response = await fetch(CLOUDFLARE_WORKER + encodeURIComponent(workerPath), {
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    if (response.ok) {
                        return response;
                    }
                    console.warn('Cloudflare Worker returned', response.status);
                } catch (e) {
                    console.warn('Cloudflare Worker failed:', e.message);
                    workerFailed = true;
                }
                // Fall through to CORS proxy if Cloudflare fails
            }

            // Fallback: CORS proxy (for local dev or if Netlify fails)
            const startIndex = lastSuccessfulProxy !== null ?
                CORS_PROXIES.indexOf(lastSuccessfulProxy) : currentProxyIndex;

            for (let i = 0; i < CORS_PROXIES.length; i++) {
                const proxyIndex = (startIndex + i) % CORS_PROXIES.length;
                const proxy = CORS_PROXIES[proxyIndex];
                try {
                    const needsEncoding = proxy.includes('allorigins') || proxy.includes('corsproxy');
                    const fullUrl = proxy + (needsEncoding ? encodeURIComponent(url) : url);
                    console.log(`Trying proxy ${proxyIndex}: ${proxy.split('/')[2]}`);

                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), isMobile ? 10000 : 15000);

                    const response = await fetch(fullUrl, { signal: controller.signal });
                    clearTimeout(timeoutId);

                    if (response.ok) {
                        currentProxyIndex = proxyIndex;
                        CORS_PROXY = proxy;
                        lastSuccessfulProxy = proxy;
                        console.log(`Proxy ${proxyIndex} succeeded`);
                        fetchRetryCount = 0;
                        return response;
                    }
                    console.warn(`Proxy ${proxyIndex} returned ${response.status}`);
                } catch (e) {
                    console.warn(`Proxy ${proxyIndex} failed:`, e.message);
                    if (i < CORS_PROXIES.length - 1) {
                        await new Promise(r => setTimeout(r, 500));
                    }
                }
            }
            throw new Error('All proxies failed - FPL API may be temporarily unavailable');
        }

        // Initialize app
        function initApp() {
            // Check if user has saved Team ID
            const savedTeamId = localStorage.getItem('fpl_team_id');
            const savedLeagues = localStorage.getItem('fpl_user_leagues');

            if (savedTeamId && savedLeagues) {
                userTeamId = parseInt(savedTeamId, 10);
                userLeagues = JSON.parse(savedLeagues);
                showMainApp();
            } else if (DEFAULT_TEAM_ID) {
                // Auto-lookup for development
                document.getElementById('teamIdInput').value = DEFAULT_TEAM_ID;
                lookupTeamLeagues();
            } else {
                showSetupScreen();
            }
        }

        function showSetupScreen() {
            document.getElementById('setupScreen').style.display = 'block';
            document.getElementById('mainApp').style.display = 'none';
        }

        function showMainApp() {
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('mainApp').style.display = 'block';
            populateLeagueDropdown();
            updateFindMeButton(); // Set initial Find Me button state
            if (userLeagues.length > 0 && !LEAGUE_ID) {
                LEAGUE_ID = userLeagues[0].id;
            }
            loadAllData();
        }

        async function lookupTeamLeagues() {
            const teamId = document.getElementById('teamIdInput').value.trim();
            if (!teamId || isNaN(teamId)) {
                showSetupError('Please enter a valid Team ID');
                return;
            }

            document.getElementById('setupError').style.display = 'none';
            document.getElementById('setupLoading').style.display = 'block';
            document.getElementById('leaguesList').style.display = 'none';

            try {
                const url = `https://fantasy.premierleague.com/api/entry/${teamId}/`;
                const response = await fetchWithFallback(url);
                if (!response.ok) {
                    throw new Error('Team not found');
                }
                const data = await response.json();

                // Extract only user-created mini-leagues (not official FPL leagues)
                const classicLeagues = data.leagues?.classic || [];
                userLeagues = classicLeagues
                    .filter(l => l.league_type === 'x') // Only user-created mini-leagues
                    .map(l => ({
                        id: l.id,
                        name: l.name,
                        rank: l.entry_rank,
                        lastRank: l.entry_last_rank
                    }));

                if (userLeagues.length === 0) {
                    showSetupError('No mini-leagues found for this Team ID');
                    document.getElementById('setupLoading').style.display = 'none';
                    return;
                }

                // Save to localStorage
                userTeamId = parseInt(teamId, 10);
                localStorage.setItem('fpl_team_id', teamId);
                localStorage.setItem('fpl_user_leagues', JSON.stringify(userLeagues));

                // Go straight to first league
                document.getElementById('setupLoading').style.display = 'none';
                LEAGUE_ID = userLeagues[0].id;
                showMainApp();

            } catch (e) {
                console.error('Team lookup failed:', e);
                showSetupError('Could not find team. Check your Team ID and try again.');
                document.getElementById('setupLoading').style.display = 'none';
            }
        }

        function showSetupError(message) {
            const errorEl = document.getElementById('setupError');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function displayLeaguesList() {
            const container = document.getElementById('leaguesContainer');
            container.innerHTML = userLeagues.map(league => `
                <div class="league-option" onclick="selectSetupLeague(${league.id}, '${league.name.replace(/'/g, "\\'")}')">
                    <div>
                        <div class="league-name">${league.name}</div>
                        <div class="league-info">Your rank: #${league.rank || '?'}${league.isPublic ? ' (Public)' : ''}</div>
                    </div>
                    <span style="color: #00ff85;">→</span>
                </div>
            `).join('');
            document.getElementById('leaguesList').style.display = 'block';
        }

        function showStatus(message, isError = false) {
            const bar = document.getElementById('statusBar');
            const text = document.getElementById('statusText');
            if (bar && text) {
                text.textContent = message;
                text.style.color = isError ? '#ff4757' : '#04f5ff';
                bar.style.display = 'block';
            }
        }

        function hideStatus() {
            const bar = document.getElementById('statusBar');
            if (bar) bar.style.display = 'none';
        }

        function selectSetupLeague(leagueId, leagueName) {
            LEAGUE_ID = leagueId;
            showMainApp();
        }

        function populateLeagueDropdown() {
            const select = document.getElementById('leagueSelect');

            // Add user leagues
            let options = userLeagues.map(league =>
                `<option value="${league.id}">${league.name}</option>`
            ).join('');

            // Add separator and "vs The Best" option (commented out for now)
            // options += `<option disabled>──────────────</option>`;
            // options += `<option value="elite" title="Compare yourself against elite FPL managers, content creators & legends!">⭐ vs The Best</option>`;

            select.innerHTML = options;

            // Check for default league first, then fall back to LEAGUE_ID
            const defaultLeagueId = getDefaultLeague();
            if (defaultLeagueId && userLeagues.some(l => String(l.id) === String(defaultLeagueId))) {
                select.value = defaultLeagueId;
                LEAGUE_ID = parseInt(defaultLeagueId);
            } else if (LEAGUE_ID) {
                select.value = LEAGUE_ID;
            }
            updateDefaultLeagueButton();
        }

        function getDefaultLeague() {
            return localStorage.getItem('fpl_default_league');
        }

        function setDefaultLeague(leagueId) {
            if (leagueId) {
                localStorage.setItem('fpl_default_league', leagueId);
            } else {
                localStorage.removeItem('fpl_default_league');
            }
            updateDefaultLeagueButton();
        }

        function toggleDefaultLeague() {
            const select = document.getElementById('leagueSelect');
            const currentLeagueId = select.value;
            const defaultLeagueId = getDefaultLeague();

            if (String(defaultLeagueId) === String(currentLeagueId)) {
                // Unset default
                setDefaultLeague(null);
            } else {
                // Set as default
                setDefaultLeague(currentLeagueId);
            }
        }

        function updateDefaultLeagueButton() {
            const btn = document.getElementById('defaultLeagueBtn');
            if (!btn) return;

            const select = document.getElementById('leagueSelect');
            const currentLeagueId = select.value;
            const defaultLeagueId = getDefaultLeague();

            if (currentLeagueId && String(defaultLeagueId) === String(currentLeagueId)) {
                btn.textContent = '★';
                btn.classList.add('active');
                btn.title = 'Remove as default league';
            } else {
                btn.textContent = '☆';
                btn.classList.remove('active');
                btn.title = 'Set as default league';
            }
        }

        function skipSetup() {
            // Show main app with empty dropdown
            userLeagues = [];
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('mainApp').style.display = 'block';
            document.getElementById('leagueSelect').innerHTML = '<option value="">Enter League ID →</option>';
        }

        function changeTeam() {
            localStorage.removeItem('fpl_team_id');
            localStorage.removeItem('fpl_user_leagues');
            userTeamId = null;
            userLeagues = [];
            LEAGUE_ID = null;
            showSetupScreen();
        }

        // Cache functions - Extended TTL with smart GW-based invalidation
        // History data only changes when a new GW completes, so cache aggressively
        const CACHE_TTL_HOURS = 24; // 24 hours base TTL
        const CACHE_TTL_MS = CACHE_TTL_HOURS * 60 * 60 * 1000;

        function getCacheKey(leagueId) {
            return `fpl_cache_${leagueId}`;
        }

        function loadFromCache(leagueId) {
            try {
                const cached = localStorage.getItem(getCacheKey(leagueId));
                if (cached) {
                    const data = JSON.parse(cached);

                    // Validate league ID matches
                    if (data.leagueId && data.leagueId !== leagueId) {
                        console.warn('Cache league ID mismatch, clearing:', data.leagueId, 'vs', leagueId);
                        localStorage.removeItem(getCacheKey(leagueId));
                        return null;
                    }

                    // Smart invalidation: check if GW has changed
                    const cachedGw = data.cachedGameweek || 0;
                    const cacheAge = Date.now() - data.timestamp;

                    // Cache is valid if:
                    // 1. Same gameweek and within 24 hours, OR
                    // 2. Different gameweek but less than 5 minutes old (allow brief overlap during GW transition)
                    const sameGw = cachedGw === currentGameweek || currentGameweek === null;
                    const withinTTL = cacheAge < CACHE_TTL_MS;
                    const recentCache = cacheAge < 300000; // 5 minutes

                    if ((sameGw && withinTTL) || recentCache) {
                        const ageMinutes = Math.round(cacheAge / 60000);
                        console.log(`Using cached data (${ageMinutes}m old, GW${cachedGw}${sameGw ? '' : ' → GW' + currentGameweek})`);
                        return data;
                    } else {
                        console.log(`Cache expired: GW${cachedGw} → GW${currentGameweek}, age: ${Math.round(cacheAge/3600000)}h`);
                    }
                }
            } catch (e) {
                console.warn('Cache read error:', e);
                localStorage.removeItem(getCacheKey(leagueId));
            }
            return null;
        }

        function saveToCache(leagueId, players, histories, leagueNameToSave) {
            try {
                const data = {
                    timestamp: Date.now(),
                    leagueId: leagueId,
                    cachedGameweek: currentGameweek,
                    players: players,
                    histories: histories,
                    leagueName: leagueNameToSave || leagueName
                };
                localStorage.setItem(getCacheKey(leagueId), JSON.stringify(data));
                console.log(`Data cached for league ${leagueId} (GW${currentGameweek}, ${players.length} players)`);
            } catch (e) {
                // localStorage quota exceeded - try to clear old caches
                console.warn('Cache write error, attempting cleanup:', e);
                clearOldCaches(leagueId);
                try {
                    const data = {
                        timestamp: Date.now(),
                        leagueId: leagueId,
                        cachedGameweek: currentGameweek,
                        players: players,
                        histories: histories,
                        leagueName: leagueNameToSave || leagueName
                    };
                    localStorage.setItem(getCacheKey(leagueId), JSON.stringify(data));
                } catch (e2) {
                    console.warn('Cache write failed after cleanup:', e2);
                }
            }
        }

        // Clear old league caches to free up space
        function clearOldCaches(exceptLeagueId) {
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('fpl_cache_') && key !== getCacheKey(exceptLeagueId)) {
                    keysToRemove.push(key);
                }
            }
            keysToRemove.forEach(key => {
                console.log('Clearing old cache:', key);
                localStorage.removeItem(key);
            });
        }

        function setChartType(type) {
            currentChartType = type;
            // Update button states for chart type only
            ['btn-total', 'btn-weekly', 'btn-rank'].forEach(id => {
                document.getElementById(id).classList.remove('active');
            });
            document.getElementById('btn-' + type).classList.add('active');
            updateChart();
        }

        function setDisplayMode(mode) {
            currentDisplayMode = mode;
            // Update button states
            document.getElementById('btn-chart-view').classList.toggle('active', mode === 'chart');
            document.getElementById('btn-table-view').classList.toggle('active', mode === 'table');

            // Toggle visibility of main content areas
            const mainContent = document.querySelector('.main-content');
            const tableView = document.getElementById('tableView');

            // Toggle chart controls row visibility
            const chartControlsRow = document.getElementById('chartControlsRow');
            if (chartControlsRow) {
                chartControlsRow.style.display = mode === 'chart' ? 'flex' : 'none';
            }

            if (mode === 'chart') {
                mainContent.style.display = 'grid';
                tableView.style.display = 'none';
                // Default to Top 10 when switching to chart if nothing selected
                if (selectedEntries.size === 0 && allPlayers.length > 0) {
                    selectTopN(10);
                }
            } else {
                mainContent.style.display = 'none';
                tableView.style.display = 'block';
                updateTableView();
            }
        }

        function toggleSort(column) {
            // If clicking same column, toggle direction; otherwise, set new column with desc
            if (sortColumn === column) {
                sortDirection = sortDirection === 'desc' ? 'asc' : 'desc';
            } else {
                sortColumn = column;
                sortDirection = 'desc';
            }
            console.log('Sort toggled:', column, sortDirection);

            // Re-render table
            updateTableView();
        }

        // Add click/touch listeners for sort headers (works on mobile)
        document.addEventListener('click', function(e) {
            if (e.target.id === 'sortGw' || e.target.closest('#sortGw')) {
                toggleSort('gw');
            } else if (e.target.id === 'sortTotal' || e.target.closest('#sortTotal')) {
                toggleSort('total');
            }
        });

        function toggleAutoSubs() {
            autoSubsEnabled = !autoSubsEnabled;
            const toggle = document.getElementById('autoSubToggle');
            toggle.classList.toggle('active', autoSubsEnabled);

            // Recalculate positions and update views immediately
            if (Object.keys(livePoints).length > 0) {
                recalculateLivePositions();
                updateTableView();
                renderPlayerToggles();
                if (currentDisplayMode === 'chart') {
                    updateChart();
                }
            }
        }

        function recalculateLivePositions() {
            if (!currentGameweek || allPlayers.length === 0) return;

            // Calculate previous GW positions
            const prevGwIndex = currentGameweek - 2;
            const prevGwRankings = allPlayers.map(p => {
                const history = playerHistories[p.entry] || [];
                const prevGwData = prevGwIndex >= 0 && history[prevGwIndex] ? history[prevGwIndex] : null;
                const prevTotal = prevGwData ? prevGwData.total_points : 0;
                return { entry: p.entry, prevTotal };
            }).sort((a, b) => b.prevTotal - a.prevTotal);

            const prevPositions = {};
            prevGwRankings.forEach((item, idx) => {
                prevPositions[item.entry] = idx + 1;
            });

            // Calculate current positions with auto-subs toggle respected
            const currentRankings = allPlayers.map(p => {
                const live = livePoints[p.entry];
                const history = playerHistories[p.entry] || [];
                const prevGwData = prevGwIndex >= 0 && history[prevGwIndex] ? history[prevGwIndex] : null;
                const prevTotal = prevGwData ? prevGwData.total_points : 0;

                let currentTotal, gwPoints;
                if (live) {
                    // Calculate base points by subtracting auto-sub bonus if basePoints not stored
                    const autoSubBonus = live.autoSubs ? live.autoSubs.reduce((sum, s) => sum + (s.pointsGained || 0), 0) : 0;
                    const basePoints = live.basePoints ?? (live.predictedPoints - autoSubBonus);
                    // predictedPoints already includes bonus - don't add again!
                    gwPoints = autoSubsEnabled ? live.predictedPoints : basePoints;
                    currentTotal = prevTotal + gwPoints;
                } else {
                    gwPoints = p.total - prevTotal;
                    currentTotal = prevTotal + gwPoints;
                }

                return {
                    entry: p.entry,
                    total: currentTotal,
                    oldRank: prevPositions[p.entry] || p.rank,
                    gwPoints: gwPoints,
                    apiRank: p.rank // Preserve API rank for tiebreaker
                };
            }).sort((a, b) => {
                // Sort by total; for ties preserve API order (official tiebreaker: fewest transfers)
                if (b.total !== a.total) return b.total - a.total;
                return a.apiRank - b.apiRank;
            });

            // Debug: log ranking order
            console.log('Ranking order (top 30):', currentRankings.slice(0, 30).map((r, i) => `#${i+1}: ${r.total}`).join(', '));

            // Update livePositions
            // For large leagues with partial data, use API ranks to avoid incorrect positioning
            // Use API ranks if: more pages exist, OR we know total and haven't loaded all
            const useApiRanks = hasMorePages || (leagueTotalPlayers > 0 && allPlayers.length < leagueTotalPlayers);
            console.log('Using API ranks:', useApiRanks, '(hasMorePages:', hasMorePages, 'total:', leagueTotalPlayers, 'loaded:', allPlayers.length, ')');

            livePositions = {};

            // For top 100, calculate live positions within the top 100 subset
            // For players outside top 100, use API rank (we can't know real position)
            const top100Entries = currentRankings
                .filter(r => {
                    const player = allPlayers.find(p => p.entry === r.entry);
                    return player && player.rank <= 100;
                })
                .sort((a, b) => {
                    // Sort by total points; for ties preserve API order (official tiebreaker: fewest transfers)
                    if (b.total !== a.total) return b.total - a.total;
                    return a.apiRank - b.apiRank; // Use stored apiRank directly
                });

            const top100Positions = {};
            top100Entries.forEach((item, idx) => {
                top100Positions[item.entry] = idx + 1;
            });

            currentRankings.forEach((item, idx) => {
                const player = allPlayers.find(p => p.entry === item.entry);
                const isTop100 = player && player.rank <= 100;

                // Top 100: use recalculated position, Others: use API rank
                const newRank = isTop100
                    ? (top100Positions[item.entry] || idx + 1)
                    : (useApiRanks ? (player?.rank || idx + 1) : (idx + 1));

                const movement = isTop100 ? (item.oldRank - newRank) : 0;
                livePositions[item.entry] = {
                    position: newRank,
                    movement: movement,
                    currentTotal: item.total,
                    gwPoints: item.gwPoints
                };
            });
        }

        // Toggle inline row details (for mobile tap)
        function toggleRowDetails(entryId) {
            // Only work on mobile
            if (window.innerWidth > 480) return;

            const detailsRow = document.getElementById(`row-details-${entryId}`);
            if (!detailsRow) return;

            // Close all other open details
            document.querySelectorAll('.row-details').forEach(row => {
                if (row.id !== `row-details-${entryId}`) {
                    row.style.display = 'none';
                }
            });

            // Toggle this one
            detailsRow.style.display = detailsRow.style.display === 'none' ? 'table-row' : 'none';
        }

        function closeMobileModal(event) {
            // If called from backdrop click, only close if clicking the backdrop itself
            if (event && event.target && event.target !== event.currentTarget) return;
            const modal = document.getElementById('mobileModal');
            if (modal) {
                modal.classList.remove('active');
                // Remove squad-modal class for next use
                const content = modal.querySelector('.modal-content');
                if (content) content.classList.remove('squad-modal');
            }
        }

        async function openSquadModal(entryId, event) {
            if (event) event.stopPropagation();

            const live = livePoints[entryId];
            const team = allPlayers.find(p => p.entry === entryId);
            if (!team) return;

            // Show modal immediately with loading state
            document.getElementById('modalName').textContent = team.entry_name;
            document.getElementById('modalTeam').textContent = team.player_name;
            const headerPts = live?.predictedPoints !== undefined ? live.predictedPoints : (live?.points || '');
            document.getElementById('modalHeaderPts').textContent = headerPts;
            const modalContent = document.querySelector('#mobileModal .modal-content');
            if (modalContent) modalContent.classList.add('squad-modal');
            document.getElementById('modalBody').innerHTML = '<div style="text-align:center;padding:20px;color:#888;">Loading squad...</div>';
            document.getElementById('mobileModal').classList.add('active');

            // Fetch picks and transfers in parallel
            let picks = live?.picks;
            const picksPromise = (!picks && currentGameweek) ?
                fplApiFetch(`/api/entry/${entryId}/event/${currentGameweek}/picks/`).then(r => r.ok ? r.json() : null).catch(() => null) :
                Promise.resolve(null);
            const transferPromise = fetchTransferData(entryId);

            const [picksData, transferData] = await Promise.all([picksPromise, transferPromise]);
            if (picksData && !picks) {
                picks = picksData.picks;
                if (live) live.picks = picks;
            }

            if (!picks) {
                document.getElementById('modalBody').innerHTML = '<div style="text-align:center;padding:20px;color:#ff6b6b;">Could not load squad data</div>';
                return;
            }

            const posLabels = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            const posClasses = { 1: 'pos-gk', 2: 'pos-def', 3: 'pos-mid', 4: 'pos-fwd' };

            // Build auto-sub lookup
            const autoSubOut = new Set((live?.autoSubs || []).map(s => s.out));
            const autoSubIn = new Set((live?.autoSubs || []).map(s => s.in));

            // Build live bonus lookup from bpsPlayers (track confirmed vs provisional)
            const bonusLookup = {};
            if (live?.bpsPlayers) {
                live.bpsPlayers.forEach(bp => {
                    bonusLookup[bp.name] = { bonus: bp.bonus, isConfirmed: bp.isConfirmed };
                });
            }

            const starting = picks.filter(p => p.position <= 11);
            const bench = picks.filter(p => p.position > 11).sort((a, b) => a.position - b.position);

            function buildPlayerRow(pick, isBench) {
                const info = bootstrapPlayers ? bootstrapPlayers[pick.element] : null;
                const pData = livePlayerData ? livePlayerData[pick.element] : null;
                const name = info ? info.name : 'Unknown';
                const pos = info ? info.position : 0;
                const rawPts = pData ? pData.points : 0;
                const mins = pData ? pData.minutes : 0;

                // Add provisional bonus to points (confirmed bonus is already in pData.points)
                const bnsInfo = bonusLookup[name];
                const provisionalBonus = (bnsInfo && !bnsInfo.isConfirmed) ? bnsInfo.bonus : 0;
                const pts = rawPts + provisionalBonus;

                // Determine effective multiplier (consider VC activation)
                let multiplier = pick.multiplier;
                if (live?.vcActivated && pick.is_vice_captain) multiplier = 2;
                if (live?.vcActivated && pick.is_captain) multiplier = 0;

                const displayPts = pts * (multiplier || 1);

                // Auto-sub classes
                let rowClass = 'squad-player';
                if (isBench && !autoSubIn.has(pick.element)) rowClass += ' bench-player';
                if (autoSubIn.has(pick.element)) rowClass += ' auto-sub-in';
                if (autoSubOut.has(pick.element)) rowClass += ' auto-sub-out';

                // Build stat icons - clear text labels
                let stats = '';
                if (pData) {
                    if (pData.goals) stats += '<span class="stat-icon stat-goal">&#9917;' + pData.goals + '</span>';
                    if (pData.assists) stats += '<span class="stat-icon stat-assist">&#127919;' + pData.assists + '</span>';
                    if (pData.clean_sheets && pos <= 3) stats += '<span class="stat-icon stat-cs">CS</span>';
                    if (pData.saves >= 3) stats += '<span class="stat-icon stat-save">&#129508;' + pData.saves + '</span>';
                    if (pData.penalties_saved) stats += '<span class="stat-icon stat-pen-save">PS</span>';
                    if (pData.own_goals) stats += '<span class="stat-icon stat-og">' + pData.own_goals + 'OG</span>';
                    if (pData.penalties_missed) stats += '<span class="stat-icon stat-pen-miss">PM</span>';
                    if (pData.yellow_cards) stats += '<span class="stat-icon stat-yc"><span class="card-icon card-yellow"></span></span>';
                    if (pData.red_cards) stats += '<span class="stat-icon stat-rc"><span class="card-icon card-red"></span></span>';
                    const bns = bnsInfo ? bnsInfo.bonus : 0;
                    if (bns > 0) stats += '<span class="stat-icon stat-bonus">BPS' + bns + '</span>';
                    if (pData.defcon) stats += '<span class="stat-icon stat-defcon">DC' + pData.defcon + '</span>';
                }

                // Captain / VC / TC badge
                let badge = '';
                if (pick.is_captain && live?.isTripleCaptain) badge = '<span class="tc-badge">TC</span>';
                else if (pick.is_captain) badge = '<span class="captain-badge">C</span>';
                else if (pick.is_vice_captain) badge = '<span class="vc-badge">V</span>';

                const ptsDisplay = '' + displayPts;

                // Colour-coded points rating (based on raw pts before captain multiplier)
                let ptsColor = '#666';       // 0 = grey (blanked)
                if (mins === 0) ptsColor = '#666';
                else if (pts <= 2) ptsColor = '#ff6b6b';  // 1-2 = red (poor)
                else if (pts <= 4) ptsColor = '#ccc';      // 3-4 = white (average)
                else if (pts <= 7) ptsColor = '#7ddf7d';   // 5-7 = light green (good)
                else if (pts <= 12) ptsColor = '#00ff85';   // 8-12 = bright green (great)
                else ptsColor = '#e8a900';                  // 13+ = gold (monster haul)

                const ptsClass = 'squad-player-pts';

                return '<div class="' + rowClass + '">' +
                    '<span class="pos-badge ' + (posClasses[pos] || '') + '">' + (posLabels[pos] || '?') + '</span>' +
                    '<span class="squad-player-name">' + name + badge + '</span>' +
                    '<span class="squad-player-stats">' + stats + '</span>' +
                    '<span class="squad-player-mins">' + (mins > 0 ? mins + "'" : '-') + '</span>' +
                    '<span class="' + ptsClass + '" style="color:' + ptsColor + ';">' + ptsDisplay + '</span>' +
                    '</div>';
            }

            let html = '';

            // Starting XI - sort by position type for clean display
            const sortedStarting = [...starting].sort((a, b) => {
                const posA = bootstrapPlayers ? (bootstrapPlayers[a.element]?.position || 0) : 0;
                const posB = bootstrapPlayers ? (bootstrapPlayers[b.element]?.position || 0) : 0;
                return posA - posB;
            });
            sortedStarting.forEach(pick => { html += buildPlayerRow(pick, false); });

            // Bench divider
            html += '<div class="bench-divider">BENCH</div>';
            bench.forEach(pick => { html += buildPlayerRow(pick, true); });

            // Summary section
            if (live) {
                html += '<div style="margin-top:8px; padding-top:8px; border-top:1px solid rgba(255,255,255,0.15);">';

                // Bonus points breakdown
                if (live.bpsPlayers && live.bpsPlayers.length > 0) {
                    const bpsText = live.bpsPlayers.map(bp =>
                        '<span style="color:#ffaa00;">' + bp.name + ' +' + bp.bonus + '</span>'
                    ).join(', ');
                    html += '<div style="display:flex;justify-content:space-between;padding:4px 0;font-size:12px;">' +
                        '<span style="color:#888;">Bonus</span><span>' + bpsText + '</span></div>';
                }

                // DEFCON breakdown
                if (live.defconPlayers && live.defconPlayers.length > 0) {
                    const defText = live.defconPlayers.map(dp =>
                        '<span style="color:#e056fd;">' + dp.name + ' ' + dp.points + '</span>'
                    ).join(', ');
                    html += '<div style="display:flex;justify-content:space-between;padding:4px 0;font-size:12px;">' +
                        '<span style="color:#888;">DEFCON</span><span>' + defText + '</span></div>';
                }

                // Transfers this GW
                if (transferData && transferData.transfers.length > 0) {
                    const txHtml = transferData.transfers.map(t => {
                        const swingColor = t.swing > 0 ? '#00ff85' : t.swing < 0 ? '#ff6b6b' : '#ccc';
                        const swingText = t.swing > 0 ? '+' + t.swing : '' + t.swing;
                        return '<div style="font-size:11px;padding:1px 0;text-align:right;">' +
                            '<span style="color:#ff6b6b;">' + t.playerOut + '</span>' +
                            ' <span style="color:#888;">\u2192</span> ' +
                            '<span style="color:#00ff85;">' + t.playerIn + '</span>' +
                            ' <span style="color:' + swingColor + ';">(' + swingText + ')</span></div>';
                    }).join('');
                    html += '<div style="display:flex;justify-content:space-between;padding:4px 0;font-size:12px;">' +
                        '<span style="color:#888;align-self:flex-start;">Transfers</span><div>' + txHtml + '</div></div>';
                }

                // FT Left
                if (transferData) {
                    html += '<div style="display:flex;justify-content:space-between;padding:4px 0;font-size:12px;">' +
                        '<span style="color:#888;">FT Left</span><span>' + transferData.ftLeft + '</span></div>';
                }

                // Hit taken
                if (live.transferCost > 0) {
                    html += '<div style="display:flex;justify-content:space-between;padding:4px 0;font-size:12px;">' +
                        '<span style="color:#888;">Hit</span><span style="color:#ff6b6b;">-' + live.transferCost + '</span></div>';
                }

                // Chip
                const chipNames = { 'bboost': 'Bench Boost', '3xc': 'Triple Captain', 'freehit': 'Free Hit', 'wildcard': 'Wildcard' };
                if (live.chip) {
                    html += '<div style="display:flex;justify-content:space-between;padding:4px 0;font-size:12px;">' +
                        '<span style="color:#888;">Chip</span><span style="color:#04f5ff;">' + (chipNames[live.chip] || live.chip) + '</span></div>';
                }

                html += '</div>';
            }

            // Total row
            const gwPts = live?.predictedPoints !== undefined ? live.predictedPoints : (live?.points || 0);
            html += '<div class="squad-total-row">' +
                '<span class="squad-total-label">GW Points</span>' +
                '<span class="squad-total-pts">' + gwPts + '</span>' +
                '</div>';

            document.getElementById('modalBody').innerHTML = html;
        }

        function calculateFreeTransfers(historyData, allTransfers, chipsUsed) {
            let ft = 1; // Start with 1 FT in GW1
            for (let gw = 1; gw < currentGameweek; gw++) {
                const gwEntry = historyData.find(h => h.event === gw);
                const gwTransfers = allTransfers.filter(t => t.event === gw).length;
                const chipThisGw = chipsUsed.find(c => c.event === gw);
                const chipName = chipThisGw ? chipThisGw.name : null;

                if (chipName === 'wildcard') {
                    ft = 1; // Wildcard resets FT to 1 next GW
                } else if (chipName === 'freehit') {
                    // Free hit doesn't consume FT, carries over
                    ft = Math.min(ft + 1, 5);
                } else {
                    const freeUsed = Math.min(gwTransfers, ft);
                    ft = Math.min(ft - freeUsed + 1, 5);
                    if (ft < 1) ft = 1;
                }
            }
            return ft;
        }

        async function fetchTransferData(entryId) {
            if (transfersCache[entryId]) return transfersCache[entryId];
            try {
                const [transfersRes, historyRes] = await Promise.all([
                    fplApiFetch(`/api/entry/${entryId}/transfers/`),
                    fplApiFetch(`/api/entry/${entryId}/history/`)
                ]);
                if (!transfersRes.ok || !historyRes.ok) return null;

                const allTransfers = await transfersRes.json();
                const historyData = await historyRes.json();

                // Transfers this GW
                const gwTransfers = allTransfers.filter(t => t.event === currentGameweek);
                const transfers = gwTransfers.map(t => {
                    const playerIn = bootstrapPlayers ? (bootstrapPlayers[t.element_in]?.name || 'Unknown') : 'Unknown';
                    const playerOut = bootstrapPlayers ? (bootstrapPlayers[t.element_out]?.name || 'Unknown') : 'Unknown';
                    const inPts = livePlayerData[t.element_in]?.points || 0;
                    const outPts = livePlayerData[t.element_out]?.points || 0;
                    const swing = inPts - outPts;
                    return { playerIn, playerOut, swing };
                });

                // Calculate FT remaining
                const chipsUsed = historyData.chips || [];
                const ftBefore = calculateFreeTransfers(historyData.current || [], allTransfers, chipsUsed);
                const freeUsedThisGw = Math.min(gwTransfers.length, ftBefore);
                const ftLeft = Math.max(ftBefore - freeUsedThisGw, 0);
                // If wildcard or free hit active this GW, FT isn't consumed
                const chipThisGw = chipsUsed.find(c => c.event === currentGameweek);
                const ftDisplay = (chipThisGw && (chipThisGw.name === 'wildcard' || chipThisGw.name === 'freehit')) ? ftBefore : ftLeft;

                const result = { transfers, ftLeft: ftDisplay };
                transfersCache[entryId] = result;
                return result;
            } catch (e) {
                console.warn('Failed to fetch transfer data for', entryId, e);
                return null;
            }
        }

        function updateTableView() {
            const tbody = document.getElementById('leagueTableBody');
            if (!tbody || allPlayers.length === 0) return;

            // Pre-calculate ALL display values for each player first
            const playerData = allPlayers.map(player => {
                const live = livePoints[player.entry];
                const history = playerHistories[player.entry] || [];
                const prevGwIndex = currentGameweek - 2;
                const prevGwData = prevGwIndex >= 0 && history[prevGwIndex] ? history[prevGwIndex] : null;
                const prevGwTotal = prevGwData ? prevGwData.total_points : 0;

                // Calculate GW points (with live bonus, respect auto-subs toggle)
                let gwPoints;
                if (live) {
                    // Calculate base points by subtracting auto-sub bonus if basePoints not stored
                    const autoSubBonus = live.autoSubs ? live.autoSubs.reduce((sum, s) => sum + (s.pointsGained || 0), 0) : 0;
                    const basePoints = live.basePoints ?? (live.predictedPoints - autoSubBonus);
                    // predictedPoints already includes bonus points - don't add again!
                    gwPoints = autoSubsEnabled ? live.predictedPoints : basePoints;
                } else if (player.event_total !== undefined) {
                    // Use API-provided GW points when no live data
                    gwPoints = player.event_total;
                } else if (prevGwTotal > 0) {
                    // Calculate from history if available
                    gwPoints = player.total - prevGwTotal;
                } else {
                    // Last resort: use event_total or 0
                    gwPoints = player.event_total || 0;
                }

                // Calculate total consistently for ALL players
                // Use API total when we have it, otherwise calculate from history
                const totalDisplay = (prevGwTotal > 0) ? (prevGwTotal + gwPoints) : player.total;

                return {
                    player,
                    gwPoints,
                    totalDisplay,
                    leaguePosition: null, // Actual league position based on total points
                    movement: 0
                };
            });

            // First: Calculate ACTUAL league positions based on total points (always)
            // This is the official FPL ranking regardless of how we're sorting the display
            const isSmallLeague = !viewingMyArea && allPlayers.length <= 100;

            // Sort by total to determine league positions
            const positionSorted = [...playerData].sort((a, b) => {
                let comparison = b.totalDisplay - a.totalDisplay;
                if (comparison === 0) comparison = a.player.rank - b.player.rank;
                return comparison;
            });

            // Assign actual league positions
            positionSorted.forEach((data, idx) => {
                if (isSmallLeague || data.player.rank <= 100) {
                    // Small league or top 100: assign position based on total points order
                    data.leaguePosition = idx + 1;
                    // Calculate movement: old rank - new position (positive = moved up)
                    data.movement = (data.player.last_rank || data.player.rank) - (idx + 1);
                } else {
                    // Large league, outside top 100: use API rank (can't recalculate global position)
                    data.leaguePosition = data.player.rank;
                    data.movement = 0;
                }
            });

            // Now sort for DISPLAY based on sortColumn and sortDirection
            playerData.sort((a, b) => {
                let comparison = 0;
                if (sortColumn === 'gw') {
                    comparison = b.gwPoints - a.gwPoints;
                    // Tiebreaker: API rank (official FPL tiebreaker is fewest transfers)
                    if (comparison === 0) comparison = a.player.rank - b.player.rank;
                } else if (sortColumn === 'total') {
                    // Sort by total, then API rank as tiebreaker (official FPL tiebreaker)
                    comparison = b.totalDisplay - a.totalDisplay;
                    if (comparison === 0) comparison = a.player.rank - b.player.rank;
                } else {
                    // Default: sort by total (live standings), then API rank as tiebreaker
                    comparison = b.totalDisplay - a.totalDisplay;
                    if (comparison === 0) comparison = a.player.rank - b.player.rank;
                }
                return sortDirection === 'asc' ? -comparison : comparison;
            });

            // Extract sorted players and totals
            const sortedPlayers = playerData.map(d => d.player);

            // Pre-calculate totals for gap calculation (use sorted order)
            const playerTotals = playerData.map(d => d.totalDisplay);

            // Build table HTML - with chunked rendering for large leagues
            let tableHtml = [];
            let prevPosition = 0;
            let separatorShown = false;

            // For very large displays (300+), limit initial render for performance
            // Users can click "Show All" to see everything
            const INITIAL_RENDER_LIMIT = 300;
            const isLargeTable = playerData.length > INITIAL_RENDER_LIMIT;
            const showAllTable = !isLargeTable || window.showAllTableRows;
            const rowsToRender = showAllTable ? playerData.length : INITIAL_RENDER_LIMIT;

            playerData.slice(0, rowsToRender).forEach((data, idx) => {
                const player = data.player;
                const live = livePoints[player.entry];
                // Use actual league position (based on total points), not sorted position
                const position = data.leaguePosition;
                const movement = data.movement || 0;

                // Add separator ONCE when jumping from top 100 to user's area
                if (!separatorShown && prevPosition > 0 && prevPosition <= 100 && position > 100) {
                    separatorShown = true;
                    // Check if we can load previous records
                    const pagesAboveTop100 = [...loadedPages].filter(p => p > 2);
                    const canLoadPrev = pagesAboveTop100.length > 0 && Math.min(...pagesAboveTop100) > 3;
                    const loadPrevBtn = canLoadPrev
                        ? `<button data-action="load-prev" ontouchend="event.preventDefault(); loadMoreManagers('up');" onclick="loadMoreManagers('up')" style="margin-left: 15px; padding: 8px 16px; background: #04f5ff; color: #37003c; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600; touch-action: manipulation; -webkit-tap-highlight-color: transparent;">↑ Load Previous 100</button>`
                        : '';
                    tableHtml.push(`
                        <tr class="jump-separator">
                            <td colspan="13" style="
                                text-align: center;
                                padding: 12px;
                                background: linear-gradient(90deg, transparent, rgba(4,245,255,0.2), transparent);
                                color: #04f5ff;
                                font-size: 12px;
                                font-weight: 600;
                                border-top: 2px solid #04f5ff;
                                border-bottom: 2px solid #04f5ff;
                            ">
                                ↓ Jumped to position ${position.toLocaleString()} ↓
                                ${loadPrevBtn}
                            </td>
                        </tr>
                    `);
                }
                prevPosition = position;

                // Use pre-calculated values
                let gwPoints = data.gwPoints;
                let hitDisplay = '';
                let totalDisplay = data.totalDisplay;

                // Calculate gap to player above
                let gapHtml = '-';
                if (idx > 0) {
                    const gap = playerTotals[idx] - playerTotals[idx - 1];
                    gapHtml = `<span style="color: ${gap >= 0 ? '#00ff85' : '#ff6b6b'};">${gap}</span>`;
                }

                if (live && live.transferCost > 0) {
                    hitDisplay = `<span class="hit">(-${live.transferCost})</span>`;
                }

                // Movement indicator
                let moveHtml = '';
                if (movement > 0) {
                    moveHtml = `<span class="move-up">▲${movement}</span>`;
                } else if (movement < 0) {
                    moveHtml = `<span class="move-down">▼${Math.abs(movement)}</span>`;
                }

                // Captain display - simplified, no multiplier shown
                let captainHtml = '-';
                if (live && live.captainName) {
                    captainHtml = live.captainName;
                    if (live.vcActivated) {
                        captainHtml += ` <span class="vc-active">(VC)</span>`;
                    }
                }

                // Chip display
                let chipHtml = '';
                if (live && live.chip) {
                    const chipNames = {
                        'bboost': 'BB',
                        '3xc': 'TC',
                        'freehit': 'FH',
                        'wildcard': 'WC'
                    };
                    chipHtml = `<span class="chip-badge">${chipNames[live.chip] || live.chip}</span>`;
                }

                // Auto-sub display - compact format
                let autoSubHtml = '';
                if (live && live.autoSubs && live.autoSubs.length > 0) {
                    autoSubHtml = live.autoSubs.map(sub => {
                        // Show more of the name - truncate at 12 chars
                        const shortName = sub.inName.length > 12 ? sub.inName.substring(0, 11) + '..' : sub.inName;
                        return `<span class="autosub-info">${shortName} <span style="color:#ffaa00;">+${sub.pointsGained}</span></span>`;
                    }).join('<br>');
                }

                // Bonus display - show all players with full names
                let bonusHtml = '';
                if (live && live.bpsPlayers && live.bpsPlayers.length > 0) {
                    bonusHtml = live.bpsPlayers.map(p => {
                        return `<span class="bps-pts">${p.name} +${p.bonus}</span>`;
                    }).join('<br>');
                }

                // Status display
                let statusHtml = '';
                if (live) {
                    const playing = live.playersPlaying || 0;
                    const toPlay = live.playersYetToPlay || 0;
                    if (playing > 0) {
                        statusHtml = `<span class="status-playing">${playing} playing</span>`;
                    } else if (toPlay > 0) {
                        statusHtml = `<span class="status-toplay">${toPlay} to play</span>`;
                    } else {
                        statusHtml = `<span class="status-done">Done</span>`;
                    }
                }

                // Overall Rank
                let orHtml = '-';
                if (live && live.overallRank) {
                    orHtml = live.overallRank.toLocaleString();
                }

                // DEFCON points - show all players with full names
                let defconHtml = '';
                if (live && live.defconPlayers && live.defconPlayers.length > 0) {
                    defconHtml = live.defconPlayers.map(p => {
                        return `<span class="defcon-pts">${p.name} +${p.points}</span>`;
                    }).join('<br>');
                }

                // Highlight user's team
                const isMyTeam = player.entry === userTeamId;
                const isHighlighted = player.entry === highlightedEntry;
                const rowClass = isMyTeam ? 'my-team' : '';
                const highlightStyle = isHighlighted ? 'background-color: rgba(0, 255, 133, 0.25);' : '';

                // Build detail data for mobile modal
                const detailData = JSON.stringify({
                    name: player.player_name,
                    team: player.entry_name,
                    position: position,
                    gw: gwPoints,
                    total: totalDisplay,
                    captain: live?.captainName || '-',
                    vcActivated: live?.vcActivated || false,
                    chip: live?.chip || '',
                    autoSubs: live?.autoSubs || [],
                    bonus: live?.liveBonus || 0,
                    defcon: live?.defconPlayers || [],
                    status: statusHtml,
                    or: live?.overallRank || null,
                    gwRank: live?.gwRank || null
                }).replace(/'/g, "\\'");

                // Build expandable details for mobile (same style as toggle players sidebar)
                const chipFullNames = { 'bboost': 'Bench Boost', '3xc': 'Triple Captain', 'freehit': 'Free Hit', 'wildcard': 'Wildcard' };
                let mobileDetailsHtml = '';
                if (live) {
                    mobileDetailsHtml = '<div class="row-details-content">';

                    // GW Points (gross)
                    mobileDetailsHtml += `<div class="detail-item"><span class="detail-label">GW${currentGameweek} Pts:</span><span style="color: #00ff85;">${live.points}</span></div>`;

                    // Captain
                    if (live.captainName) {
                        const capLabel = live.isTripleCaptain ? 'Triple Cap:' : 'Captain:';
                        const capMultiplier = live.isTripleCaptain ? 3 : 2;
                        mobileDetailsHtml += `<div class="detail-item"><span class="detail-label">${capLabel}</span><span>${live.captainName} <span style="color: #00ff85;">(${live.captainPoints} × ${capMultiplier})</span></span></div>`;
                    }

                    // Hit Taken
                    if (live.transferCost > 0) {
                        mobileDetailsHtml += `<div class="detail-item"><span class="detail-label">Hit Taken:</span><span style="color: #ffaa00;">-${live.transferCost}</span></div>`;
                    }

                    // Net GW Points
                    mobileDetailsHtml += `<div class="detail-item"><span class="detail-label">Net GW Pts:</span><span style="color: #04f5ff;">${gwPoints}</span></div>`;

                    // Auto-subs
                    if (live.autoSubs && live.autoSubs.length > 0) {
                        const hasMultipleSubs = live.autoSubs.length > 1;
                        if (hasMultipleSubs) {
                            mobileDetailsHtml += `<div class="detail-item has-sub-items"><span class="detail-label">Auto-Subs:</span><span></span></div>`;
                            live.autoSubs.forEach((s, idx, arr) => {
                                const isLast = idx === arr.length - 1;
                                mobileDetailsHtml += `<div class="detail-sub-item${isLast ? ' last-sub-item' : ''}"><span class="detail-label"></span><span style="color: #ffaa00;">${s.outName} → ${s.inName} (+${s.pointsGained})</span></div>`;
                            });
                        } else {
                            const sub = live.autoSubs[0];
                            mobileDetailsHtml += `<div class="detail-item"><span class="detail-label">Auto-Sub:</span><span style="color: #ffaa00;">${sub.outName} → ${sub.inName} (+${sub.pointsGained})</span></div>`;
                        }
                    }

                    // Bonus Points
                    if (live.bpsPlayers && live.bpsPlayers.length > 0) {
                        const totalBonus = live.bpsPlayers.reduce((sum, p) => sum + p.bonus, 0);
                        mobileDetailsHtml += `<div class="detail-item has-sub-items"><span class="detail-label">Bonus Pts:</span><span style="color: #ffaa00;">+${totalBonus}</span></div>`;
                        live.bpsPlayers.forEach((p, idx, arr) => {
                            const isLast = idx === arr.length - 1;
                            mobileDetailsHtml += `<div class="detail-sub-item${isLast ? ' last-sub-item' : ''}"><span class="detail-label"></span><span style="color: #ffaa00;">${p.name} (+${p.bonus})</span></div>`;
                        });
                    }

                    // DEFCON
                    if (live.defconPlayers && live.defconPlayers.length > 0) {
                        const hasMultipleDef = live.defconPlayers.length > 1;
                        if (hasMultipleDef) {
                            mobileDetailsHtml += `<div class="detail-item has-sub-items"><span class="detail-label">DEFCON:</span><span style="color: #e056fd;">+${live.defconPoints}</span></div>`;
                            live.defconPlayers.forEach((p, idx, arr) => {
                                const isLast = idx === arr.length - 1;
                                mobileDetailsHtml += `<div class="detail-sub-item${isLast ? ' last-sub-item' : ''}"><span class="detail-label"></span><span style="color: #e056fd;">${p.name} (+${p.points})</span></div>`;
                            });
                        } else {
                            const p = live.defconPlayers[0];
                            mobileDetailsHtml += `<div class="detail-item"><span class="detail-label">DEFCON:</span><span style="color: #e056fd;">${p.name} (+${p.points})</span></div>`;
                        }
                    }

                    // VC Active
                    if (live.vcActivated && live.vcName) {
                        mobileDetailsHtml += `<div class="detail-item"><span class="detail-label">VC Active:</span><span style="color: #04f5ff;">${live.vcName} (C)</span></div>`;
                    }

                    // Players status
                    const playing = live.playersPlaying || 0;
                    const yetToPlay = live.playersYetToPlay || 0;
                    if (playing > 0 || yetToPlay > 0) {
                        const parts = [];
                        if (playing > 0) parts.push(`<span style="color: #ff4757;">${playing} playing</span>`);
                        if (yetToPlay > 0) parts.push(`<span style="color: #888;">${yetToPlay} to play</span>`);
                        mobileDetailsHtml += `<div class="detail-item"><span class="detail-label">Players:</span><span>${parts.join(', ')}</span></div>`;
                    }

                    // Chip
                    if (live.chip) mobileDetailsHtml += `<div class="detail-item"><span class="detail-label">Chip:</span><span style="color: #04f5ff;">${chipFullNames[live.chip] || live.chip}</span></div>`;

                    // Total (with separator)
                    mobileDetailsHtml += `<div class="detail-item" style="border-top: 1px solid rgba(255,255,255,0.2); margin-top: 5px; padding-top: 8px;"><span class="detail-label">Total:</span><span style="font-weight: bold;">${totalDisplay.toLocaleString()}</span></div>`;

                    // Gap to 1st in league
                    if (idx > 0) {
                        const leaderTotal = playerTotals[0];
                        const gapTo1st = totalDisplay - leaderTotal;
                        mobileDetailsHtml += `<div class="detail-item"><span class="detail-label">Gap to 1st:</span><span style="color: ${gapTo1st >= 0 ? '#00ff85' : '#ff6b6b'};">${gapTo1st}</span></div>`;
                    }

                    // GW Rank (moved above Overall Rank)
                    if (live.gwRank) mobileDetailsHtml += `<div class="detail-item"><span class="detail-label">GW Rank:</span><span style="color: #888;">${live.gwRank.toLocaleString()}</span></div>`;

                    // Overall Rank
                    if (live.overallRank) mobileDetailsHtml += `<div class="detail-item"><span class="detail-label">Overall Rank:</span><span style="color: #888;">${live.overallRank.toLocaleString()}</span></div>`;

                    mobileDetailsHtml += '</div>';
                }

                tableHtml.push(`
                    <tr class="${rowClass}" data-entry="${player.entry}" style="${highlightStyle}" onclick="toggleRowDetails(${player.entry})">
                        <td class="col-rank">${position.toLocaleString()}</td>
                        <td class="col-move">${moveHtml}</td>
                        <td class="col-name" title="${player.entry_name} - ${player.player_name}" onclick="openSquadModal(${player.entry}, event)" style="cursor:pointer;">
                            <div class="team-name">${isMyTeam ? '⭐ ' : ''}${player.entry_name.length > 18 ? player.entry_name.substring(0, 18) + '...' : player.entry_name}</div>
                            <div class="manager-name">${player.player_name}</div>
                        </td>
                        <td class="col-gw">${gwPoints} ${hitDisplay}</td>
                        <td class="col-total">${totalDisplay.toLocaleString()}</td>
                        <td class="col-gap">${gapHtml}</td>
                        <td class="col-captain">${captainHtml}</td>
                        <td class="col-chip">${chipHtml}</td>
                        <td class="col-autosub">${autoSubHtml}</td>
                        <td class="col-bps">${bonusHtml}</td>
                        <td class="col-defcon">${defconHtml}</td>
                        <td class="col-status">${statusHtml}</td>
                        <td class="col-or">${orHtml}</td>
                    </tr>
                    <tr class="row-details" id="row-details-${player.entry}" style="display:none;">
                        <td colspan="13">${mobileDetailsHtml}</td>
                    </tr>
                `);
            });

            // Add "Show All" row when table is truncated for performance
            if (isLargeTable && !showAllTable) {
                const remaining = playerData.length - INITIAL_RENDER_LIMIT;
                tableHtml.push(`
                    <tr class="show-all-row">
                        <td colspan="13" style="
                            text-align: center;
                            padding: 15px;
                            background: linear-gradient(90deg, transparent, rgba(255,170,0,0.15), transparent);
                            border-top: 2px solid #ffaa00;
                        ">
                            <button onclick="window.showAllTableRows = true; updateTableView();" style="padding: 10px 20px; background: linear-gradient(135deg, #ffaa00, #ff6b00); color: #37003c; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
                                Show All ${remaining.toLocaleString()} More Managers
                            </button>
                            <div style="margin-top: 8px; font-size: 11px; color: #888;">Showing first ${INITIAL_RENDER_LIMIT} for faster performance</div>
                        </td>
                    </tr>
                `);
            }

            // Add "Load Next 100" row at the end when viewing user's area and there are more pages
            if (viewingMyArea && hasMorePages) {
                tableHtml.push(`
                    <tr class="load-more-row">
                        <td colspan="13" style="
                            text-align: center;
                            padding: 15px;
                            background: linear-gradient(90deg, transparent, rgba(0,255,133,0.15), transparent);
                            border-top: 2px solid #00ff85;
                        ">
                            <button data-action="load-next" ontouchend="event.preventDefault(); loadMoreManagers('down');" onclick="loadMoreManagers('down')" style="padding: 10px 20px; background: linear-gradient(135deg, #00ff85, #04f5ff); color: #37003c; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600; touch-action: manipulation; -webkit-tap-highlight-color: transparent;">↓ Load Next 100</button>
                            <div style="margin-top: 8px; font-size: 11px; color: #888;">Showing ${allPlayers.length.toLocaleString()} of ${leagueTotalPlayers > 0 ? leagueTotalPlayers.toLocaleString() : '...'}</div>
                        </td>
                    </tr>
                `);
            }

            tbody.innerHTML = tableHtml.join('');

            // Fetch data for visible players missing history (lazy load)
            fetchDataForVisiblePlayers(playerData.slice(0, rowsToRender).map(d => d.player));
        }

        // Lazy-load history and live data for visible players
        let fetchingVisibleData = false;
        async function fetchDataForVisiblePlayers(visiblePlayers) {
            if (fetchingVisibleData) return;

            // Find players missing history data (limit to 100 at a time)
            const playersNeedingData = visiblePlayers
                .filter(p => !playerHistories[p.entry])
                .slice(0, 100);

            if (playersNeedingData.length === 0) return;

            console.log(`Fetching data for ${playersNeedingData.length} visible players missing history`);
            fetchingVisibleData = true;

            try {
                await Promise.all([
                    fetchHistoriesForPlayers(playersNeedingData),
                    refreshLiveDataForPlayers(playersNeedingData)
                ]);

                // Re-render to show the new data (only if we actually fetched something)
                if (playersNeedingData.length > 0) {
                    // Small delay to batch multiple rapid calls
                    setTimeout(() => {
                        fetchingVisibleData = false;
                        updateTableView();
                    }, 100);
                }
            } catch (e) {
                console.error('Error fetching visible player data:', e);
                fetchingVisibleData = false;
            }
        }

        // Track if viewing "my area" vs top 100
        let viewingMyArea = false;
        let top100Players = null; // Cache top 100 for switching back

        // Find and scroll to user's team in the table
        async function findMyTeam() {
            if (!userTeamId) {
                console.log('No user team ID set');
                showStatus('No team ID set. Use Change to set your team.');
                setTimeout(hideStatus, 2000);
                return;
            }

            // If already loading, don't allow another click
            if (isLoadingMyArea) {
                console.log('findMyTeam: already loading, please wait');
                showStatus('Loading in progress...');
                setTimeout(hideStatus, 1500);
                return;
            }

            const targetLeague = LEAGUE_ID; // Capture current league
            console.log('findMyTeam: userTeamId=', userTeamId, 'userLeagueRank=', userLeagueRank, 'league=', targetLeague, 'LEAGUE_ID type:', typeof LEAGUE_ID);

            // Find the row with the user's team
            const myRow = document.querySelector(`tr[data-entry="${userTeamId}"]`);
            if (myRow) {
                // Scroll to the row
                myRow.scrollIntoView({ behavior: 'smooth', block: 'center' });

                // Set persistent highlight
                highlightedEntry = userTeamId;
                myRow.style.transition = 'background-color 0.3s';
                myRow.style.backgroundColor = 'rgba(0, 255, 133, 0.25)';
                return;
            }

            // User not in current view - ALWAYS fetch their rank fresh to ensure accuracy
            // Wait for any pending league load to finish
            if (isLoading) {
                showStatus('League still loading, please wait...');
                setTimeout(hideStatus, 2000);
                return;
            }

            showStatus('Finding your position...');
            const rankInfo = await fetchUserLeagueRank(targetLeague, userTeamId);
            console.log('findMyTeam: rankInfo=', rankInfo);

            // Check if league changed during fetch
            if (LEAGUE_ID !== targetLeague) {
                console.log('findMyTeam: league changed during fetch, aborting');
                hideStatus();
                return;
            }

            if (rankInfo) {
                userLeagueRank = rankInfo.rank;
                leagueTotalPlayers = rankInfo.leagueCount || leagueTotalPlayers;
                console.log('Fetched rank:', userLeagueRank, 'of', leagueTotalPlayers);

                // Now load their area
                await loadMyArea();
            } else {
                hideStatus();
                showStatus('You are not a member of this league. Find Me only works in leagues you\'ve joined.');
                setTimeout(hideStatus, 4000);
            }
        }

        // Load and display 100 managers around user's position (ADD to top 100, don't replace)
        let isLoadingMyArea = false; // Prevent double-clicks
        async function loadMyArea() {
            // Prevent multiple simultaneous calls
            if (isLoadingMyArea) {
                console.log('loadMyArea: already loading, skipping');
                return;
            }

            if (!userLeagueRank || !userTeamId) {
                console.log('loadMyArea: missing userLeagueRank or userTeamId');
                showStatus('Could not determine your position');
                setTimeout(hideStatus, 2000);
                return;
            }

            const targetLeague = LEAGUE_ID; // Capture current league for checks

            // If user is in top 100, just scroll to them
            if (userLeagueRank <= 100) {
                const myRow = document.querySelector(`tr[data-entry="${userTeamId}"]`);
                if (myRow) {
                    myRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    highlightedEntry = userTeamId;
                    myRow.style.transition = 'background-color 0.3s';
                    myRow.style.backgroundColor = 'rgba(0, 255, 133, 0.25)';
                }
                return;
            }

            // Check if user's row already exists in current data
            const existingRow = document.querySelector(`tr[data-entry="${userTeamId}"]`);
            if (existingRow) {
                existingRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                highlightedEntry = userTeamId;
                existingRow.style.transition = 'background-color 0.3s';
                existingRow.style.backgroundColor = 'rgba(0, 255, 133, 0.25)';
                return;
            }

            isLoadingMyArea = true;
            console.log('loadMyArea: userLeagueRank=', userLeagueRank, 'userTeamId=', userTeamId);
            showStatus('Loading position ' + userLeagueRank.toLocaleString() + '...');

            // Cache current top 100 if not already cached
            if (!top100Players && allPlayers.length > 0) {
                top100Players = [...allPlayers];
            }

            // Calculate pages to load (300 managers around user: 3 pages above, user's page, 3 pages below)
            const userPage = Math.ceil(userLeagueRank / 50);
            // Don't rely on leagueTotalPlayers - it may not be accurate for large leagues
            // Instead, trust that if user has a rank, those pages exist
            const minPage = Math.max(3, userPage - 3); // At least page 3 (skip top 100)
            const maxPage = userPage + 3;
            const pagesToLoad = [];

            // Load pages around user's position
            for (let i = minPage; i <= maxPage; i++) {
                pagesToLoad.push(i);
            }

            // If user is in top 150, make sure we load at least pages 3-5
            if (pagesToLoad.length === 0 || (userPage <= 3 && pagesToLoad.length < 3)) {
                pagesToLoad.length = 0; // Clear and rebuild
                for (let i = 3; i <= 5; i++) {
                    pagesToLoad.push(i);
                }
            }
            console.log('loadMyArea: userPage=', userPage, 'pagesToLoad=', pagesToLoad);

            // Clear these pages from loadedPages to force reload
            pagesToLoad.forEach(p => loadedPages.delete(p));

            try {
                const newPlayers = await fetchLeaguePages(pagesToLoad);
                console.log('loadMyArea: fetched', newPlayers.length, 'players');

                // Check if league changed during fetch
                if (LEAGUE_ID !== targetLeague) {
                    console.log('loadMyArea: league changed during fetch, aborting');
                    hideStatus();
                    return;
                }

                if (newPlayers.length > 0) {
                    // COMBINE top 100 with user's area (don't replace)
                    const top100 = top100Players || allPlayers.filter(p => p.rank <= 100);
                    const combinedMap = new Map(top100.map(p => [p.entry, p]));
                    // New players overwrite old data to ensure fresh ranks
                    newPlayers.forEach(p => combinedMap.set(p.entry, p));
                    // Sort by API rank (guaranteed to be correct from fresh API data)
                    allPlayers = [...combinedMap.values()].sort((a, b) => (a.rank || 999999) - (b.rank || 999999));
                    viewingMyArea = true;

                    // Calculate hasMorePages - use both calculation and API value
                    const maxLoadedPage = loadedPages.size > 0 ? Math.max(...loadedPages) : 0;
                    const totalPages = leagueTotalPlayers > 0 ? Math.ceil(leagueTotalPlayers / 50) : 999;
                    const calculatedHasMore = maxLoadedPage < totalPages;
                    // hasMorePages was also set by fetchLeaguePages from API's has_next - use either
                    hasMorePages = calculatedHasMore || hasMorePages;
                    console.log('loadMyArea: combined', allPlayers.length, 'players, maxPage=', maxLoadedPage, 'totalPages=', totalPages, 'leagueTotalPlayers=', leagueTotalPlayers, 'hasMorePages=', hasMorePages);

                    // Set persistent highlight BEFORE rendering so row gets green style
                    highlightedEntry = userTeamId;

                    // RENDER IMMEDIATELY (don't wait for data)
                    updateTableView();
                    renderPlayerToggles();

                    updateViewToggle();
                    updateLeagueNotice();

                    // Scroll to user's row NOW (before data loads)
                    requestAnimationFrame(() => {
                        const myRow = document.querySelector(`tr[data-entry="${userTeamId}"]`);
                        if (myRow) {
                            myRow.scrollIntoView({ behavior: 'auto', block: 'center' });
                        }
                    });

                    hideStatus();

                    // Fetch histories and live data in BACKGROUND (non-blocking)
                    Promise.all([
                        fetchHistoriesForPlayers(newPlayers),
                        refreshLiveDataForPlayers(newPlayers)
                    ]).then(() => {
                        updateTableView(); // Re-render with full data (highlight preserved via highlightedEntry)
                        // Re-scroll in case table shifted
                        const myRow = document.querySelector(`tr[data-entry="${userTeamId}"]`);
                        if (myRow) {
                            myRow.scrollIntoView({ behavior: 'auto', block: 'center' });
                        }

                        // Pre-fetch nearby pages for smoother scrolling
                        prefetchNearbyPages();
                    });
                } else {
                    console.error('loadMyArea: no players returned from pages', pagesToLoad);
                    showStatus('Could not load your position - try again');
                    setTimeout(hideStatus, 3000);
                }
            } catch (e) {
                console.error('Error loading my area:', e);
                showStatus('Error loading your position - try again');
                setTimeout(hideStatus, 3000);
            } finally {
                isLoadingMyArea = false;
            }
        }

        // Pre-fetch nearby pages in background for smoother scrolling
        async function prefetchNearbyPages() {
            if (!userLeagueRank || userLeagueRank <= 100) return;

            const userPage = Math.ceil(userLeagueRank / 50);
            const totalPages = leagueTotalPlayers > 0 ? Math.ceil(leagueTotalPlayers / 50) : 999;

            // Pages to pre-fetch: 2 above and 2 below current position
            const pagesToPrefetch = [];
            for (let i = userPage - 3; i <= userPage + 3; i++) {
                if (i > 2 && i <= totalPages && !loadedPages.has(i)) {
                    pagesToPrefetch.push(i);
                }
            }

            if (pagesToPrefetch.length === 0) return;

            console.log('Pre-fetching nearby pages:', pagesToPrefetch);

            // Fetch in background without blocking UI
            try {
                const prefetchedPlayers = await fetchLeaguePages(pagesToPrefetch);
                if (prefetchedPlayers.length > 0 && LEAGUE_ID) {
                    // Merge into allPlayers
                    const combinedMap = new Map(allPlayers.map(p => [p.entry, p]));
                    prefetchedPlayers.forEach(p => combinedMap.set(p.entry, p));
                    allPlayers = [...combinedMap.values()].sort((a, b) => a.rank - b.rank);

                    // Update hasMorePages
                    const maxLoadedPage = Math.max(...loadedPages);
                    hasMorePages = maxLoadedPage < totalPages;

                    console.log('Pre-fetch complete:', prefetchedPlayers.length, 'players added. Total:', allPlayers.length);

                    // Silently update table (no status message)
                    updateTableView();
                    updateLeagueNotice();
                }
            } catch (e) {
                console.warn('Pre-fetch failed (non-critical):', e);
            }
        }

        // Switch back to top 100 view
        async function showTop100() {
            showStatus('Loading top 100...');
            if (top100Players && top100Players.length > 0) {
                allPlayers = [...top100Players];
                viewingMyArea = false;
                hasMorePages = false; // Top 100 doesn't need Load More
                await refreshLiveData(); // Reload live stats
                updateTableView();
                renderPlayerToggles();
                updateViewToggle();
                updateLeagueNotice();
                hideStatus();
            } else {
                // Reload top 100
                loadedPages = new Set();
                hasMorePages = false;
                const players = await fetchLeaguePages([1, 2]);
                allPlayers = players.sort((a, b) => a.rank - b.rank);
                viewingMyArea = false;
                await fetchHistoriesForPlayers(players);
                await refreshLiveData(); // Reload live stats
                updateTableView();
                renderPlayerToggles();
                updateViewToggle();
                updateLeagueNotice();
                hideStatus();
            }
        }

        // Update view toggle buttons
        function updateViewToggle() {
            const findMeBtn = document.querySelector('button[onclick="findMyTeam()"]');
            const viewNotice = document.getElementById('viewingNotice');

            if (viewingMyArea && userLeagueRank) {
                // Show "viewing my area" notice and back button
                if (!viewNotice) {
                    const notice = document.createElement('div');
                    notice.id = 'viewingNotice';
                    notice.style.cssText = 'text-align: center; padding: 8px; background: rgba(4,245,255,0.1); border-radius: 8px; margin-bottom: 10px; font-size: 12px;';
                    notice.innerHTML = `
                        <span style="color: #04f5ff;">Viewing positions around #${userLeagueRank.toLocaleString()}</span>
                        <button onclick="showTop100()" style="margin-left: 10px; padding: 4px 12px; background: #37003c; border: 1px solid #04f5ff; color: #04f5ff; border-radius: 4px; cursor: pointer; font-size: 11px;">Back to Top 100</button>
                    `;
                    const tableContainer = document.querySelector('.table-view') || document.getElementById('playerToggles');
                    if (tableContainer) tableContainer.parentNode.insertBefore(notice, tableContainer);
                }
            } else {
                // Remove notice when viewing top 100
                if (viewNotice) viewNotice.remove();
            }
        }

        function loadNewLeague() {
            const newId = document.getElementById('leagueId').value.trim();
            if (newId && !isNaN(newId)) {
                // FORCE REFRESH: Clear everything immediately
                clearViewStateUI();
                const leagueTable = document.getElementById('leagueTable');
                if (leagueTable) leagueTable.innerHTML = '';

                LEAGUE_ID = parseInt(newId);
                updateDefaultLeagueButton();
                resetAndLoad();
            }
        }

        // Track if we're in elite mode
        let isEliteMode = false;

        // Save current league state to memory cache
        function saveLeagueToMemory() {
            if (!LEAGUE_ID || allPlayers.length === 0) return;

            const state = {
                allPlayers: [...allPlayers],
                playerHistories: { ...playerHistories },
                livePoints: { ...livePoints },
                livePositions: { ...livePositions },
                loadedPages: new Set(loadedPages),
                top100Players: top100Players ? [...top100Players] : null,
                userLeagueRank,
                leagueTotalPlayers,
                viewingMyArea,
                hasMorePages,
                leagueName,
                timestamp: Date.now()
            };

            leagueMemoryCache.set(LEAGUE_ID, state);
            console.log('Saved league', LEAGUE_ID, 'to memory cache');

            // Evict oldest if over limit
            if (leagueMemoryCache.size > MAX_MEMORY_CACHE) {
                const oldest = [...leagueMemoryCache.entries()].sort((a, b) => a[1].timestamp - b[1].timestamp)[0];
                leagueMemoryCache.delete(oldest[0]);
                console.log('Evicted league', oldest[0], 'from memory cache');
            }
        }

        // Restore league state from memory cache
        function restoreLeagueFromMemory(leagueId) {
            const cached = leagueMemoryCache.get(leagueId);
            if (!cached) return false;

            // Shorter expiry during live games (1 min), longer when finished (5 min)
            const maxAge = gameweekFinished ? 5 * 60 * 1000 : 60 * 1000;
            if (Date.now() - cached.timestamp > maxAge) {
                leagueMemoryCache.delete(leagueId);
                console.log('Memory cache expired for league', leagueId, '(maxAge:', maxAge/1000, 's)');
                return false;
            }

            console.log('Restoring league', leagueId, 'from memory cache');

            allPlayers = [...cached.allPlayers];
            playerHistories = { ...cached.playerHistories };
            livePoints = { ...cached.livePoints };
            livePositions = { ...cached.livePositions };
            loadedPages = new Set(cached.loadedPages);
            top100Players = cached.top100Players ? [...cached.top100Players] : null;
            userLeagueRank = cached.userLeagueRank;
            leagueTotalPlayers = cached.leagueTotalPlayers;
            viewingMyArea = cached.viewingMyArea;
            hasMorePages = cached.hasMorePages;
            leagueName = cached.leagueName;

            return true;
        }

        // Helper to aggressively clear all view state notices
        function clearViewStateUI() {
            // Remove viewing notice
            const viewNotice = document.getElementById('viewingNotice');
            if (viewNotice) viewNotice.remove();
            // Hide league notice
            const leagueNotice = document.getElementById('leagueNotice');
            if (leagueNotice) leagueNotice.style.display = 'none';
            // Hide load more section
            const loadMoreSection = document.getElementById('loadMoreSection');
            if (loadMoreSection) loadMoreSection.style.display = 'none';
            // Hide Load All progress bar
            const loadAllProgress = document.getElementById('loadAllProgress');
            if (loadAllProgress) loadAllProgress.style.display = 'none';
            // Remove any jump separators in table
            document.querySelectorAll('.jump-separator').forEach(el => el.remove());
        }

        function selectLeague() {
            const select = document.getElementById('leagueSelect');
            const selectedValue = select.value;
            console.log('Selected league from dropdown:', selectedValue, select.options[select.selectedIndex].text);

            // Save current league to memory before switching
            saveLeagueToMemory();

            // Reset sort to default when changing leagues
            sortColumn = 'total';
            sortDirection = 'desc';

            // Clear UI immediately
            clearViewStateUI();

            // Reset loading flags
            isLoadingMyArea = false;
            isLoadingMore = false;
            isLoadingAll = false;
            loadAllCancelled = true; // Cancel any in-progress Load All
            highlightedEntry = null;

            if (selectedValue === 'elite') {
                // Elite mode - load elite managers
                isEliteMode = true;
                LEAGUE_ID = null;

                // Clear table and show loading
                const leagueTable = document.getElementById('leagueTable');
                if (leagueTable) leagueTable.innerHTML = '';
                document.getElementById('playerToggles').innerHTML = '<div class="loading"><div id="loadingText">Loading...</div><div style="margin-top: 10px;"><div id="loadingPercent" style="font-size: 20px; color: #00ff88;">0%</div></div></div>';

                updateDefaultLeagueButton();
                resetAndLoadElite();
            } else {
                // Normal league mode
                isEliteMode = false;
                const newLeagueId = parseInt(selectedValue);

                // Try to restore from memory cache first
                if (restoreLeagueFromMemory(newLeagueId)) {
                    LEAGUE_ID = newLeagueId;
                    updateDefaultLeagueButton();

                    // Render immediately from cache
                    updateTableView();
                    renderPlayerToggles();
                    updateViewToggle();
                    updateLeagueNotice();
                    console.log('League restored from memory - instant switch!');

                    // Refresh live data in background
                    refreshLiveData().then(() => {
                        updateTableView();
                    });
                } else {
                    // No cache - full reload
                    LEAGUE_ID = newLeagueId;

                    // Clear table and show loading
                    const leagueTable = document.getElementById('leagueTable');
                    if (leagueTable) leagueTable.innerHTML = '';
                    document.getElementById('playerToggles').innerHTML = '<div class="loading"><div id="loadingText">Loading...</div><div style="margin-top: 10px;"><div id="loadingPercent" style="font-size: 20px; color: #00ff88;">0%</div></div></div>';

                    // Reset state for fresh load
                    viewingMyArea = false;
                    hasMorePages = false;
                    loadedPages = new Set();
                    top100Players = null;
                    userLeagueRank = null;

                    updateDefaultLeagueButton();
                    resetAndLoad();
                }
            }
        }

        function clearCacheAndReload() {
            console.log('Clearing cache for league:', LEAGUE_ID);
            localStorage.removeItem(getCacheKey(LEAGUE_ID));
            resetAndLoad();
        }

        function clearAllCaches() {
            console.log('Clearing ALL FPL caches');
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('fpl_cache_')) {
                    keysToRemove.push(key);
                }
            }
            keysToRemove.forEach(key => localStorage.removeItem(key));
            console.log('Cleared', keysToRemove.length, 'cache entries');
            resetAndLoad();
        }

        let isLoading = false;
        let loadingLeagueId = null;

        function resetAndLoad() {
            console.log('=== Switching to league:', LEAGUE_ID, '===');
            loadingLeagueId = LEAGUE_ID; // Track which league we're loading
            allPlayers = [];
            playerHistories = {};
            selectedEntries = new Set();
            hoveredEntry = null;
            livePoints = {};
            livePositions = {};
            livePlayerScores = null; // Reset live scores cache
            transfersCache = {};

            // Reset view state for new league
            viewingMyArea = false;
            hasMorePages = false;
            loadedPages = new Set();
            top100Players = null;
            userLeagueRank = null; // Will be fetched fresh for new league
            leagueTotalPlayers = 0;
            isLoadingMyArea = false;
            isLoadingMore = false;
            isLoadingAll = false;
            loadAllCancelled = true; // Cancel any in-progress Load All
            highlightedEntry = null; // Clear Find Me highlight
            updateFindMeButton(); // Disable Find Me until position is fetched

            // Clear all view state UI
            clearViewStateUI();

            if (chart) chart.destroy();
            chart = null;
            document.getElementById('playerToggles').innerHTML = '<div class="loading"><div id="loadingText">Loading...</div><div style="margin-top: 10px;"><div id="loadingPercent" style="font-size: 20px; color: #00ff88;">0%</div></div></div>';
            loadAllData();
        }

        // Elite managers data
        const eliteManagers = [
            // Legends - Top All-Time Managers
            { id: 1213878, name: "David Fairchild", category: "legend", achievement: "#1 All-Time" },
            { id: 74756, name: "Rob Mayes", category: "legend", achievement: "#2 All-Time" },
            { id: 512846, name: "Harry Daniels", category: "legend", achievement: "#3 All-Time" },
            { id: 4633, name: "Ben Crellin", category: "legend", achievement: "Chip Guru, 11× top 50k" },
            { id: 1168153, name: "Tom Dollimore", category: "legend", achievement: "World #1" },
            { id: 409941, name: "Fábio Borges", category: "legend", achievement: "8× consecutive top 5k" },
            { id: 1205614, name: "Cameron Scott", category: "legend", achievement: "Sweet Viktory" },
            { id: 121212, name: "Abinav C", category: "legend", achievement: "#7 All-Time" },
            { id: 226, name: "Colin Innes", category: "legend", achievement: "Top 50 All-Time" },
            // Content Creators
            { id: 24, name: "Let's Talk FPL", category: "creator", achievement: "YouTube 478k" },
            { id: 96, name: "FPL Mate", category: "creator", achievement: "YouTube 240k, OR 243" },
            { id: 271, name: "Big Man Bakar", category: "creator", achievement: "Twitter 200k+" },
            { id: 1301, name: "FPL Focal", category: "creator", achievement: "Former World #1" },
            { id: 3544, name: "FPL Harry", category: "creator", achievement: "FFS Podcasts" },
            { id: 746, name: "FPL Raptor", category: "creator", achievement: "Stats Analysis" },
            { id: 9, name: "Holly Shand", category: "creator", achievement: "FFS Writer" },
            { id: 5131, name: "FPL General", category: "creator", achievement: "Podcaster" },
            { id: 2869, name: "Ben Crellin", category: "creator", achievement: "BGW/DGW Spreadsheets" },
            { id: 24194, name: "Lateriser", category: "creator", achievement: "FPL Analyst" },
            // Celebrity
            { id: 76862, name: "Magnus Carlsen", category: "celebrity", achievement: "Chess GOAT, Rank #10" },
        ];

        function resetAndLoadElite() {
            console.log('=== Loading Elite Managers ===');
            allPlayers = [];
            playerHistories = {};
            selectedEntries = new Set();
            hoveredEntry = null;
            livePoints = {};
            livePositions = {};
            livePlayerScores = null;
            transfersCache = {};
            if (chart) chart.destroy();
            chart = null;
            document.getElementById('playerToggles').innerHTML = '<div class="loading"><div id="loadingText">Loading elite managers...</div><div style="margin-top: 10px;"><div id="loadingPercent" style="font-size: 20px; color: #ffd700;">0%</div></div></div>';
            loadEliteData();
        }

        async function loadEliteData() {
            isLoading = true;
            try {
                showStatus('Loading elite managers...');

                // Fetch bootstrap data for current gameweek
                await fetchBootstrapStatic();

                const loadingPercent = document.getElementById('loadingPercent');
                const loadingText = document.getElementById('loadingText');
                let loaded = 0;
                const total = eliteManagers.length + (userTeamId ? 1 : 0);

                // Add user's team first if they have one
                let managersToLoad = [...eliteManagers];
                if (userTeamId && !eliteManagers.some(m => m.id === userTeamId)) {
                    managersToLoad.unshift({
                        id: userTeamId,
                        name: "⭐ YOU",
                        category: "you",
                        achievement: "Your Team"
                    });
                }

                // Fetch data for each elite manager
                const players = [];
                const histories = {};

                for (const manager of managersToLoad) {
                    try {
                        // Fetch entry data
                        const entryUrl = `https://fantasy.premierleague.com/api/entry/${manager.id}/`;
                        const entryResponse = await fetchWithFallback(entryUrl);
                        const entryData = await entryResponse.json();

                        // Fetch history data
                        const historyUrl = `https://fantasy.premierleague.com/api/entry/${manager.id}/history/`;
                        const historyResponse = await fetchWithFallback(historyUrl);
                        const historyData = await historyResponse.json();

                        // Format as player object matching existing structure
                        const player = {
                            entry: manager.id,
                            entry_name: entryData.name,
                            player_name: manager.name,
                            total: entryData.summary_overall_points || 0,
                            rank: entryData.summary_overall_rank || 0,
                            event_total: entryData.summary_event_points || 0,
                            // Add elite-specific fields
                            isElite: manager.category !== 'you',
                            isUser: manager.category === 'you',
                            eliteCategory: manager.category,
                            eliteAchievement: manager.achievement
                        };

                        players.push(player);
                        histories[manager.id] = historyData.current || [];

                        loaded++;
                        if (loadingPercent) {
                            loadingPercent.textContent = Math.round((loaded / total) * 100) + '%';
                        }
                        if (loadingText) {
                            loadingText.textContent = `Loading ${manager.name}...`;
                        }
                    } catch (error) {
                        console.error(`Failed to load ${manager.name}:`, error);
                        loaded++;
                    }
                }

                // Sort by total points descending
                players.sort((a, b) => b.total - a.total);

                // Assign ranks based on sorted position
                players.forEach((p, idx) => {
                    p.last_rank = idx + 1;
                    p.rank = idx + 1;
                });

                allPlayers = players;
                playerHistories = histories;
                leagueName = '⭐ vs The Best';
                document.title = 'FPL Tracker - vs The Best';

                // Select top 10 by default (or user + top 9)
                const userEntry = players.find(p => p.isUser);
                if (userEntry) {
                    selectedEntries.add(userEntry.entry);
                    players.filter(p => !p.isUser).slice(0, 9).forEach(p => selectedEntries.add(p.entry));
                } else {
                    players.slice(0, 10).forEach(p => selectedEntries.add(p.entry));
                }

                // Populate week range selectors
                weekRangeEnd = currentGameweek || 38;
                populateWeekSelectors();

                renderPlayerToggles();
                updateChart();
                hideStatus();

                console.log('Elite data loaded:', players.length, 'managers');

            } catch (error) {
                console.error('Failed to load elite data:', error);
                showStatus('Failed to load elite managers');
            } finally {
                isLoading = false;
            }
        }

        // High-contrast, colorblind-friendly palette (12 distinct colors)
        const colors = [
            '#FF6B6B', // Coral red
            '#4ECDC4', // Teal
            '#FFE66D', // Yellow
            '#6C5CE7', // Purple
            '#FF9F43', // Orange
            '#26DE81', // Green
            '#54A0FF', // Blue
            '#FF6EB4', // Pink
            '#A0522D', // Brown
            '#00D2D3', // Cyan
            '#8B5CF6', // Violet
            '#10B981', // Emerald
        ];

        // Fetch specific pages of league standings (in parallel for speed)
        async function fetchLeaguePages(pagesToLoad) {
            console.log('fetchLeaguePages for LEAGUE_ID:', LEAGUE_ID, 'pages:', pagesToLoad);

            // Filter out already loaded pages
            const pagesToFetch = pagesToLoad.filter(p => !loadedPages.has(p));
            if (pagesToFetch.length === 0) return [];

            // Fetch all pages in parallel
            const fetchPromises = pagesToFetch.map(async (page) => {
                try {
                    const url = `https://fantasy.premierleague.com/api/leagues-classic/${LEAGUE_ID}/standings/?page_standings=${page}`;
                    const response = await fetchWithFallback(url);
                    const data = await response.json();
                    return { page, data, success: true };
                } catch (e) {
                    console.error(`Error loading page ${page}:`, e);
                    return { page, success: false };
                }
            });

            const results = await Promise.all(fetchPromises);
            const players = [];

            for (const result of results) {
                if (!result.success) continue;

                const { page, data } = result;

                // Get league info from first page response
                if (data.league) {
                    leagueName = data.league.name;
                    document.title = 'FPL Tracker - ' + leagueName;
                }

                players.push(...data.standings.results);
                loadedPages.add(page);
                hasMorePages = data.standings.has_next;

                // Estimate total from highest rank seen
                const maxRank = Math.max(...data.standings.results.map(p => p.rank || 0));
                if (maxRank > leagueTotalPlayers) {
                    leagueTotalPlayers = hasMorePages ? Math.max(maxRank + 50, page * 50 + 50) : maxRank;
                }
            }

            return players;
        }

        // Get user's rank in a specific league
        async function fetchUserLeagueRank(leagueId, teamId) {
            try {
                const url = `https://fantasy.premierleague.com/api/entry/${teamId}/`;
                const response = await fetchWithFallback(url);
                const data = await response.json();

                // Find user's rank in this specific league
                const classicLeagues = data.leagues?.classic || [];
                const targetId = parseInt(leagueId);
                console.log('Looking for league', targetId, '(type:', typeof targetId, ') in', classicLeagues.length, 'leagues');

                // Try to find the league - handle both number and string IDs
                const league = classicLeagues.find(l => {
                    const matches = l.id === targetId || l.id === leagueId || String(l.id) === String(leagueId);
                    if (matches) console.log('Match found:', l.id, '===', targetId);
                    return matches;
                });

                if (league) {
                    console.log('Found league:', league.name, 'entry_rank:', league.entry_rank, 'entry_last_rank:', league.entry_last_rank, 'total_entries:', league.total_entries);
                    return {
                        rank: league.entry_rank,
                        lastRank: league.entry_last_rank,
                        leagueCount: league.total_entries || 0
                    };
                } else {
                    console.log('League', targetId, 'not found. User leagues:', classicLeagues.map(l => `${l.id}:${l.name}`).join(', '));
                }
                return null;
            } catch (e) {
                console.error('Failed to fetch user league rank:', e);
                return null;
            }
        }

        // Initial load: top 100 only
        async function fetchLeagueStandings() {
            console.log('fetchLeagueStandings for LEAGUE_ID:', LEAGUE_ID);

            // Reset pagination state
            loadedPages = new Set();
            hasMorePages = false;
            viewingMyArea = false;  // Reset when loading new league
            userLeagueRank = null;
            updateFindMeButton(); // Disable Find Me until position fetched

            // Get user's rank in this league (for Find Me feature)
            if (userTeamId) {
                const rankInfo = await fetchUserLeagueRank(LEAGUE_ID, userTeamId);
                if (rankInfo) {
                    userLeagueRank = rankInfo.rank;
                    leagueTotalPlayers = rankInfo.leagueCount;
                    console.log(`User rank: ${userLeagueRank} of ${leagueTotalPlayers}`);
                    updateFindMeButton(); // Enable Find Me now that we have user's position
                }
            }

            // For medium/small leagues (<=500), load all managers automatically
            // For large leagues, only load top 100 initially
            const AUTO_LOAD_THRESHOLD = 500;
            const pagesToLoad = [];

            if (leagueTotalPlayers > 0 && leagueTotalPlayers <= AUTO_LOAD_THRESHOLD) {
                // Small/medium league: load everything
                const totalPages = Math.ceil(leagueTotalPlayers / 50);
                for (let i = 1; i <= totalPages; i++) {
                    pagesToLoad.push(i);
                }
                console.log(`Small/medium league (${leagueTotalPlayers} managers): loading all ${totalPages} pages`);
            } else {
                // Large league: load top 500 initially (10 pages)
                const DEFAULT_PAGES = 10;
                for (let i = 1; i <= DEFAULT_PAGES; i++) {
                    pagesToLoad.push(i);
                }
                console.log(`Large league (${leagueTotalPlayers} managers): loading top 500 initially`);
            }

            const players = await fetchLeaguePages(pagesToLoad);

            // Sort by rank and remove duplicates
            const uniquePlayers = [...new Map(players.map(p => [p.entry, p])).values()];
            uniquePlayers.sort((a, b) => a.rank - b.rank);

            return uniquePlayers;
        }

        // Load more managers (100 at a time = 2 pages for speed)
        async function loadMoreManagers(direction = 'down') {
            if (isLoadingMore) return;

            isLoadingMore = true;
            showLoadingMore(true);

            try {
                // Find next pages to load (2 pages = 100 managers for speed)
                const maxLoadedPage = Math.max(...loadedPages, 0);
                // For 'up' direction, find min page that's not in top 100 (pages 1-2)
                const pagesAboveTop100 = [...loadedPages].filter(p => p > 2);
                const minUserAreaPage = pagesAboveTop100.length > 0 ? Math.min(...pagesAboveTop100) : 999;

                let pagesToLoad = [];
                if (direction === 'down') {
                    pagesToLoad = [maxLoadedPage + 1, maxLoadedPage + 2];
                } else {
                    // Load pages before user's area (not top 100)
                    pagesToLoad = [minUserAreaPage - 1, minUserAreaPage - 2].filter(p => p > 2);
                }

                // Filter out already loaded pages
                pagesToLoad = pagesToLoad.filter(p => !loadedPages.has(p));

                if (pagesToLoad.length === 0) {
                    hasMorePages = false;
                    isLoadingMore = false;
                    showLoadingMore(false);
                    updateLeagueNotice();
                    return;
                }

                console.log('Loading more pages:', pagesToLoad);
                const newPlayers = await fetchLeaguePages(pagesToLoad);

                if (newPlayers.length > 0) {
                    // Merge with existing players, using NEW player data (more recent rank)
                    const allEntries = new Map(allPlayers.map(p => [p.entry, p]));
                    newPlayers.forEach(p => {
                        allEntries.set(p.entry, p); // New data overwrites old
                    });
                    // Sort by API rank (guaranteed to be set for all players)
                    allPlayers = [...allEntries.values()].sort((a, b) => (a.rank || 999999) - (b.rank || 999999));

                    // Update hasMorePages based on what we've loaded
                    const newMaxPage = Math.max(...loadedPages, 0);
                    const totalPages = leagueTotalPlayers > 0 ? Math.ceil(leagueTotalPlayers / 50) : 999;
                    hasMorePages = newMaxPage < totalPages;
                    console.log('After load: maxPage=', newMaxPage, 'totalPages=', totalPages, 'hasMorePages=', hasMorePages);

                    // Re-render immediately (don't wait for data)
                    updateTableView();
                    renderPlayerToggles();
                    updateLeagueNotice();

                    // Fetch live data ONLY for new players (much faster than refreshing all)
                    Promise.all([
                        refreshLiveDataForPlayers(newPlayers),
                        fetchHistoriesForPlayers(newPlayers)
                    ]).then(() => {
                        updateTableView(); // Re-render with full data
                    });
                }
            } catch (e) {
                console.error('Error loading more:', e);
            }

            isLoadingMore = false;
            showLoadingMore(false);
        }

        // Cancel loading all managers
        function cancelLoadAll() {
            loadAllCancelled = true;
            console.log('Load All cancelled by user');
        }

        // Load ALL managers in the league (for full sorting capability)
        async function loadAllManagers() {
            if (isLoadingAll || isLoadingMore) {
                console.log('Already loading, please wait');
                return;
            }

            const targetLeague = LEAGUE_ID;
            const totalManagers = leagueTotalPlayers || 0;

            if (totalManagers === 0) {
                showStatus('Cannot determine league size');
                setTimeout(hideStatus, 2000);
                return;
            }

            const totalPages = Math.ceil(totalManagers / 50);
            const pagesToLoad = [];

            // Find all pages we haven't loaded yet
            for (let i = 1; i <= totalPages; i++) {
                if (!loadedPages.has(i)) {
                    pagesToLoad.push(i);
                }
            }

            if (pagesToLoad.length === 0) {
                showStatus('All managers already loaded!');
                setTimeout(hideStatus, 2000);
                return;
            }

            console.log(`Load All: ${pagesToLoad.length} pages to load (${totalManagers} managers)`);

            isLoadingAll = true;
            loadAllCancelled = false;

            // Show progress UI
            const progressDiv = document.getElementById('loadAllProgress');
            const progressText = document.getElementById('loadAllProgressText');
            const progressBar = document.getElementById('loadAllProgressBar');
            const loadAllBtn = document.getElementById('loadAllBtn');
            const loadAllBtn2 = document.getElementById('loadAllBtn2');

            if (progressDiv) progressDiv.style.display = 'block';
            if (loadAllBtn) loadAllBtn.style.display = 'none';
            if (loadAllBtn2) loadAllBtn2.style.display = 'none';

            let loadedCount = 0;
            const BATCH_SIZE = 5; // Load 5 pages at a time (250 managers)
            const BATCH_DELAY = 500; // 500ms between batches to avoid rate limits

            try {
                for (let i = 0; i < pagesToLoad.length; i += BATCH_SIZE) {
                    // Check if cancelled or league changed
                    if (loadAllCancelled || LEAGUE_ID !== targetLeague) {
                        console.log('Load All stopped:', loadAllCancelled ? 'cancelled' : 'league changed');
                        break;
                    }

                    const batch = pagesToLoad.slice(i, i + BATCH_SIZE);
                    const newPlayers = await fetchLeaguePages(batch);

                    if (newPlayers.length > 0) {
                        // Merge with existing players
                        const allEntries = new Map(allPlayers.map(p => [p.entry, p]));
                        newPlayers.forEach(p => allEntries.set(p.entry, p));
                        allPlayers = [...allEntries.values()].sort((a, b) => (a.rank || 999999) - (b.rank || 999999));
                    }

                    loadedCount += batch.length;
                    const percent = Math.round((loadedCount / pagesToLoad.length) * 100);
                    const managersLoaded = Math.min(loadedCount * 50, totalManagers);

                    // Update progress
                    if (progressText) progressText.textContent = `${percent}% (${managersLoaded.toLocaleString()} managers)`;
                    if (progressBar) progressBar.style.width = `${percent}%`;

                    // Update table every 10 batches (500 managers) for visual feedback
                    if (loadedCount % 10 === 0 || i + BATCH_SIZE >= pagesToLoad.length) {
                        updateTableView();
                        updateLeagueNotice();
                    }

                    // Small delay between batches to avoid rate limiting
                    if (i + BATCH_SIZE < pagesToLoad.length && !loadAllCancelled) {
                        await new Promise(resolve => setTimeout(resolve, BATCH_DELAY));
                    }
                }

                // Final render
                hasMorePages = false;
                updateTableView();
                renderPlayerToggles();
                updateLeagueNotice();

                if (!loadAllCancelled && LEAGUE_ID === targetLeague) {
                    showStatus(`Loaded all ${allPlayers.length.toLocaleString()} managers! Sorting now works on everyone.`);
                    setTimeout(hideStatus, 3000);

                    // Fetch histories for all players in background (non-blocking)
                    console.log('Starting background history fetch for all players...');
                    fetchHistoriesForPlayers(allPlayers);
                }

            } catch (e) {
                console.error('Error in Load All:', e);
                showStatus('Error loading managers. Try again.');
                setTimeout(hideStatus, 3000);
            } finally {
                isLoadingAll = false;
                loadAllCancelled = false;
                if (progressDiv) progressDiv.style.display = 'none';
                updateLeagueNotice(); // This will show/hide Load All button appropriately
            }
        }

        // Auto-preload additional pages in background for large leagues
        // This runs after initial render to pre-populate more data without blocking UI
        async function autoPreloadMorePages(targetLeagueId) {
            if (isBackgroundLoading || isLoadingMore) return;

            // Limit background preloading to first 500 managers (10 pages)
            const MAX_PRELOAD_PAGES = 10;
            const pagesLoaded = loadedPages.size;

            if (pagesLoaded >= MAX_PRELOAD_PAGES) {
                console.log('Auto-preload limit reached (10 pages)');
                return;
            }

            console.log(`Auto-preloading pages ${pagesLoaded + 1}-${Math.min(pagesLoaded + 2, MAX_PRELOAD_PAGES)}...`);

            try {
                isBackgroundLoading = true;
                const maxLoadedPage = Math.max(...loadedPages, 0);
                const pagesToLoad = [maxLoadedPage + 1, maxLoadedPage + 2].filter(p => p <= MAX_PRELOAD_PAGES);

                if (pagesToLoad.length === 0) {
                    isBackgroundLoading = false;
                    return;
                }

                // Check if league changed
                if (LEAGUE_ID !== targetLeagueId) {
                    isBackgroundLoading = false;
                    return;
                }

                const newPlayers = await fetchLeaguePages(pagesToLoad);

                if (newPlayers.length > 0 && LEAGUE_ID === targetLeagueId) {
                    // Merge with existing
                    const allEntries = new Map(allPlayers.map(p => [p.entry, p]));
                    newPlayers.forEach(p => allEntries.set(p.entry, p));
                    allPlayers = [...allEntries.values()].sort((a, b) => (a.rank || 999999) - (b.rank || 999999));

                    // Fetch histories for new players
                    await fetchHistoriesForPlayers(newPlayers);

                    // Update cache with expanded data
                    saveToCache(targetLeagueId, allPlayers, playerHistories, leagueName);

                    console.log(`Auto-preloaded ${newPlayers.length} managers (total: ${allPlayers.length})`);

                    // Continue preloading more pages if within limit
                    if (loadedPages.size < MAX_PRELOAD_PAGES && LEAGUE_ID === targetLeagueId) {
                        setTimeout(() => autoPreloadMorePages(targetLeagueId), 2000);
                    }
                }
            } catch (e) {
                console.warn('Auto-preload error:', e);
            } finally {
                isBackgroundLoading = false;
            }
        }

        // Fetch histories for a subset of players
        async function fetchHistoriesForPlayers(players) {
            const batchPromises = players.map(async (player) => {
                if (playerHistories[player.entry]) return; // Already have it
                try {
                    const history = await fetchPlayerHistory(player.entry);
                    if (history && Array.isArray(history) && history.length > 0) {
                        playerHistories[player.entry] = history;
                    }
                } catch (e) {
                    console.error(`Failed to fetch history for ${player.entry}`);
                }
            });
            await Promise.all(batchPromises);
        }

        // Update league notice for large leagues
        function updateLeagueNotice() {
            const notice = document.getElementById('leagueNotice');
            const loadedCount = document.getElementById('loadedCount');
            const totalCount = document.getElementById('totalCount');
            const loadMoreSection = document.getElementById('loadMoreSection');
            const loadedCount2 = document.getElementById('loadedCount2');
            const totalCount2 = document.getElementById('totalCount2');
            const loadAllBtn = document.getElementById('loadAllBtn');
            const loadAllBtn2 = document.getElementById('loadAllBtn2');

            // Only show "Load More" when viewing "My Area" AND there are more pages
            const showMore = viewingMyArea && hasMorePages;
            const totalDisplay = leagueTotalPlayers > 0 ? leagueTotalPlayers.toLocaleString() : (hasMorePages ? '...' : allPlayers.length);

            // Show "Load All" when league is large and not all loaded
            const notAllLoaded = leagueTotalPlayers > allPlayers.length;
            const isLargeLeague = leagueTotalPlayers > 200;
            const showLoadAll = isLargeLeague && notAllLoaded && !isLoadingAll;

            console.log('updateLeagueNotice: viewingMyArea=', viewingMyArea, 'hasMorePages=', hasMorePages, 'showMore=', showMore, 'showLoadAll=', showLoadAll, 'isLargeLeague=', isLargeLeague);

            if (notice) {
                // Show notice for large leagues (always show Load All option) OR when viewing My Area
                if (showMore || showLoadAll || isLoadingAll) {
                    loadedCount.textContent = allPlayers.length.toLocaleString();
                    totalCount.textContent = totalDisplay;
                    notice.style.display = 'block';
                } else {
                    notice.style.display = 'none';
                }
            }

            // Show/hide Load All buttons - always visible for large leagues until fully loaded
            if (loadAllBtn) {
                loadAllBtn.style.display = showLoadAll ? 'inline-block' : 'none';
            }
            if (loadAllBtn2) {
                loadAllBtn2.style.display = showLoadAll ? 'inline-block' : 'none';
            }

            if (loadMoreSection) {
                // Show Load More section when viewing My Area, OR show Load All for large leagues
                if (showMore || showLoadAll) {
                    loadedCount2.textContent = allPlayers.length.toLocaleString();
                    totalCount2.textContent = totalDisplay;
                    loadMoreSection.style.display = 'block';
                } else {
                    loadMoreSection.style.display = 'none';
                }
            }
        }

        // Show/hide loading more indicator
        function showLoadingMore(show) {
            let indicator = document.getElementById('loadingMoreIndicator');
            if (!indicator && show) {
                indicator = document.createElement('div');
                indicator.id = 'loadingMoreIndicator';
                indicator.style.cssText = 'text-align: center; padding: 15px; color: #04f5ff; font-size: 12px;';
                indicator.innerHTML = 'Loading more managers...';
                const tableContainer = document.querySelector('.table-view');
                if (tableContainer) tableContainer.appendChild(indicator);
            }
            if (indicator) {
                indicator.style.display = show ? 'block' : 'none';
            }
        }

        async function fetchPlayerHistory(entryId, retries = 2) {
            const url = `https://fantasy.premierleague.com/api/entry/${entryId}/history/`;
            for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                    let fetchUrl;
                    if (useCloudflareWorker && !workerFailed) {
                        fetchUrl = CLOUDFLARE_WORKER + encodeURIComponent(`entry/${entryId}/history/`);
                    } else {
                        fetchUrl = CORS_PROXY + encodeURIComponent(url);
                    }
                    const response = await throttledFetch(fetchUrl, { timeout: 10000 });
                    if (!response.ok) {
                        console.error(`HTTP error for entry ${entryId}: ${response.status}`);
                        if (attempt < retries) {
                            await new Promise(r => setTimeout(r, 300));
                            continue;
                        }
                        return null;
                    }
                    const text = await response.text();
                    const data = JSON.parse(text);
                    if (!data.current) {
                        console.error(`No 'current' field for entry ${entryId}:`, Object.keys(data));
                        return null;
                    }
                    return data.current;
                } catch (e) {
                    console.error(`Attempt ${attempt + 1} failed for entry ${entryId}:`, e.message);
                    if (attempt < retries) {
                        await new Promise(r => setTimeout(r, 500));
                        continue;
                    }
                    return null;
                }
            }
            return null;
        }

        async function fetchBootstrapStatic() {
            try {
                const response = await fplApiFetch('/api/bootstrap-static/');
                const data = await response.json();

                // Log all gameweeks for debugging
                const gws = data.events.map(e => ({ id: e.id, is_current: e.is_current, is_next: e.is_next, finished: e.finished, data_checked: e.data_checked, deadline: e.deadline_time }));
                console.log('Gameweeks:', gws.filter(g => g.is_current || g.is_next));

                // Find current gameweek
                const currentGw = data.events.find(e => e.is_current);
                const nextGw = data.events.find(e => e.is_next);

                // Check if "next" gameweek has actually started (deadline passed)
                if (nextGw) {
                    const deadline = new Date(nextGw.deadline_time);
                    const now = new Date();
                    if (now > deadline) {
                        // Next GW deadline has passed, so it's actually the active one
                        currentGameweek = nextGw.id;
                        gameweekFinished = nextGw.finished;
                        gwDataConfirmed = nextGw.data_checked || false;
                        console.log('Using NEXT gameweek (deadline passed):', currentGameweek, gameweekFinished ? '(finished)' : '(in progress)', gwDataConfirmed ? '(data confirmed)' : '');
                        return { gameweek: nextGw.id, finished: nextGw.finished, dataChecked: nextGw.data_checked, isNext: true };
                    }
                }

                if (currentGw) {
                    currentGameweek = currentGw.id;
                    gameweekFinished = currentGw.finished;
                    gwDataConfirmed = currentGw.data_checked || false;
                    console.log('Current gameweek:', currentGameweek, gameweekFinished ? '(finished)' : '(in progress)', gwDataConfirmed ? '(data confirmed)' : '');
                    return { gameweek: currentGw.id, finished: currentGw.finished, dataChecked: currentGw.data_checked, isNext: false };
                }

                // Fallback to next - 1
                if (nextGw) {
                    currentGameweek = nextGw.id - 1;
                    gwDataConfirmed = true;
                    return { gameweek: nextGw.id - 1, finished: true, dataChecked: true, isNext: true };
                }
                return null;
            } catch (e) {
                console.error('Failed to fetch bootstrap-static:', e);
                return null;
            }
        }

        // Fetch fixture status to detect if matches are currently in progress
        async function fetchFixtureStatus(gameweek) {
            try {
                const response = await fplApiFetch(`/api/fixtures/?event=${gameweek}`);
                const fixtures = await response.json();

                // Count fixture statuses
                let liveCount = 0;
                let finishedProvisional = 0;
                let finishedConfirmed = 0;
                let notStarted = 0;

                fixtures.forEach(f => {
                    if (f.started && !f.finished) {
                        liveCount++;
                    } else if (f.finished_provisional && !f.finished) {
                        finishedProvisional++;
                    } else if (f.finished) {
                        finishedConfirmed++;
                    } else {
                        notStarted++;
                    }
                });

                matchesInProgress = liveCount > 0;
                bonusPending = finishedProvisional > 0;

                console.log(`Fixture status GW${gameweek}: ${liveCount} live, ${finishedProvisional} bonus pending, ${finishedConfirmed} confirmed, ${notStarted} not started`);

                return {
                    matchesLive: liveCount > 0,
                    bonusPending: finishedProvisional > 0,
                    allConfirmed: finishedConfirmed === fixtures.length,
                    fixtures: fixtures.length,
                    liveCount,
                    notStarted
                };
            } catch (e) {
                console.error('Failed to fetch fixture status:', e);
                return { matchesLive: false, bonusPending: false, allConfirmed: true };
            }
        }

        // Cache for live player scores (fetched once per refresh)
        let livePlayerScores = null;
        let livePlayerData = null; // Full player data including minutes
        let bootstrapPlayers = null; // Player metadata (team, position)
        let bootstrapTeams = null; // Team ID to abbreviation mapping
        let gwFixtures = null; // Fixtures for current GW

        async function fetchBootstrapTeams() {
            if (bootstrapTeams) return bootstrapTeams;
            try {
                const response = await fplApiFetch('/api/bootstrap-static/');
                const data = await response.json();
                bootstrapTeams = {};
                data.teams.forEach(t => {
                    bootstrapTeams[t.id] = t.short_name; // e.g., 14 -> 'MUN'
                });
                console.log('Loaded teams from API:', bootstrapTeams);
                return bootstrapTeams;
            } catch (e) {
                console.error('Failed to fetch bootstrap teams:', e);
                return null;
            }
        }

        async function fetchBootstrapPlayers() {
            if (bootstrapPlayers) return bootstrapPlayers;
            try {
                const response = await fplApiFetch('/api/bootstrap-static/');
                const data = await response.json();
                bootstrapPlayers = {};
                data.elements.forEach(p => {
                    bootstrapPlayers[p.id] = {
                        team: p.team,
                        position: p.element_type, // 1=GK, 2=DEF, 3=MID, 4=FWD
                        name: p.web_name,
                        chanceOfPlaying: p.chance_of_playing_this_round, // null = fine, 0 = definitely out
                        status: p.status // 'a'=available, 'i'=injured, 'u'=unavailable, 's'=suspended, 'd'=doubtful
                    };
                });
                // Also cache teams if not already done
                if (!bootstrapTeams) {
                    bootstrapTeams = {};
                    data.teams.forEach(t => {
                        bootstrapTeams[t.id] = t.short_name;
                    });
                }
                return bootstrapPlayers;
            } catch (e) {
                console.error('Failed to fetch bootstrap players:', e);
                return null;
            }
        }

        async function fetchGwFixtures(gameweek) {
            if (gwFixtures) return gwFixtures;
            try {
                const response = await fplApiFetch(`/api/fixtures/?event=${gameweek}`);
                gwFixtures = await response.json();
                return gwFixtures;
            } catch (e) {
                console.error('Failed to fetch GW fixtures:', e);
                return [];
            }
        }

        // Fetch live Premier League fixtures via Cloudflare Worker (cached globally)
        // Normalize ESPN team names to match our internal format
        function normalizeESPNTeamName(espnName) {
            const name = espnName.toLowerCase();
            const mappings = {
                'leeds united': 'leeds',
                'tottenham hotspur': 'tottenham',
                'wolverhampton wanderers': 'wolves',
                'brighton & hove albion': 'brighton',
                'brighton hove albion': 'brighton',
                'newcastle united': 'newcastle',
                'west ham united': 'west ham',
                'leicester city': 'leicester',
                'ipswich town': 'ipswich',
                'afc bournemouth': 'bournemouth',
            };
            // Check explicit mappings first, otherwise use lowercase as-is
            return mappings[name] || name;
        }

        // Fetch today's EPL scoreboard from ESPN (all matches in one call)
        async function fetchESPNScoreboard() {
            try {
                const response = await fetch(`${ESPN_API_BASE}/scoreboard`);
                const data = await response.json();
                return data.events || [];
            } catch (e) {
                console.warn('ESPN scoreboard fetch failed:', e);
                return [];
            }
        }

        // Fetch match commentary from ESPN summary (contains assist info)
        async function fetchESPNCommentary(eventId) {
            try {
                const response = await fetch(`${ESPN_API_BASE}/summary?event=${eventId}`);
                const data = await response.json();
                return data.commentary || [];
            } catch (e) {
                console.warn('ESPN summary fetch failed for event', eventId, ':', e);
                return [];
            }
        }

        // Fetch goal data from ESPN: scoreboard for scorers + summary commentary for assists
        // Returns { teamName: [{ player: { name }, time: { elapsed }, assist: { name } | null }] }
        async function fetchESPNGoals() {
            try {
                const events = await fetchESPNScoreboard();
                if (!events.length) {
                    console.log('ESPN: no events found for today');
                    return {};
                }

                const allGoals = {}; // teamName -> [goals]

                for (const event of events) {
                    const comp = event.competitions[0];
                    if (!comp) continue;

                    // Build ESPN team ID -> normalized name mapping from competitors
                    const teamMap = {};
                    for (const c of comp.competitors) {
                        teamMap[c.team.id] = normalizeESPNTeamName(c.team.displayName);
                    }

                    // Get goal details from scoreboard
                    const goalDetails = (comp.details || []).filter(d => d.scoringPlay);
                    if (!goalDetails.length) continue;

                    // Fetch commentary for this match to get assists
                    const commentary = await fetchESPNCommentary(event.id);

                    // Parse assists from commentary text
                    // Format: "Goal! TeamA X, TeamB Y. PlayerName (TeamName) ... Assisted by AssistName with ..."
                    const assistMap = {}; // "scorerName-minute" -> assistName
                    for (const c of commentary) {
                        if (!c.text) continue;
                        const goalMatch = c.text.match(/^Goal[!.].*?\.\s+(.+?)\s+\(/);
                        if (goalMatch) {
                            const scorer = goalMatch[1].trim();
                            const assistMatch = c.text.match(/Assisted by (.+?)(?:\s+with|\s+following|\s+after|\s+from|\s+in\s|\s*\.|\s*$)/);
                            const assist = assistMatch ? assistMatch[1].trim() : null;
                            const timeMatch = c.time?.displayValue?.match(/(\d+)/);
                            const minute = timeMatch ? timeMatch[1] : '?';
                            assistMap[`${scorer}-${minute}`] = assist;
                        }
                    }

                    // Build goal objects per team
                    for (const detail of goalDetails) {
                        const scorer = detail.athletesInvolved?.[0];
                        if (!scorer) continue;

                        const teamId = detail.team?.id;
                        const teamName = teamMap[teamId];
                        if (!teamName) continue;

                        if (!allGoals[teamName]) allGoals[teamName] = [];

                        const timeStr = detail.clock?.displayValue || '?';
                        const minuteNum = timeStr.match(/(\d+)/)?.[1] || '?';

                        // Look up assist from commentary
                        const assistName = assistMap[`${scorer.displayName}-${minuteNum}`] || null;

                        let playerName = scorer.shortName || scorer.displayName;
                        if (detail.ownGoal) playerName += ' (OG)';
                        if (detail.penaltyKick) playerName += ' (P)';

                        allGoals[teamName].push({
                            player: { name: playerName },
                            time: { elapsed: parseInt(minuteNum) || minuteNum },
                            assist: assistName ? { name: assistName } : null
                        });
                    }
                }

                const teamsWithGoals = Object.keys(allGoals).filter(k => allGoals[k].length > 0);
                console.log(`ESPN: parsed goals for ${teamsWithGoals.length} teams:`, teamsWithGoals);
                return allGoals;
            } catch (e) {
                console.warn('ESPN goals fetch failed:', e);
                return {};
            }
        }

        // Map FPL team names to API-Football team names for matching
        function normalizeTeamName(name) {
            const mappings = {
                'MUN': 'Manchester United', 'MCI': 'Manchester City', 'LIV': 'Liverpool',
                'ARS': 'Arsenal', 'CHE': 'Chelsea', 'TOT': 'Tottenham', 'NEW': 'Newcastle',
                'AVL': 'Aston Villa', 'BHA': 'Brighton', 'BRE': 'Brentford', 'BOU': 'Bournemouth',
                'CRY': 'Crystal Palace', 'EVE': 'Everton', 'FUL': 'Fulham', 'NFO': 'Nottingham Forest',
                'WHU': 'West Ham', 'WOL': 'Wolves', 'IPS': 'Ipswich', 'LEI': 'Leicester', 'SOU': 'Southampton',
                'SUN': 'Sunderland', 'BUR': 'Burnley', 'LEE': 'Leeds'
            };
            return mappings[name] || name;
        }

        // Fixture ticker
        async function fetchAndUpdateTicker(gameweek) {
            try {
                // Load goal scorers for this gameweek (merges hardcoded + localStorage)
                loadGoalScorersForGameweek(gameweek);

                // Fetch teams data dynamically (handles season changes/promotion/relegation)
                const teamAbbr = await fetchBootstrapTeams() || {};

                const response = await fplApiFetch(`/api/fixtures/?event=${gameweek}`);
                const allFixtures = await response.json();
                console.log(`Ticker: Fetched ${allFixtures?.length || 0} fixtures for GW${gameweek}`, allFixtures);

                if (!allFixtures || allFixtures.length === 0) {
                    document.getElementById('fixtureTicker').style.display = 'none';
                    return;
                }

                // Check for live games
                const liveGames = allFixtures.filter(f => f.started && !f.finished);
                const hasLiveGames = liveGames.length > 0;

                // Ticker logic:
                // - If games are LIVE: show only those live games
                // - If NO games live: show ALL GW fixtures with results
                const fixtures = hasLiveGames ? liveGames : allFixtures;

                // Check for score changes (goals/VAR removals) - triggers ESPN fetch
                const startedFixtures = fixtures.filter(f => f.started);
                const liveFixtures = startedFixtures.filter(f => !f.finished);
                const isFirstLoad = Object.keys(previousScores).length === 0;

                // Track score changes: new goals AND VAR disallowed goals (score decrease)
                let scoreChanged = false;
                let matchJustFinished = false;
                console.log(`Goal check: ${liveFixtures.length} live, ${startedFixtures.length} started, isFirstLoad=${isFirstLoad}`);
                for (const f of startedFixtures) {
                    const fixtureKey = `${f.team_h}-${f.team_a}`;
                    const currentTotal = (f.team_h_score || 0) + (f.team_a_score || 0);
                    const previousTotal = previousScores[fixtureKey];
                    const wasFinished = previousFinished?.[fixtureKey];

                    console.log(`  ${fixtureKey}: current=${currentTotal}, previous=${previousTotal}, finished=${f.finished}, wasFinished=${wasFinished}`);

                    // Detect new goal or VAR disallowed goal (score went up OR down)
                    if (previousTotal !== undefined && currentTotal !== previousTotal) {
                        console.log(`⚽ SCORE CHANGE in ${fixtureKey}! ${previousTotal} → ${currentTotal}`);
                        scoreChanged = true;
                    }

                    // Detect match just finished (was live, now FT) - re-fetch for final confirmation
                    if (f.finished && !wasFinished) {
                        console.log(`🏁 MATCH FINISHED: ${fixtureKey} - re-fetching for final scorer/assist confirmation`);
                        matchJustFinished = true;
                    }

                    // Always update tracked state
                    previousScores[fixtureKey] = currentTotal;
                    previousFinished[fixtureKey] = f.finished;
                }

                // Check if there are existing goals on first load
                const hasExistingGoals = startedFixtures.some(f => (f.team_h_score || 0) + (f.team_a_score || 0) > 0);
                const shouldFetchScorers = scoreChanged || matchJustFinished || (isFirstLoad && hasExistingGoals);

                if (shouldFetchScorers) {
                    console.log(`Fetching goal details from ESPN (scoreChanged=${scoreChanged}, matchFinished=${matchJustFinished}, firstLoad=${isFirstLoad})`);
                    try {
                        const espnGoals = await fetchESPNGoals();
                        let goalsAdded = 0;
                        const hardcodedForGw = HARDCODED_GOALS[currentGameweek] || {};

                        Object.keys(espnGoals).forEach(team => {
                            // ESPN data overrides for: teams without hardcoded data,
                            // OR when a match just finished (re-confirm OGs/assists)
                            const hasHardcoded = hardcodedForGw[team]?.length > 0;
                            if ((!hasHardcoded || matchJustFinished) && espnGoals[team].length > 0) {
                                cachedGoalScorers[team] = espnGoals[team];
                                goalsAdded++;
                            }
                        });

                        if (goalsAdded > 0) {
                            console.log(`ESPN: updated goal data for ${goalsAdded} teams`);
                            saveGoalScorersToStorage();
                        }
                    } catch (e) {
                        console.warn('Could not fetch ESPN goal data:', e);
                    }
                } else if (isFirstLoad) {
                    console.log('First load - no goals yet, will fetch on first score change');
                }

                const fixtureHtml = fixtures.map(f => {
                    const home = teamAbbr[f.team_h] || 'TBC';
                    const away = teamAbbr[f.team_a] || 'TBC';
                    const homeScore = f.team_h_score ?? '-';
                    const awayScore = f.team_a_score ?? '-';

                    let statusClass = 'upcoming';
                    let statusText = '';
                    let goalScorers = '';

                    // Get goal scorers and DEDUPLICATE by player+time
                    const homeNorm = normalizeTeamName(home).toLowerCase();
                    const awayNorm = normalizeTeamName(away).toLowerCase();

                    const homeGoalsRaw = cachedGoalScorers[homeNorm] || [];
                    const awayGoalsRaw = cachedGoalScorers[awayNorm] || [];

                    // Deduplicate: combine all goals and remove duplicates by player+time
                    const seen = new Set();
                    const allGoals = [...homeGoalsRaw, ...awayGoalsRaw]
                        .filter(g => {
                            const key = `${g.player?.name || ''}-${g.time?.elapsed || 0}`;
                            if (seen.has(key)) return false;
                            seen.add(key);
                            return true;
                        })
                        .sort((a, b) => (a.time?.elapsed || 0) - (b.time?.elapsed || 0));

                    if (allGoals.length > 0) {
                        goalScorers = allGoals
                            .map(g => {
                                const scorer = g.player?.name || '?';
                                const time = g.time?.elapsed || '?';
                                const assist = g.assist?.name ? ` (${g.assist.name})` : '';

                                // Color coding:
                                // - Home team goals (including OGs that benefit home): green
                                // - Away team goals (including OGs that benefit away): cyan
                                let color = '#04f5ff'; // default cyan (away)
                                const isHomeGoal = homeGoalsRaw.some(hg => hg.player?.name === g.player?.name && hg.time?.elapsed === g.time?.elapsed);
                                if (isHomeGoal) {
                                    color = '#00ff85'; // green for home team goals
                                }

                                return `<span style="color:${color}">⚽ ${scorer} ${time}'${assist}</span>`;
                            })
                            .join(' <span style="color:#666">│</span> ');
                    }

                    if (f.finished) {
                        statusClass = 'ft';
                        statusText = 'FT';
                    } else if (f.started) {
                        statusClass = 'live';
                        statusText = f.minutes > 0 ? `${f.minutes}'` : 'LIVE';
                    } else {
                        // Format kickoff time
                        const kickoff = new Date(f.kickoff_time);
                        statusText = kickoff.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                    }

                    return `
                        <div class="fixture-item">
                            <div class="fixture-teams">
                                <span class="team-abbr home">${home}</span>
                                <span class="fixture-score">${homeScore}-${awayScore}</span>
                                <span class="team-abbr">${away}</span>
                            </div>
                            <span class="fixture-status ${statusClass}">${statusText}</span>
                            ${goalScorers ? `<span class="goal-scorers">${goalScorers}</span>` : ''}
                        </div>
                    `;
                }).join('');

                // Duplicate for seamless loop
                const tickerContent = document.getElementById('tickerContent');
                tickerContent.innerHTML = fixtureHtml + fixtureHtml;
                document.getElementById('fixtureTicker').style.display = 'block';

                // Check if any matches are live and manage auto-refresh
                const liveMatches = fixtures.some(f => f.started && !f.finished);
                hasLiveMatches = liveMatches;

                // Check for score changes using BOTH detection methods (belt and suspenders)
                const backupDetected = checkScoreChanges(fixtures);
                const shouldRefreshTable = scoreChanged || backupDetected;

                if (shouldRefreshTable) {
                    console.log(`Score change detected (scoreChanged=${scoreChanged}, backup=${backupDetected}) - refreshing table`);
                    silentRefreshLiveData();
                }

                if (liveMatches) {
                    startTickerAutoRefresh();
                    startTableAutoRefresh();
                } else {
                    stopTickerAutoRefresh();
                    stopTableAutoRefresh();
                    lastKnownScores = null; // Reset backup tracker when no live games
                }

            } catch (e) {
                console.error('Failed to fetch fixtures for ticker:', e);
                document.getElementById('fixtureTicker').style.display = 'none';
            }
        }

        // Auto-refresh ticker and table when matches are live
        let tickerRefreshInterval = null;
        let tableRefreshInterval = null;
        let hasLiveMatches = false;
        let lastKnownScores = null; // Backup score tracking for table refresh

        function startTickerAutoRefresh() {
            if (tickerRefreshInterval) return; // Already running

            tickerRefreshInterval = setInterval(async () => {
                if (!currentGameweek || document.hidden) return; // Skip if tab hidden

                console.log('Auto-refreshing ticker...');
                await fetchAndUpdateTicker(currentGameweek);
            }, 60000); // Every 60 seconds

            console.log('Ticker auto-refresh started (60s interval)');
        }

        function stopTickerAutoRefresh() {
            if (tickerRefreshInterval) {
                clearInterval(tickerRefreshInterval);
                tickerRefreshInterval = null;
                console.log('Ticker auto-refresh stopped');
            }
        }

        // Auto-refresh table during live matches (every 2 minutes)
        function startTableAutoRefresh() {
            if (tableRefreshInterval) return; // Already running

            tableRefreshInterval = setInterval(async () => {
                if (!currentGameweek || document.hidden || !LEAGUE_ID) return;

                console.log('Auto-refreshing table (2 min interval)...');
                await silentRefreshLiveData();
            }, 120000); // Every 2 minutes

            console.log('Table auto-refresh started (2 min interval)');
        }

        function stopTableAutoRefresh() {
            if (tableRefreshInterval) {
                clearInterval(tableRefreshInterval);
                tableRefreshInterval = null;
                console.log('Table auto-refresh stopped');
            }
        }

        // Silent refresh - updates table without showing status messages
        async function silentRefreshLiveData() {
            try {
                livePlayerScores = null; // Clear cache to get fresh data
                await refreshLiveData();
                updateTableView();
                console.log('Silent table refresh complete');
            } catch (e) {
                console.warn('Silent refresh failed:', e);
            }
        }

        // Backup check: detect any score changes in live fixtures
        function checkScoreChanges(fixtures) {
            const liveFixtures = fixtures.filter(f => f.started && !f.finished);
            if (liveFixtures.length === 0) return false;

            const currentScores = liveFixtures
                .map(f => `${f.team_h}:${f.team_h_score || 0}-${f.team_a_score || 0}:${f.team_a}`)
                .sort()
                .join('|');

            const hasChanged = lastKnownScores !== null && lastKnownScores !== currentScores;

            if (hasChanged) {
                console.log('Backup score check: change detected!');
                console.log('  Previous:', lastKnownScores);
                console.log('  Current:', currentScores);
            }

            lastKnownScores = currentScores;
            return hasChanged;
        }


        // Pause/resume based on tab visibility
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('Tab hidden - pausing auto-refresh');
            } else if (hasLiveMatches && currentGameweek) {
                console.log('Tab visible - refreshing ticker and table');
                fetchAndUpdateTicker(currentGameweek);
                silentRefreshLiveData();
            }
        });

        async function fetchLivePlayerScores(gameweek) {
            if (livePlayerScores) return livePlayerScores;
            try {
                const response = await fplApiFetch(`/api/event/${gameweek}/live/`);
                if (!response.ok) return null;
                const data = await response.json();
                // Build map of element_id -> { points, minutes, bonus, bps, defcon }
                livePlayerScores = {};
                livePlayerData = {};
                data.elements.forEach(el => {
                    livePlayerScores[el.id] = el.stats.total_points;

                    // Extract DEFCON points from explain array
                    let defconPoints = 0;
                    if (el.explain && Array.isArray(el.explain)) {
                        el.explain.forEach(fixture => {
                            if (fixture.stats && Array.isArray(fixture.stats)) {
                                fixture.stats.forEach(stat => {
                                    // Check for defensive contribution identifiers
                                    if (stat.identifier === 'defcon' ||
                                        stat.identifier === 'defensive_contribution' ||
                                        stat.identifier === 'defensive_contributions') {
                                        defconPoints += stat.points || 0;
                                    }
                                });
                            }
                        });
                    }

                    livePlayerData[el.id] = {
                        points: el.stats.total_points,
                        minutes: el.stats.minutes,
                        bonus: el.stats.bonus || 0,
                        bps: el.stats.bps || 0,
                        defcon: defconPoints,
                        goals: el.stats.goals_scored || 0,
                        assists: el.stats.assists || 0,
                        clean_sheets: el.stats.clean_sheets || 0,
                        yellow_cards: el.stats.yellow_cards || 0,
                        red_cards: el.stats.red_cards || 0,
                        saves: el.stats.saves || 0,
                        own_goals: el.stats.own_goals || 0,
                        penalties_saved: el.stats.penalties_saved || 0,
                        penalties_missed: el.stats.penalties_missed || 0,
                        goals_conceded: el.stats.goals_conceded || 0
                    };
                });
                console.log('Fetched live scores for', Object.keys(livePlayerScores).length, 'players');
                return livePlayerScores;
            } catch (e) {
                console.error('Failed to fetch live player scores:', e);
                return null;
            }
        }

        // Calculate live bonus points for a fixture based on BPS
        function calculateLiveBonus(fixturePlayersBps) {
            // Sort by BPS descending
            const sorted = [...fixturePlayersBps].sort((a, b) => b.bps - a.bps);
            const bonusMap = {};

            if (sorted.length === 0) return bonusMap;

            // Handle ties according to FPL rules
            let bonusLeft = 3;
            let i = 0;

            while (bonusLeft > 0 && i < sorted.length) {
                const currentBps = sorted[i].bps;
                if (currentBps === 0) break; // No bonus for 0 BPS

                // Find all players with same BPS
                const tiedPlayers = [];
                while (i < sorted.length && sorted[i].bps === currentBps) {
                    tiedPlayers.push(sorted[i].element);
                    i++;
                }

                // All tied players get the same bonus
                const bonusToAward = bonusLeft;
                tiedPlayers.forEach(el => {
                    bonusMap[el] = bonusToAward;
                });

                // Reduce bonus available
                bonusLeft -= tiedPlayers.length;
                if (bonusLeft < 0) bonusLeft = 0;
            }

            return bonusMap;
        }

        // Pre-fetch shared data for all players (call once before batch processing)
        async function prefetchSharedData(gameweek) {
            console.log('Pre-fetching shared data...');
            const [playerScores, players, fixtures] = await Promise.all([
                fetchLivePlayerScores(gameweek),
                fetchBootstrapPlayers(),
                fetchGwFixtures(gameweek)
            ]);
            console.log('Shared data pre-fetched');
            return { playerScores, players, fixtures };
        }

        async function fetchLivePoints(entryId, gameweek, sharedData = null) {
            try {
                // Get manager's picks using throttled fetch for better concurrency
                const apiPath = `/api/entry/${entryId}/event/${gameweek}/picks/`;
                let fetchUrl;
                if (useCloudflareWorker && !workerFailed) {
                    fetchUrl = CLOUDFLARE_WORKER + encodeURIComponent(`entry/${entryId}/event/${gameweek}/picks/`);
                } else {
                    fetchUrl = CORS_PROXY + encodeURIComponent('https://fantasy.premierleague.com' + apiPath);
                }
                const response = await throttledFetch(fetchUrl, { timeout: 10000 });
                if (!response.ok) return null;
                const data = await response.json();
                const h = data.entry_history;

                // Use pre-fetched shared data if available, otherwise fetch (fallback)
                const playerScores = sharedData?.playerScores || await fetchLivePlayerScores(gameweek);
                const players = sharedData?.players || await fetchBootstrapPlayers();
                const fixtures = sharedData?.fixtures || await fetchGwFixtures(gameweek);

                // Build set of teams that have finished playing
                const teamsFinished = new Set();
                const teamsPlaying = new Set();
                const teamsYetToPlay = new Set();
                fixtures.forEach(f => {
                    if (f.finished || f.finished_provisional) {
                        teamsFinished.add(f.team_h);
                        teamsFinished.add(f.team_a);
                    } else if (f.started) {
                        teamsPlaying.add(f.team_h);
                        teamsPlaying.add(f.team_a);
                    } else {
                        teamsYetToPlay.add(f.team_h);
                        teamsYetToPlay.add(f.team_a);
                    }
                });

                // Calculate live bonus for in-progress AND bonus-pending fixtures
                const liveBonusMap = {};
                let liveFixtureCount = 0;
                // Use UTC date to avoid timezone issues
                const now = new Date();
                const todayUTC = now.toISOString().split('T')[0]; // YYYY-MM-DD format
                console.log(`Today UTC: ${todayUTC}`);
                fixtures.forEach(f => {
                    // Only calculate provisional bonus for TODAY's fixtures where bonus hasn't been confirmed
                    const fixtureDate = f.kickoff_time ? f.kickoff_time.split('T')[0] : null;
                    const isToday = fixtureDate === todayUTC;
                    // Log fixture details for debugging
                    if (f.started) {
                        console.log(`Fixture ${f.team_h}v${f.team_a}: started=${f.started}, finished=${f.finished}, bonus_added=${f.bonus_added}, date=${fixtureDate}, isToday=${isToday}`);
                    }
                    if (f.started && !f.bonus_added && isToday) {
                        liveFixtureCount++;
                        // Get all players from both teams in this fixture
                        const fixturePlayers = [];
                        if (players && livePlayerData) {
                            Object.entries(players).forEach(([playerId, playerInfo]) => {
                                if (playerInfo.team === f.team_h || playerInfo.team === f.team_a) {
                                    const pData = livePlayerData[playerId];
                                    if (pData && pData.minutes > 0) {
                                        fixturePlayers.push({
                                            element: parseInt(playerId),
                                            bps: pData.bps || 0
                                        });
                                    }
                                }
                            });
                        }
                        // Calculate bonus for this fixture
                        const fixtureBonus = calculateLiveBonus(fixturePlayers);
                        if (Object.keys(fixtureBonus).length > 0) {
                            console.log(`Fixture ${f.team_h}v${f.team_a}: ${fixturePlayers.length} players, bonus=`, fixtureBonus);
                        }
                        Object.assign(liveBonusMap, fixtureBonus);
                    }
                });
                if (liveFixtureCount > 0 && Object.keys(liveBonusMap).length > 0) {
                    console.log(`Live fixtures: ${liveFixtureCount}, Total bonus map entries: ${Object.keys(liveBonusMap).length}`);
                }

                // Separate starting 11 and bench
                const starting = data.picks.filter(p => p.position <= 11);
                const bench = data.picks.filter(p => p.position > 11).sort((a, b) => a.position - b.position);

                // Vice Captain Logic: Check if captain didn't play
                const captain = data.picks.find(p => p.is_captain);
                const viceCaptain = data.picks.find(p => p.is_vice_captain);
                let vcActivated = false;
                let effectiveMultipliers = {}; // Track adjusted multipliers

                // Initialize multipliers from picks
                data.picks.forEach(p => {
                    effectiveMultipliers[p.element] = p.multiplier;
                });

                if (captain && viceCaptain) {
                    const captainInfo = players ? players[captain.element] : null;
                    const captainData = livePlayerData ? livePlayerData[captain.element] : null;
                    const captainTeam = captainInfo ? captainInfo.team : 0;
                    const captainMins = captainData ? captainData.minutes : 0;

                    // If captain's fixture is finished and they played 0 minutes
                    if (teamsFinished.has(captainTeam) && captainMins === 0) {
                        // Transfer captain multiplier to vice captain
                        effectiveMultipliers[captain.element] = 1; // Captain loses multiplier
                        effectiveMultipliers[viceCaptain.element] = captain.multiplier; // VC gets it
                        vcActivated = true;
                    }
                }

                // Calculate current points and identify players needing auto-sub
                let calculatedPoints = 0;
                let playersYetToPlay = 0;
                let playersPlaying = 0;
                const needsAutoSub = []; // Starting players with 0 mins and fixture finished

                // Debug: check for Saka specifically
                starting.forEach(pick => {
                    const pInfo = players ? players[pick.element] : null;
                    if (pInfo?.name === 'Saka') {
                        const pData = livePlayerData ? livePlayerData[pick.element] : null;
                        const mins = pData ? pData.minutes : 0;
                        const tm = pInfo.team;
                        console.log(`DEBUG Saka: team=${tm}, mins=${mins}, finished=${teamsFinished.has(tm)}, playing=${teamsPlaying.has(tm)}, yetToPlay=${teamsYetToPlay.has(tm)}`);
                    }
                });

                for (const pick of starting) {
                    const playerInfo = players ? players[pick.element] : null;
                    const playerData = livePlayerData ? livePlayerData[pick.element] : null;
                    const playerPoints = playerScores ? (playerScores[pick.element] || 0) : 0;
                    const minutes = playerData ? playerData.minutes : 0;
                    const team = playerInfo ? playerInfo.team : 0;
                    const multiplier = effectiveMultipliers[pick.element] || 1;

                    calculatedPoints += playerPoints * multiplier;

                    // Check if player yet to play
                    if (teamsYetToPlay.has(team)) {
                        playersYetToPlay++;
                    } else if (teamsPlaying.has(team)) {
                        playersPlaying++;
                    } else if (teamsFinished.has(team) && minutes === 0) {
                        // Player didn't play and fixture is done - needs auto-sub
                        const pName = players ? players[pick.element]?.name : pick.element;
                        console.log(`Needs auto-sub: ${pName} (team ${team} finished, 0 mins)`);
                        needsAutoSub.push(pick);
                    }
                }

                // Get active chip (bboost, 3xc, freehit, wildcard)
                const activeChip = data.active_chip || null;
                const isBenchBoost = activeChip === 'bboost';

                // Only count bench players if Bench Boost is active
                if (isBenchBoost) {
                    for (const pick of bench) {
                        const playerInfo = players ? players[pick.element] : null;
                        const playerPoints = playerScores ? (playerScores[pick.element] || 0) : 0;
                        const team = playerInfo ? playerInfo.team : 0;

                        // Add bench points to calculated total (Bench Boost scores all 15)
                        calculatedPoints += playerPoints;

                        if (teamsYetToPlay.has(team)) {
                            playersYetToPlay++;
                        } else if (teamsPlaying.has(team)) {
                            playersPlaying++;
                        }
                    }
                }

                // Calculate predicted points with auto-subs (proper FPL rules)
                let predictedPoints = calculatedPoints;
                const autoSubs = [];

                // Count current formation (after removing players who didn't play)
                const getFormation = (activePicks) => {
                    const formation = { 1: 0, 2: 0, 3: 0, 4: 0 }; // GK, DEF, MID, FWD
                    activePicks.forEach(pick => {
                        const info = players ? players[pick.element] : null;
                        if (info) formation[info.position]++;
                    });
                    return formation;
                };

                // Check if a substitution is valid (maintains valid formation)
                // Official FPL rules: min 1 GK, min 3 DEF, min 2 MID, min 1 FWD
                const isValidSub = (outPos, inPos, currentFormation) => {
                    // GK can only be replaced by GK
                    if (outPos === 1) return inPos === 1;
                    if (inPos === 1) return false; // Can't sub GK in for outfield

                    // Simulate the substitution
                    const newFormation = { ...currentFormation };
                    newFormation[outPos]--;
                    newFormation[inPos]++;

                    // Check official FPL formation requirements
                    if (newFormation[1] < 1) return false; // Need at least 1 GK
                    if (newFormation[2] < 3) return false; // Need at least 3 DEF
                    if (newFormation[3] < 2) return false; // Need at least 2 MID
                    if (newFormation[4] < 1) return false; // Need at least 1 FWD

                    return true;
                };

                // Track which players are "active" (starting + already subbed in)
                let activePicks = starting.filter(p => !needsAutoSub.includes(p));
                const usedBench = new Set();

                // Process auto-subs in order
                for (const outPlayer of needsAutoSub) {
                    const outInfo = players ? players[outPlayer.element] : null;
                    const outPos = outInfo ? outInfo.position : 0;
                    const currentFormation = getFormation(activePicks);

                    // Find first valid bench player (in bench order: 12, 13, 14, 15)
                    for (const benchPlayer of bench) {
                        if (usedBench.has(benchPlayer.element)) continue;

                        const benchInfo = players ? players[benchPlayer.element] : null;
                        const benchPos = benchInfo ? benchInfo.position : 0;
                        const benchData = livePlayerData ? livePlayerData[benchPlayer.element] : null;
                        const benchMins = benchData ? benchData.minutes : 0;
                        const benchTeam = benchInfo ? benchInfo.team : 0;

                        // Check fixture status for this bench player
                        const benchFixtureStarted = teamsPlaying.has(benchTeam) || teamsFinished.has(benchTeam);
                        const benchFixtureYetToPlay = teamsYetToPlay.has(benchTeam);

                        // Skip players who are definitely out (injured/unavailable/suspended or 0% chance)
                        if (benchInfo) {
                            const unavailable = ['i', 'u', 's'].includes(benchInfo.status);
                            const zeroChance = benchInfo.chanceOfPlaying === 0;
                            console.log(`Auto-sub check: ${benchInfo.name} - status=${benchInfo.status}, chance=${benchInfo.chanceOfPlaying}, mins=${benchMins}, unavailable=${unavailable}, zeroChance=${zeroChance}`);
                            if (unavailable || zeroChance) continue; // Won't play this GW
                        }

                        // Check if bench player actually played (for finished fixtures)
                        const benchFixtureFinished = teamsFinished.has(benchTeam);
                        if (benchFixtureFinished && benchMins === 0) continue; // Didn't play

                        // Check if substitution is valid for formation
                        if (!isValidSub(outPos, benchPos, currentFormation)) continue;

                        // Valid sub found!
                        usedBench.add(benchPlayer.element);
                        activePicks.push(benchPlayer);

                        const benchPoints = playerScores ? (playerScores[benchPlayer.element] || 0) : 0;
                        const outPoints = playerScores ? (playerScores[outPlayer.element] || 0) : 0;
                        const outMultiplier = effectiveMultipliers[outPlayer.element] || 1;

                        // Add the difference (use effective multiplier for VC scenarios)
                        predictedPoints += (benchPoints - outPoints) * outMultiplier;

                        // Count if this auto-subbed player is yet to play or playing
                        if (teamsYetToPlay.has(benchTeam)) {
                            playersYetToPlay++;
                        } else if (teamsPlaying.has(benchTeam)) {
                            playersPlaying++;
                        }

                        autoSubs.push({
                            out: outPlayer.element,
                            in: benchPlayer.element,
                            outName: outInfo?.name || '?',
                            inName: benchInfo?.name || '?',
                            pointsGained: benchPoints
                        });
                        break;
                    }
                }

                // Always use calculated points - it sums live player scores in real-time
                // h.points from API only updates after games finish
                const points = calculatedPoints;
                const transferCost = h.event_transfers_cost || 0;
                const netPoints = points - transferCost;

                // Calculate provisional bonus for in-progress fixtures only
                // (confirmed bonus is already included in total_points)
                let liveBonus = 0;
                let totalDefcon = 0;
                const defconPlayers = []; // Track which players earned DEFCON
                const bpsPlayers = []; // Track players in bonus positions
                const activePlayers = isBenchBoost ? data.picks : data.picks.filter(p => p.position <= 11);
                activePlayers.forEach(pick => {
                    const playerInfo = players ? players[pick.element] : null;
                    const playerLiveData = livePlayerData ? livePlayerData[pick.element] : null;

                    // Track provisional bonus (live matches) AND confirmed bonus (finished matches)
                    const provisionalBonus = liveBonusMap[pick.element] || 0;
                    const confirmedBonus = playerLiveData?.bonus || 0;

                    // Show provisional if available (live), otherwise show confirmed (finished)
                    const displayBonus = provisionalBonus > 0 ? provisionalBonus : confirmedBonus;
                    if (displayBonus > 0) {
                        bpsPlayers.push({
                            name: playerInfo?.name || 'Unknown',
                            bonus: displayBonus,
                            bps: playerLiveData?.bps || 0,
                            isConfirmed: provisionalBonus === 0 && confirmedBonus > 0
                        });
                    }
                    // Only add provisional to liveBonus (confirmed already in total_points)
                    liveBonus += provisionalBonus;

                    // Sum DEFCON points for active players
                    if (playerLiveData && playerLiveData.defcon) {
                        totalDefcon += playerLiveData.defcon;
                        defconPlayers.push({
                            name: playerInfo?.name || 'Unknown',
                            points: playerLiveData.defcon
                        });
                    }
                });

                // Also count DEFCON and BPS for auto-subbed players
                autoSubs.forEach(sub => {
                    const playerLiveData = livePlayerData ? livePlayerData[sub.in] : null;
                    const playerInfo = players ? players[sub.in] : null;
                    if (playerLiveData && playerLiveData.defcon) {
                        totalDefcon += playerLiveData.defcon;
                        defconPlayers.push({
                            name: playerInfo?.name || 'Unknown',
                            points: playerLiveData.defcon
                        });
                    }
                    // Auto-subbed players can also have bonus points
                    if (playerLiveData && playerLiveData.bonus > 0) {
                        bpsPlayers.push({
                            name: playerInfo?.name || 'Unknown',
                            bonus: playerLiveData.bonus,
                            bps: playerLiveData.bps || 0,
                            isConfirmed: true
                        });
                    }
                });

                // Get captain and vice captain names for display
                const captainInfo = captain && players ? players[captain.element] : null;
                const captainName = captainInfo ? captainInfo.name : null;
                const captainPoints = captain && playerScores ? (playerScores[captain.element] || 0) : 0;
                const vcInfo = viceCaptain && players ? players[viceCaptain.element] : null;
                const vcName = vcInfo ? vcInfo.name : null;

                // Sort BPS players by bonus (highest first)
                bpsPlayers.sort((a, b) => b.bonus - a.bonus);

                // Debug: log bonus calculation
                if (liveBonus > 0) {
                    console.log(`BPS Debug [${entryId}]: liveBonus=${liveBonus}, bpsPlayers=`, bpsPlayers.map(p => `${p.name}(+${p.bonus})`));
                }

                // Add provisional bonus to predicted points for live updates
                calculatedPoints += liveBonus;
                predictedPoints += liveBonus;

                // Store both: basePoints (without auto-subs) and predictedPoints (with auto-subs)
                const basePointsWithBonus = calculatedPoints - transferCost;
                const predictedWithBonus = predictedPoints - transferCost;

                return {
                    points: points,
                    netPoints: netPoints,
                    transferCost: transferCost,
                    totalPoints: h.total_points,
                    overallRank: h.overall_rank,
                    gwRank: h.rank,
                    chip: activeChip,
                    playersYetToPlay: playersYetToPlay,
                    playersPlaying: playersPlaying,
                    basePoints: basePointsWithBonus,        // GW points WITHOUT auto-subs
                    predictedPoints: predictedWithBonus,    // GW points WITH auto-subs
                    autoSubs: autoSubs,
                    vcActivated: vcActivated,
                    vcName: vcName,
                    liveBonus: liveBonus,
                    bpsPlayers: bpsPlayers,
                    defconPoints: totalDefcon,
                    defconPlayers: defconPlayers,
                    captainName: captainName,
                    captainPoints: captainPoints,
                    isTripleCaptain: activeChip === '3xc',
                    picks: data.picks
                };
            } catch (e) {
                console.error(`Failed to fetch live points for ${entryId}:`, e);
                return null;
            }
        }

        async function refreshLiveData() {
            if (!currentGameweek || allPlayers.length === 0) {
                console.log('refreshLiveData skipped: currentGameweek=', currentGameweek, 'allPlayers.length=', allPlayers.length);
                return;
            }

            console.log('Refreshing live data for GW', currentGameweek, '- fetching for', allPlayers.length, 'players');
            const refreshBtn = document.getElementById('refreshLiveBtn');
            if (refreshBtn) {
                refreshBtn.textContent = 'Updating...';
                refreshBtn.disabled = true;
            }

            try {
            // Clear cached data to get fresh data
            livePlayerScores = null;
            livePlayerData = null;
            gwFixtures = null;
            bootstrapPlayers = null;
            bootstrapTeams = null;

            // Pre-fetch ALL shared data in parallel ONCE before processing players
            console.log('Pre-fetching shared data and fixture status...');
            const [fixtureStatus, sharedData] = await Promise.all([
                fetchFixtureStatus(currentGameweek),
                prefetchSharedData(currentGameweek)
            ]);
            console.log('Fixture status:', fixtureStatus);

            // Build goal scorer data from FPL live stats (uses player goals/assists)
            buildGoalDataFromFPL();

            const newLivePoints = {};

            // Prioritize selected players first, then top 20, then rest
            const selectedArray = allPlayers.filter(p => selectedEntries.has(p.entry));
            const top20 = allPlayers.slice(0, 20).filter(p => !selectedEntries.has(p.entry));
            const rest = allPlayers.slice(20).filter(p => !selectedEntries.has(p.entry));
            const prioritizedPlayers = [...selectedArray, ...top20, ...rest];

            // Aggressive batch size for maximum throughput
            const LIVE_BATCH_SIZE = Math.min(100, Math.max(50, prioritizedPlayers.length));
            const totalBatches = Math.ceil(prioritizedPlayers.length / LIVE_BATCH_SIZE);
            console.log(`Processing ${prioritizedPlayers.length} players in ${totalBatches} batches of ${LIVE_BATCH_SIZE}`);

            for (let batchIdx = 0; batchIdx < totalBatches; batchIdx++) {
                const startIdx = batchIdx * LIVE_BATCH_SIZE;
                const endIdx = Math.min(startIdx + LIVE_BATCH_SIZE, prioritizedPlayers.length);
                const batch = prioritizedPlayers.slice(startIdx, endIdx);

                // Fetch all in batch in parallel, passing shared data to avoid redundant fetches
                const batchResults = await Promise.all(
                    batch.map(async (player) => {
                        const live = await fetchLivePoints(player.entry, currentGameweek, sharedData);
                        return { entry: player.entry, live, apiTotal: player.total };
                    })
                );

                // Process results
                batchResults.forEach(({ entry, live, apiTotal }) => {
                    if (live) {
                        // Get previous GW total from history
                        const history = playerHistories[entry] || [];
                        const prevGwIndex = currentGameweek - 2;
                        const prevGwData = prevGwIndex >= 0 && history[prevGwIndex] ? history[prevGwIndex] : null;
                        const prevGwTotal = prevGwData ? prevGwData.total_points : 0;

                        // Calculate GW points from API total (doesn't double-count)
                        const gwPointsFromApi = apiTotal - prevGwTotal;

                        newLivePoints[entry] = {
                            points: live.points,                    // Raw GW points (before hits)
                            netPoints: live.netPoints,              // GW points minus hits
                            transferCost: live.transferCost,
                            totalPoints: live.totalPoints,
                            chip: live.chip,
                            isLive: fixtureStatus.matchesLive,      // Only true if matches in progress
                            isBonusPending: fixtureStatus.bonusPending,
                            gwPointsFromApi: gwPointsFromApi,       // GW points calculated from API total
                            apiTotal: apiTotal,                     // The API's total (source of truth)
                            playersYetToPlay: live.playersYetToPlay,
                            playersPlaying: live.playersPlaying,
                            predictedPoints: live.predictedPoints,
                            autoSubs: live.autoSubs,
                            vcActivated: live.vcActivated,
                            vcName: live.vcName,
                            liveBonus: live.liveBonus,
                            bpsPlayers: live.bpsPlayers,
                            defconPoints: live.defconPoints,
                            defconPlayers: live.defconPlayers,
                            overallRank: live.overallRank,          // Overall FPL rank in the world
                            gwRank: live.gwRank,                     // Gameweek rank
                            captainName: live.captainName,
                            captainPoints: live.captainPoints,
                            isTripleCaptain: live.isTripleCaptain
                        };
                    }
                });

                // Update progress
                if (refreshBtn) {
                    refreshBtn.textContent = `${Math.round((endIdx / allPlayers.length) * 100)}%`;
                }
                // No delay - maximize throughput
            }

            livePoints = newLivePoints;
            console.log('Live data fetched for', Object.keys(newLivePoints).length, 'players');
            console.log('Matches in progress:', fixtureStatus.matchesLive, '| Bonus pending:', fixtureStatus.bonusPending);

            // Calculate previous GW positions (before current GW started)
            const prevGwIndex = currentGameweek - 2;

            const prevGwRankings = allPlayers.map(p => {
                const history = playerHistories[p.entry] || [];
                const prevGwData = prevGwIndex >= 0 && history[prevGwIndex] ? history[prevGwIndex] : null;
                const prevTotal = prevGwData ? prevGwData.total_points : 0;
                return { entry: p.entry, prevTotal };
            }).sort((a, b) => b.prevTotal - a.prevTotal);

            const prevPositions = {};
            prevGwRankings.forEach((item, idx) => {
                prevPositions[item.entry] = idx + 1;
            });

            // Debug: show previous positions
            const prevPosDebug = prevGwRankings.slice(0, 10).map((r, i) => {
                const player = allPlayers.find(p => p.entry === r.entry);
                return `#${i+1}: ${player ? player.player_name : r.entry} (${r.prevTotal} pts)`;
            });
            console.log('Previous GW positions (end of GW' + (currentGameweek - 1) + '):', prevPosDebug);

            // Calculate current positions using API total as source of truth
            // If matches are live, we may need to add live delta on top
            const currentRankings = allPlayers.map(p => {
                const live = newLivePoints[p.entry];
                const history = playerHistories[p.entry] || [];
                const prevGwData = prevGwIndex >= 0 && history[prevGwIndex] ? history[prevGwIndex] : null;
                const prevTotal = prevGwData ? prevGwData.total_points : 0;

                let currentTotal;
                let gwPoints;

                if (live) {
                    // Calculate base points by subtracting auto-sub bonus if basePoints not stored
                    const autoSubBonus = live.autoSubs ? live.autoSubs.reduce((sum, s) => sum + (s.pointsGained || 0), 0) : 0;
                    const basePoints = live.basePoints ?? (live.predictedPoints - autoSubBonus);
                    // predictedPoints already includes bonus - don't add again!
                    gwPoints = autoSubsEnabled ? live.predictedPoints : basePoints;
                    currentTotal = prevTotal + gwPoints;
                } else {
                    // No live data: derive from API total
                    gwPoints = p.total - prevTotal;
                    currentTotal = prevTotal + gwPoints;
                }

                return {
                    entry: p.entry,
                    total: currentTotal,
                    oldRank: prevPositions[p.entry] || p.rank,
                    gwPoints: gwPoints,
                    transferCost: live ? live.transferCost : 0,
                    apiRank: p.rank
                };
            }).sort((a, b) => {
                // Sort by total; for ties preserve API order (official tiebreaker: fewest transfers)
                if (b.total !== a.total) return b.total - a.total;
                return a.apiRank - b.apiRank;
            });

            // Debug: show current rankings
            const rankDebug = currentRankings.slice(0, 10).map((r, i) => {
                const player = allPlayers.find(p => p.entry === r.entry);
                return `#${i+1}: ${player ? player.player_name : r.entry} (${r.total} pts, was #${r.oldRank}, GW+${r.gwPoints})`;
            });
            console.log('Current rankings (GW' + currentGameweek + '):', rankDebug);

            // For large leagues with partial data, use API ranks to avoid incorrect positioning
            // Use API ranks if: more pages exist, OR we know total and haven't loaded all
            const useApiRanks = hasMorePages || (leagueTotalPlayers > 0 && allPlayers.length < leagueTotalPlayers);

            livePositions = {};
            currentRankings.forEach((item, idx) => {
                const player = allPlayers.find(p => p.entry === item.entry);
                const newRank = useApiRanks ? (player?.rank || idx + 1) : (idx + 1);
                const movement = useApiRanks ? 0 : (item.oldRank - newRank);
                livePositions[item.entry] = {
                    position: newRank,
                    movement: movement,
                    currentTotal: item.total,
                    gwPoints: item.gwPoints
                };
            });

            // Update button text based on status
            if (refreshBtn) {
                if (fixtureStatus.matchesLive) {
                    refreshBtn.textContent = 'Refresh Live';
                    refreshBtn.style.background = '#ff4757'; // Red for live
                } else if (fixtureStatus.bonusPending) {
                    refreshBtn.textContent = 'Bonus Pending';
                    refreshBtn.style.background = '#ffaa00'; // Orange for pending
                } else {
                    refreshBtn.textContent = 'Refresh';
                    refreshBtn.style.background = ''; // Default
                }
                refreshBtn.disabled = false;
            }

            console.log('Live data updated:', Object.keys(livePoints).length, 'players');

            // Update fixture ticker
            fetchAndUpdateTicker(currentGameweek);

            renderPlayerToggles();
            if (currentFilter) filterPlayers(currentFilter);
            updateTableView();
            updateChart();

            } catch (error) {
                console.error('Error refreshing live data:', error);
                showStatus('Error refreshing live data. Click Refresh Live to retry.', true);
                if (refreshBtn) {
                    refreshBtn.textContent = 'Refresh Live';
                    refreshBtn.disabled = false;
                }
            }
        }

        // Optimized function to fetch live data for ONLY specific players (used when loading more managers)
        async function refreshLiveDataForPlayers(players) {
            if (!currentGameweek || players.length === 0) {
                console.log('refreshLiveDataForPlayers skipped: no players or gameweek');
                return;
            }

            console.log('Fetching live data for', players.length, 'new players only');
            const startTime = Date.now();

            try {
                // Fetch shared data once (use cached if available)
                const [fixtureStatus, sharedData] = await Promise.all([
                    fetchFixtureStatus(currentGameweek),
                    prefetchSharedData(currentGameweek)
                ]);

                // Build goal scorer data from FPL live stats
                buildGoalDataFromFPL();

                // Fetch live data for all new players in parallel (aggressive batching)
                const BATCH_SIZE = 50;
                const totalBatches = Math.ceil(players.length / BATCH_SIZE);
                const newPlayerLivePoints = {};

                for (let batchIdx = 0; batchIdx < totalBatches; batchIdx++) {
                    const batch = players.slice(batchIdx * BATCH_SIZE, (batchIdx + 1) * BATCH_SIZE);

                    const batchResults = await Promise.all(
                        batch.map(async (player) => {
                            const live = await fetchLivePoints(player.entry, currentGameweek, sharedData);
                            return { entry: player.entry, live, apiTotal: player.total };
                        })
                    );

                    batchResults.forEach(({ entry, live, apiTotal }) => {
                        if (live) {
                            const history = playerHistories[entry] || [];
                            const prevGwIndex = currentGameweek - 2;
                            const prevGwData = prevGwIndex >= 0 && history[prevGwIndex] ? history[prevGwIndex] : null;
                            const prevGwTotal = prevGwData ? prevGwData.total_points : 0;
                            const gwPointsFromApi = apiTotal - prevGwTotal;

                            newPlayerLivePoints[entry] = {
                                points: live.points,
                                netPoints: live.netPoints,
                                transferCost: live.transferCost,
                                totalPoints: live.totalPoints,
                                chip: live.chip,
                                isLive: fixtureStatus.matchesLive,
                                isBonusPending: fixtureStatus.bonusPending,
                                gwPointsFromApi: gwPointsFromApi,
                                apiTotal: apiTotal,
                                playersYetToPlay: live.playersYetToPlay,
                                playersPlaying: live.playersPlaying,
                                predictedPoints: live.predictedPoints,
                                autoSubs: live.autoSubs,
                                vcActivated: live.vcActivated,
                                vcName: live.vcName,
                                liveBonus: live.liveBonus,
                                bpsPlayers: live.bpsPlayers,
                                defconPoints: live.defconPoints,
                                defconPlayers: live.defconPlayers,
                                overallRank: live.overallRank,
                                gwRank: live.gwRank,
                                captainName: live.captainName,
                                captainPoints: live.captainPoints,
                                isTripleCaptain: live.isTripleCaptain
                            };
                        }
                    });
                }

                // MERGE new data with existing livePoints (don't replace)
                Object.assign(livePoints, newPlayerLivePoints);

                // Update livePositions for new players only (use API rank)
                players.forEach(player => {
                    const live = livePoints[player.entry];
                    const history = playerHistories[player.entry] || [];
                    const prevGwIndex = currentGameweek - 2;
                    const prevGwData = prevGwIndex >= 0 && history[prevGwIndex] ? history[prevGwIndex] : null;
                    const prevTotal = prevGwData ? prevGwData.total_points : 0;

                    let currentTotal, gwPoints;
                    if (live) {
                        const autoSubBonus = live.autoSubs ? live.autoSubs.reduce((sum, s) => sum + (s.pointsGained || 0), 0) : 0;
                        const basePoints = live.basePoints ?? (live.predictedPoints - autoSubBonus);
                        // predictedPoints already includes bonus - don't add again!
                        gwPoints = autoSubsEnabled ? live.predictedPoints : basePoints;
                        currentTotal = prevTotal + gwPoints;
                    } else {
                        gwPoints = player.total - prevTotal;
                        currentTotal = player.total;
                    }

                    livePositions[player.entry] = {
                        position: player.rank, // Use API rank for large leagues
                        movement: 0,
                        currentTotal: currentTotal,
                        gwPoints: gwPoints
                    };
                });

                console.log('Live data for new players fetched in', Date.now() - startTime, 'ms');

            } catch (error) {
                console.error('Error fetching live data for players:', error);
            }
        }

        async function loadAllData() {
            const targetLeague = LEAGUE_ID;
            isLoading = true;

            // Reset table display state for new league
            window.showAllTableRows = false;

            try {
                showStatus('Loading league data...');
                console.log('Loading data for league:', LEAGUE_ID);

                // Abort if league changed
                if (LEAGUE_ID !== targetLeague) {
                    console.log('League changed, aborting load');
                    return;
                }

                // Fetch current gameweek info
                await fetchBootstrapStatic();

                // Check cache first
                const cached = loadFromCache(LEAGUE_ID);
                console.log('Cache result:', cached ? `found (${cached.leagueName}, ${cached.players?.length} players)` : 'not found');
                if (cached && cached.players && cached.players.length > 0) {
                    allPlayers = cached.players;
                    playerHistories = cached.histories || {};
                    leagueName = cached.leagueName || 'FPL League';
                    console.log('Using cached league:', leagueName, 'with', allPlayers.length, 'players');
                    document.title = 'FPL Tracker - ' + leagueName;

                    // Select top 10 by default
                    allPlayers.slice(0, 10).forEach(p => selectedEntries.add(p.entry));

                    // Populate week range selectors
                    weekRangeEnd = currentGameweek || 38;
                    populateWeekSelectors();

                    renderPlayerToggles();
                    updateChart();
                    hideStatus();

                    // Auto-fetch live data for current gameweek
                    if (currentGameweek) {
                        console.log('Auto-fetching live data for GW', currentGameweek, gameweekFinished ? '(finished)' : '(in progress)');
                        showStatus('Fetching live scores...');
                        refreshLiveData().then(hideStatus);
                    }

                    // Auto-fetch user's position in background (so Find Me is ready)
                    if (userTeamId) {
                        fetchUserLeagueRank(targetLeague, userTeamId).then(rankInfo => {
                            if (rankInfo && LEAGUE_ID === targetLeague) {
                                userLeagueRank = rankInfo.rank;
                                leagueTotalPlayers = rankInfo.leagueCount || leagueTotalPlayers;
                                console.log('User position pre-fetched:', userLeagueRank, 'of', leagueTotalPlayers);
                                updateFindMeButton(); // Enable Find Me button
                            }
                        }).catch(e => console.warn('Could not pre-fetch user position:', e));
                    }

                    // Refresh in background
                    document.getElementById('loadingText').textContent = 'Updating...';
                    document.getElementById('loadingPercent').textContent = '';
                    fetchFreshData();
                    return;
                }

                document.getElementById('loadingText').textContent = 'Loading league...';
                await fetchFreshData();

            } catch (error) {
                console.error('Error loading data:', error);
                fetchRetryCount++;

                if (fetchRetryCount < MAX_FETCH_RETRIES) {
                    const retryDelay = fetchRetryCount * 2000; // 2s, 4s, 6s
                    showStatus(`Error loading. Retrying in ${retryDelay/1000}s... (attempt ${fetchRetryCount + 1}/${MAX_FETCH_RETRIES})`, true);
                    console.log(`Auto-retry ${fetchRetryCount}/${MAX_FETCH_RETRIES} in ${retryDelay}ms`);

                    setTimeout(() => {
                        if (LEAGUE_ID === targetLeague) {
                            loadAllData();
                        }
                    }, retryDelay);
                } else {
                    showStatus('Error loading league data. Please try again later.', true);
                    fetchRetryCount = 0; // Reset for next manual attempt
                    if (allPlayers.length === 0) {
                        document.getElementById('playerToggles').innerHTML =
                            '<div class="loading">Error loading after multiple attempts. <br><button class="btn btn-top-10" onclick="fetchRetryCount=0; resetAndLoad();" style="margin-top: 10px;">Try Again</button></div>';
                    }
                }
            } finally {
                isLoading = false;
            }
        }

        // Aggressive batch sizing for maximum throughput (throttledFetch handles concurrency)
        function getOptimalBatchSize(playerCount) {
            if (playerCount <= 30) return playerCount;  // Small league: all at once
            if (playerCount <= 100) return 100;         // Medium league: 1-2 batches
            return 150;                                  // Large league: aggressive batching
        }

        // Background loading state
        let isBackgroundLoading = false;
        let backgroundLoadProgress = 0;

        // Show/hide background loading indicator
        function updateBackgroundLoadingIndicator(show, loaded, total) {
            let indicator = document.getElementById('backgroundLoadingIndicator');
            if (!indicator && show) {
                indicator = document.createElement('div');
                indicator.id = 'backgroundLoadingIndicator';
                indicator.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: rgba(0, 0, 0, 0.85);
                    color: #04f5ff;
                    padding: 12px 18px;
                    border-radius: 8px;
                    font-size: 12px;
                    z-index: 9999;
                    border: 1px solid #04f5ff;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    display: flex;
                    align-items: center;
                    gap: 10px;
                `;
                document.body.appendChild(indicator);
            }
            if (indicator) {
                if (show && total > 0) {
                    const percent = Math.round((loaded / total) * 100);
                    indicator.innerHTML = `
                        <div style="width: 60px; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden;">
                            <div style="width: ${percent}%; height: 100%; background: #04f5ff; transition: width 0.3s;"></div>
                        </div>
                        <span>Loading history: ${loaded}/${total}</span>
                    `;
                    indicator.style.display = 'flex';
                } else {
                    indicator.style.display = 'none';
                }
            }
        }

        async function fetchFreshData() {
            const fetchingLeagueId = LEAGUE_ID;
            try {
                console.log('Fetching fresh data for league:', fetchingLeagueId);
                const freshPlayers = await fetchLeagueStandings();
                freshPlayers.sort((a, b) => a.rank - b.rank);

                const freshHistories = {};
                let loadedCount = 0;
                const failedPlayers = [];

                // Dynamic batch size based on league size
                const BATCH_SIZE = getOptimalBatchSize(freshPlayers.length);
                const totalBatches = Math.ceil(freshPlayers.length / BATCH_SIZE);
                const isLargeLeague = freshPlayers.length > 100;
                console.log(`Loading ${freshPlayers.length} players in ${totalBatches} batches of ${BATCH_SIZE}`);

                // For large leagues, show background indicator after first render
                if (isLargeLeague) {
                    isBackgroundLoading = true;
                }

                for (let batchIdx = 0; batchIdx < totalBatches; batchIdx++) {
                    // Abort if league changed during loading
                    if (LEAGUE_ID !== fetchingLeagueId) {
                        console.log('League changed during load, aborting');
                        isBackgroundLoading = false;
                        updateBackgroundLoadingIndicator(false, 0, 0);
                        return;
                    }

                    const startIdx = batchIdx * BATCH_SIZE;
                    const endIdx = Math.min(startIdx + BATCH_SIZE, freshPlayers.length);
                    const batch = freshPlayers.slice(startIdx, endIdx);

                    // Fetch all players in this batch in parallel
                    const batchPromises = batch.map(async (player) => {
                        try {
                            const history = await fetchPlayerHistory(player.entry);
                            if (history && Array.isArray(history) && history.length > 0) {
                                freshHistories[player.entry] = history;
                                loadedCount++;
                                return { success: true, player: player.player_name };
                            } else {
                                // Use cached history if available
                                if (playerHistories[player.entry] && playerHistories[player.entry].length > 0) {
                                    freshHistories[player.entry] = playerHistories[player.entry];
                                    return { success: true, player: player.player_name, cached: true };
                                } else {
                                    freshHistories[player.entry] = [];
                                    failedPlayers.push(player.player_name);
                                    return { success: false, player: player.player_name };
                                }
                            }
                        } catch (e) {
                            // Use cached history if available
                            if (playerHistories[player.entry] && playerHistories[player.entry].length > 0) {
                                freshHistories[player.entry] = playerHistories[player.entry];
                                return { success: true, player: player.player_name, cached: true };
                            } else {
                                freshHistories[player.entry] = [];
                                failedPlayers.push(player.player_name);
                                return { success: false, player: player.player_name, error: e.message };
                            }
                        }
                    });

                    // Wait for all in batch to complete
                    await Promise.all(batchPromises);

                    // Update progress indicators
                    const percent = Math.round((endIdx / freshPlayers.length) * 100);
                    const loadingPercent = document.getElementById('loadingPercent');
                    const loadingText = document.getElementById('loadingText');

                    // Progressive update: render UI immediately after first batch
                    if (batchIdx === 0) {
                        // Hide main loading, show the UI immediately
                        if (loadingPercent) loadingPercent.textContent = '';
                        if (loadingText) loadingText.textContent = '';
                        hideStatus();

                        // Select top 10 immediately so user sees something
                        if (selectedEntries.size === 0) {
                            freshPlayers.slice(0, Math.min(10, endIdx)).forEach(p => selectedEntries.add(p.entry));
                        }
                        allPlayers = freshPlayers;  // Show all players in list (history loads progressively)
                        playerHistories = { ...freshHistories };

                        // Populate week range selectors early
                        weekRangeEnd = currentGameweek || 38;
                        populateWeekSelectors();

                        renderPlayerToggles();
                        updateChart();
                        updateLeagueNotice();

                        // Start showing background loading indicator for large leagues
                        if (isLargeLeague && totalBatches > 1) {
                            updateBackgroundLoadingIndicator(true, endIdx, freshPlayers.length);
                        }
                    } else {
                        // Update progress in background indicator
                        if (loadingPercent) loadingPercent.textContent = percent + '%';
                        if (loadingText) loadingText.textContent = `Loading ${endIdx}/${freshPlayers.length}`;

                        // Update background loading indicator
                        if (isLargeLeague) {
                            updateBackgroundLoadingIndicator(true, endIdx, freshPlayers.length);
                        }

                        // Progressive updates: merge new histories and refresh UI periodically
                        playerHistories = { ...playerHistories, ...freshHistories };

                        // Update UI every 2 batches (or final batch) to avoid too frequent re-renders
                        if (batchIdx % 2 === 0 || batchIdx === totalBatches - 1) {
                            renderPlayerToggles();
                            if (currentDisplayMode === 'chart') {
                                updateChart();
                            }
                        }
                    }
                    // No delay between batches - maximize throughput
                }

                // Hide background loading indicator
                isBackgroundLoading = false;
                updateBackgroundLoadingIndicator(false, 0, 0);

                console.log(`=== SUMMARY: Loaded ${loadedCount}/${freshPlayers.length} player histories ===`);
                if (failedPlayers.length > 0) {
                    console.warn('Failed players:', failedPlayers);
                }

                // Check if user switched leagues during fetch - abort if so
                if (LEAGUE_ID !== fetchingLeagueId) {
                    console.warn('League changed during fetch, discarding results for', fetchingLeagueId);
                    return;
                }

                // Final update of global state
                allPlayers = freshPlayers;
                playerHistories = freshHistories;

                // Save to cache with smart GW-based invalidation
                saveToCache(fetchingLeagueId, allPlayers, playerHistories, leagueName);

                // Final render after all data loaded (already done progressively, but ensure consistency)
                if (currentFilter) filterPlayers(currentFilter);
                renderPlayerToggles();
                updateChart();
                updateTableView();
                updateLeagueNotice();
                hideStatus();

                // Auto-fetch live data for current gameweek
                if (currentGameweek) {
                    console.log('Auto-fetching live data after fresh load for GW', currentGameweek);
                    showStatus('Fetching live scores...');
                    refreshLiveData().then(hideStatus);
                }

                // Auto-fetch user's position in background (for large leagues or unknown size)
                if (userTeamId && (leagueTotalPlayers > 100 || leagueTotalPlayers === 0)) {
                    console.log('Auto-fetching user position in background...');
                    fetchUserLeagueRank(fetchingLeagueId, userTeamId).then(rankInfo => {
                        if (rankInfo && LEAGUE_ID === fetchingLeagueId) {
                            userLeagueRank = rankInfo.rank;
                            leagueTotalPlayers = rankInfo.leagueCount || leagueTotalPlayers;
                            console.log('User position fetched:', userLeagueRank, 'of', leagueTotalPlayers);
                            updateFindMeButton(); // Enable Find Me button

                            // Auto-preload more pages in background for large leagues
                            // This runs after live data, so user already has a responsive UI
                            if (leagueTotalPlayers > 100 && hasMorePages && !isBackgroundLoading) {
                                setTimeout(() => {
                                    if (LEAGUE_ID === fetchingLeagueId && hasMorePages && !isBackgroundLoading) {
                                        console.log('Auto-preloading additional pages in background...');
                                        autoPreloadMorePages(fetchingLeagueId);
                                    }
                                }, 3000); // Wait 3 seconds after initial load before preloading
                            }
                        }
                    }).catch(e => console.warn('Could not fetch user position:', e));
                }

            } catch (error) {
                console.error('Error fetching fresh data:', error);
                showStatus('Error loading data. Using cached data if available.', true);
                // If we have data (cached or partial), keep using it and render
                if (allPlayers.length > 0) {
                    console.log('Keeping existing data due to error');
                    renderPlayerToggles();
                    if (currentFilter) filterPlayers(currentFilter);
                    updateChart();
                } else {
                    document.getElementById('playerToggles').innerHTML =
                        '<div class="loading">Error loading. Refresh page.</div>';
                }
            }
        }

        function renderPlayerToggles() {
            const container = document.getElementById('playerToggles');
            if (!allPlayers || allPlayers.length === 0) {
                container.innerHTML = '<div class="loading">No players found</div>';
                return;
            }
            console.log('Rendering', allPlayers.length, 'player toggles');

            // Update slider max to match league size
            updateSliderMax();

            // Sort players by live position if available, otherwise by API rank
            const sortedPlayers = [...allPlayers].sort((a, b) => {
                const posA = livePositions[a.entry] ? livePositions[a.entry].position : a.rank;
                const posB = livePositions[b.entry] ? livePositions[b.entry].position : b.rank;
                return posA - posB;
            });

            // Get leader's total for gap calculation
            const leaderTotal = sortedPlayers.length > 0 ? sortedPlayers[0].total : 0;

            // Build HTML
            let htmlParts = [];
            let prevRank = 0;
            let separatorShown = false;

            sortedPlayers.forEach((player, idx) => {
                const isSelected = selectedEntries.has(player.entry);
                const originalIndex = allPlayers.findIndex(p => p.entry === player.entry);
                const color = colors[originalIndex % colors.length];
                const live = livePoints[player.entry];
                const posData = livePositions[player.entry];
                const currentRank = posData ? posData.position : player.rank;

                // Add separator ONCE when jumping from top 100 to user's area
                if (!separatorShown && prevRank > 0 && prevRank <= 100 && currentRank > 100) {
                    separatorShown = true;
                    htmlParts.push(`
                        <div style="
                            text-align: center;
                            padding: 10px;
                            margin: 8px 0;
                            background: linear-gradient(90deg, transparent, rgba(4,245,255,0.2), transparent);
                            color: #04f5ff;
                            font-size: 11px;
                            font-weight: 600;
                            border-top: 2px solid #04f5ff;
                            border-bottom: 2px solid #04f5ff;
                        ">
                            ↓ Jumped to position ${currentRank.toLocaleString()} ↓
                        </div>
                    `);
                }
                prevRank = currentRank;

                // Get previous GW total for calculating GW points
                const history = playerHistories[player.entry] || [];
                const prevGwIndex = currentGameweek - 2;
                const prevGwData = prevGwIndex >= 0 && history[prevGwIndex] ? history[prevGwIndex] : null;
                const prevGwTotal = prevGwData ? prevGwData.total_points : 0;

                // Use API total as source of truth, calculate GW points from it
                let pointsDisplay = player.total;  // Always use API total
                let gwPoints = player.total - prevGwTotal;  // GW points = current - previous

                // If matches are live, use live calculated points instead
                if (live && live.isLive && matchesInProgress) {
                    // Use predictedPoints if auto-subs enabled and present
                    const hasAutoSubs = autoSubsEnabled && live.autoSubs && live.autoSubs.length > 0;
                    gwPoints = live.predictedPoints;
                    // When live, total = prevGwTotal + live points
                    pointsDisplay = prevGwTotal + gwPoints;
                }

                // Use position from livePositions if available (correctly calculated)
                const displayRank = posData ? posData.position : player.rank;

                // Build GW indicator
                let liveIndicator = '';
                let movementIndicator = '';
                const chipAbbrev = { 'bboost': 'BB', '3xc': 'TC', 'freehit': 'FH', 'wildcard': 'WC' };

                if (live) {
                    // Build tooltip
                    let tooltipParts = [
                        `GW${currentGameweek} Points: ${live.points}`,
                        `Hit Taken: ${live.transferCost > 0 ? '-' + live.transferCost : '0'}`,
                        `Net GW Points: ${gwPoints}`,
                        `Chip Used: ${live.chip ? chipAbbrev[live.chip] || live.chip : 'None'}`,
                        `---`,
                        `Total: ${pointsDisplay}`
                    ];
                    const tooltip = tooltipParts.join('\n');

                    // Style: orange if hit, cyan if chip, green otherwise
                    let pointStyle = 'color: #00ff85;';
                    if (live.transferCost > 0) pointStyle = 'color: #ffaa00;';
                    if (live.chip) pointStyle = 'color: #04f5ff;';

                    // Chip badge
                    let chipBadge = '';
                    if (live.chip) {
                        chipBadge = `<span style="background: #04f5ff; color: #37003c; font-size: 8px; padding: 1px 3px; border-radius: 3px; margin-left: 3px; font-weight: bold;">${chipAbbrev[live.chip] || live.chip}</span>`;
                    }

                    // Hit badge
                    let hitBadge = '';
                    if (live.transferCost > 0) {
                        hitBadge = `<span style="background: #ffaa00; color: #37003c; font-size: 8px; padding: 1px 3px; border-radius: 3px; margin-left: 3px; font-weight: bold;">-${live.transferCost}</span>`;
                    }

                    // Live badge (only when matches in progress)
                    let liveBadge = '';
                    if (live.isLive && matchesInProgress) {
                        liveBadge = `<span style="background: #ff4757; color: white; font-size: 7px; padding: 1px 3px; border-radius: 3px; margin-left: 3px; font-weight: bold; animation: pulse 1s infinite;">LIVE</span>`;
                    } else if (live.isBonusPending) {
                        liveBadge = `<span style="background: #ffaa00; color: #37003c; font-size: 7px; padding: 1px 3px; border-radius: 3px; margin-left: 3px; font-weight: bold;">BPS</span>`;
                    }

                    // Show GW points (compact format)
                    liveIndicator = `<span style="${pointStyle} font-size: 9px; margin-left: 3px; cursor: help;" title="${tooltip}">(${gwPoints >= 0 ? '+' : ''}${gwPoints})</span>${hitBadge}${chipBadge}${liveBadge}`;
                }

                // Movement indicator
                if (posData && posData.movement !== 0) {
                    if (posData.movement > 0) {
                        movementIndicator = `<span style="color: #00ff88; font-size: 10px;">▲${posData.movement}</span>`;
                    } else {
                        movementIndicator = `<span style="color: #ff4757; font-size: 10px;">▼${Math.abs(posData.movement)}</span>`;
                    }
                }

                // Build expandable detail section
                let detailSection = '';
                if (live) {
                    const chipAbbrevFull = { 'bboost': 'Bench Boost', '3xc': 'Triple Captain', 'freehit': 'Free Hit', 'wildcard': 'Wildcard' };
                    const yetToPlay = live.playersYetToPlay || 0;
                    const playing = live.playersPlaying || 0;
                    const predicted = live.predictedPoints || gwPoints;
                    const autoSubs = live.autoSubs || [];

                    // Build auto-sub display
                    let autoSubHtml = '';
                    if (autoSubs.length === 1) {
                        // Single auto-sub on one line
                        const sub = autoSubs[0];
                        autoSubHtml = `<div class="detail-row"><span style="color: #888;">Auto-sub:</span><span style="color: #ffaa00;">${sub.outName} → ${sub.inName} (+${sub.pointsGained})</span></div>`;
                    } else if (autoSubs.length > 1) {
                        // Multiple auto-subs: header + list
                        const subsList = autoSubs.map(sub =>
                            `<div class="detail-row sub-row"><span></span><span style="color: #ffaa00;">${sub.outName} → ${sub.inName} (+${sub.pointsGained})</span></div>`
                        ).join('');
                        autoSubHtml = `<div class="detail-row"><span style="color: #888;">Auto-subs (${autoSubs.length}):</span><span></span></div>${subsList}`;
                    }

                    // Vice captain activation display
                    let vcHtml = '';
                    if (live.vcActivated && live.vcName) {
                        vcHtml = `<div class="detail-row"><span style="color: #888;">VC Active:</span><span style="color: #04f5ff;">${live.vcName} (C)</span></div>`;
                    }

                    // Bonus points display - show total then each player
                    let bonusHtml = '';
                    const bpsPlayers = live.bpsPlayers || [];
                    if (bpsPlayers.length > 0) {
                        const totalBonus = bpsPlayers.reduce((sum, p) => sum + p.bonus, 0);
                        const bpsList = bpsPlayers.map(p =>
                            `<div class="detail-row sub-row"><span></span><span style="color: #ffaa00;">${p.name} (+${p.bonus})</span></div>`
                        ).join('');
                        bonusHtml = `<div class="detail-row"><span style="color: #888;">Bonus Points:</span><span style="color: #ffaa00;">+${totalBonus}</span></div>${bpsList}`;
                    }

                    // DEFCON points display (similar to auto-subs)
                    let defconHtml = '';
                    const defconPlayers = live.defconPlayers || [];
                    if (defconPlayers.length === 1) {
                        // Single player: show on one line
                        defconHtml = `<div class="detail-row"><span style="color: #888;">DEFCON:</span><span style="color: #e056fd;">${defconPlayers[0].name} (+${defconPlayers[0].points})</span></div>`;
                    } else if (defconPlayers.length > 1) {
                        // Multiple players: header + list
                        const defconList = defconPlayers.map(p =>
                            `<div class="detail-row sub-row"><span></span><span style="color: #e056fd;">${p.name} (+${p.points})</span></div>`
                        ).join('');
                        defconHtml = `<div class="detail-row"><span style="color: #888;">DEFCON (${defconPlayers.length}):</span><span style="color: #e056fd;">+${live.defconPoints}</span></div>${defconList}`;
                    }

                    // Players status text
                    let playersStatusHtml = '';
                    if (yetToPlay > 0 || playing > 0) {
                        const parts = [];
                        if (playing > 0) parts.push(`<span style="color: #ff4757;">${playing} playing</span>`);
                        if (yetToPlay > 0) parts.push(`<span style="color: #888;">${yetToPlay} to play</span>`);
                        playersStatusHtml = `<div class="detail-row"><span>Players:</span><span>${parts.join(', ')}</span></div>`;
                    }

                    // Predicted line removed - auto-sub points now included in main GW Points

                    // Captain display
                    const capLabel = live.isTripleCaptain ? 'Triple Cap:' : 'Captain:';
                    const capMultiplier = live.isTripleCaptain ? 3 : 2;
                    const capHtml = live.captainName ?
                        `<div class="detail-row"><span style="color: #888;">${capLabel}</span><span>${live.captainName} <span style="color: #00ff85;">(${live.captainPoints} × ${capMultiplier})</span></span></div>` : '';

                    detailSection = `
                    <div class="player-details" id="details-${player.entry}" style="display: none;">
                        <div class="detail-row"><span>GW${currentGameweek} Points:</span><span style="color: #00ff85;">${live.points}</span></div>
                        ${capHtml}
                        ${live.transferCost > 0 ? `<div class="detail-row"><span>Hit Taken:</span><span style="color: #ffaa00;">-${live.transferCost}</span></div>` : ''}
                        <div class="detail-row"><span>Net GW Points:</span><span style="color: #04f5ff;">${gwPoints}</span></div>
                        ${autoSubHtml}
                        ${bonusHtml}
                        ${defconHtml}
                        ${vcHtml}
                        ${playersStatusHtml}
                        ${live.chip ? `<div class="detail-row"><span>Chip:</span><span style="color: #04f5ff;">${chipAbbrevFull[live.chip] || live.chip}</span></div>` : ''}
                        <div class="detail-row" style="border-top: 1px solid rgba(255,255,255,0.2); margin-top: 5px; padding-top: 8px;"><span>Total:</span><span style="font-weight: bold;">${pointsDisplay}</span></div>
                        ${idx > 0 ? `<div class="detail-row"><span>Gap to 1st:</span><span style="color: ${pointsDisplay - leaderTotal >= 0 ? '#00ff85' : '#ff6b6b'};">${pointsDisplay - leaderTotal}</span></div>` : ''}
                        ${live.gwRank ? `<div class="detail-row"><span>GW${currentGameweek} Rank:</span><span style="color: #888;">${live.gwRank.toLocaleString()}</span></div>` : ''}
                        ${live.overallRank ? `<div class="detail-row"><span>Overall Rank:</span><span style="color: #888;">${live.overallRank.toLocaleString()}</span></div>` : ''}
                    </div>`;
                }

                // Elite styling & user identification
                const isElite = player.isElite;
                const isUser = player.isUser || player.entry === userTeamId;
                const eliteClass = isUser ? 'user-player' : (isElite ? 'elite-player' : '');
                const userStar = isUser ? '⭐ ' : '';
                const eliteBadge = player.eliteCategory && player.eliteCategory !== 'you'
                    ? `<span class="elite-badge ${player.eliteCategory}" title="${player.eliteAchievement || ''}">${player.eliteCategory.toUpperCase()}</span>`
                    : '';

                htmlParts.push(`
                <div class="player-wrapper">
                    <label class="player-toggle ${isSelected ? 'selected' : ''} ${eliteClass}" id="toggle-${player.entry}"
                           onmouseenter="hoverPlayer(${player.entry})"
                           onmouseleave="hoverPlayer(null)"
                           onclick="toggleDetails(${player.entry}, event)"
                           style="border-left: 4px solid ${isSelected ? color : 'transparent'};">
                        <input type="checkbox"
                               data-entry="${player.entry}"
                               ${isSelected ? 'checked' : ''}
                               onchange="togglePlayer(${player.entry}, this.checked)">
                        <span class="rank">#${displayRank} ${movementIndicator}</span>
                        <span class="color-dot" style="background: ${color}; box-shadow: 0 0 4px ${color};"></span>
                        <span class="player-name" title="${player.entry_name} - ${player.player_name}${player.eliteAchievement ? ' | ' + player.eliteAchievement : ''}">
                            <span class="toggle-team-name">${userStar}${player.entry_name}${eliteBadge}</span>
                            <span class="toggle-manager-name">${player.player_name}</span>
                        </span>
                        <span class="points">${pointsDisplay}${liveIndicator}</span>
                        ${live ? '<span class="expand-icon">ℹ️</span>' : ''}
                    </label>
                    ${detailSection}
                </div>
            `);
            });

            container.innerHTML = htmlParts.join('');

            // Also update table view if in table mode
            if (currentDisplayMode === 'table') {
                updateTableView();
            }
        }

        function toggleDetails(entryId, event) {
            // If clicking the checkbox directly, let it handle selection
            if (event.target.type === 'checkbox') return;

            // Prevent the label from toggling the checkbox
            event.preventDefault();
            event.stopPropagation();

            const details = document.getElementById(`details-${entryId}`);
            if (details) {
                const isVisible = details.style.display !== 'none';
                // Hide all other details
                document.querySelectorAll('.player-details').forEach(d => d.style.display = 'none');
                // Toggle this one
                details.style.display = isVisible ? 'none' : 'block';
            }
        }

        function hoverPlayer(entryId) {
            if (hoveredEntry !== entryId) {
                hoveredEntry = entryId;
                // Only update styles, don't rebuild entire chart
                if (chart && chart.data && chart.data.datasets) {
                    updateChartHoverStyles();
                } else {
                    updateChart();
                }
            }
        }

        // Update only the hover styling without rebuilding chart
        function updateChartHoverStyles() {
            if (!chart) return;

            const selectedPlayers = allPlayers.filter(p => selectedEntries.has(p.entry));

            chart.data.datasets.forEach((dataset, i) => {
                const player = selectedPlayers[i];
                if (!player) return;

                const playerIndex = allPlayers.findIndex(p => p.entry === player.entry);
                const baseColor = colors[playerIndex % colors.length];
                const isHovered = hoveredEntry === player.entry;
                const isDimmed = hoveredEntry !== null && !isHovered;

                // Update line styles
                dataset.borderColor = isDimmed ? baseColor + '40' : baseColor;
                dataset.borderWidth = isHovered ? 4 : (isDimmed ? 1 : 2.5);

                // Update point styles (except last point which has special styling)
                const pointCount = dataset.data.length;
                const live = livePoints[player.entry];
                const hasLiveData = live && currentGameweek;

                for (let j = 0; j < pointCount; j++) {
                    const isLastPoint = j === pointCount - 1 && hasLiveData;
                    if (!isLastPoint) {
                        dataset.pointRadius[j] = isHovered ? 5 : (isDimmed ? 2 : 3);
                        dataset.pointBackgroundColor[j] = isDimmed ? baseColor + '40' : baseColor;
                        dataset.pointBorderColor[j] = isDimmed ? baseColor + '40' : baseColor;
                    }
                }
            });

            chart.update('none'); // 'none' mode skips animations for instant update
        }

        function togglePlayer(entryId, isChecked) {
            if (isChecked) {
                selectedEntries.add(entryId);
            } else {
                selectedEntries.delete(entryId);
            }

            // Update visual state
            const toggle = document.getElementById(`toggle-${entryId}`);
            if (toggle) {
                toggle.classList.toggle('selected', isChecked);
                const playerIndex = allPlayers.findIndex(p => p.entry === entryId);
                const color = colors[playerIndex % colors.length];
                toggle.style.borderLeftColor = isChecked ? color : 'transparent';
            }

            updateChart();
        }

        function updateChart() {
            const selectedPlayers = allPlayers.filter(p => selectedEntries.has(p.entry));
            const chartType = currentChartType;

            if (selectedPlayers.length === 0) {
                if (chart) chart.destroy();
                chart = null;
                return;
            }

            // Get histories only for selected players in current league
            const selectedHistories = selectedPlayers.map(p => playerHistories[p.entry]).filter(h => h && h.length > 0);

            if (selectedHistories.length === 0) {
                console.warn('No history data available');
                return;
            }

            let maxGameweeks = Math.max(...selectedHistories.map(h => h.length));

            // If we have live data, add one more gameweek
            const hasAnyLiveData = Object.keys(livePoints).length > 0 && currentGameweek;
            if (hasAnyLiveData && currentGameweek > maxGameweeks) {
                maxGameweeks = currentGameweek;
            }

            // Apply week range filter
            const rangeStart = weekRangeStart;
            const rangeEnd = Math.min(weekRangeEnd, maxGameweeks);

            const labels = [];
            for (let gwNum = rangeStart; gwNum <= rangeEnd; gwNum++) {
                if (hasAnyLiveData && gwNum === currentGameweek) {
                    if (matchesInProgress) {
                        labels.push(`GW${gwNum} 🔴`);  // Red dot when live
                    } else if (bonusPending) {
                        labels.push(`GW${gwNum} 🟡`);  // Yellow when bonus pending
                    } else {
                        labels.push(`GW${gwNum} ✓`);   // Checkmark when confirmed
                    }
                } else {
                    labels.push(`GW${gwNum}`);
                }
            }

            // Pre-calculate all positions for rank mode (need all players, not just selected)
            const allPositions = {};
            if (chartType === 'rank') {
                for (let gwIdx = 0; gwIdx < maxGameweeks; gwIdx++) {
                    // Get all players' totals at this gameweek
                    const gwTotals = allPlayers.map(p => {
                        const h = playerHistories[p.entry];
                        return {
                            entry: p.entry,
                            total: h && h[gwIdx] ? h[gwIdx].total_points : 0
                        };
                    }).sort((a, b) => b.total - a.total);

                    // Assign positions
                    gwTotals.forEach((item, idx) => {
                        if (!allPositions[item.entry]) allPositions[item.entry] = [];
                        allPositions[item.entry][gwIdx] = idx + 1;
                    });
                }
            }

            // Calculate final values for label positioning (use last gameweek for all)
            const finalValues = selectedPlayers.map(player => {
                const history = playerHistories[player.entry] || [];
                if (history.length === 0) return { player, value: 0 };
                // Use the actual last gameweek data for value calculation
                const lastIdx = Math.min(history.length - 1, maxGameweeks - 1);
                const lastGw = history[lastIdx];
                let value;
                if (chartType === 'rank') {
                    // Use position at the final gameweek
                    value = allPositions[player.entry] ? allPositions[player.entry][maxGameweeks - 1] || allPositions[player.entry][lastIdx] : 999;
                } else {
                    value = chartType === 'total' ? (lastGw ? lastGw.total_points : 0) : (lastGw ? lastGw.points : 0);
                }
                return { player, value };
            }).sort((a, b) => chartType === 'rank' ? a.value - b.value : b.value - a.value);

            // Assign label offsets to prevent overlap
            const labelOffsets = {};
            finalValues.forEach((item, idx) => {
                // Alternate labels up/down when close together
                labelOffsets[item.player.entry] = (idx % 2 === 0) ? -5 : 15;
            });

            const datasets = selectedPlayers.map((player) => {
                const history = playerHistories[player.entry] || [];
                const playerIndex = allPlayers.findIndex(p => p.entry === player.entry);
                let data = [];

                if (history.length === 0) {
                    console.warn(`No history for ${player.player_name}`);
                    return null;
                }

                // Check for live data
                const live = livePoints[player.entry];
                const posData = livePositions[player.entry];
                const hasLiveData = live && currentGameweek;

                // Get previous GW total for calculations
                const prevGwIdx = currentGameweek - 2;
                const prevGwData = prevGwIdx >= 0 && history[prevGwIdx] ? history[prevGwIdx] : null;
                const prevTotal = prevGwData ? prevGwData.total_points : 0;

                if (chartType === 'total') {
                    data = history.map(gw => gw ? gw.total_points : null);

                    // For current gameweek, use correct total
                    if (hasLiveData && currentGameweek) {
                        let currentTotal;
                        if (matchesInProgress) {
                            // Matches live: use prev + live points
                            currentTotal = prevTotal + live.netPoints;
                        } else {
                            // No matches live: use API total (already updated)
                            currentTotal = player.total;
                        }

                        // Replace or add for current GW
                        if (data.length >= currentGameweek) {
                            data[currentGameweek - 1] = currentTotal;
                        } else {
                            while (data.length < currentGameweek - 1) {
                                data.push(data.length > 0 ? data[data.length - 1] : null);
                            }
                            data.push(currentTotal);
                        }
                    }
                } else if (chartType === 'weekly') {
                    data = history.map(gw => gw ? gw.points : null);

                    // For current gameweek, calculate GW points correctly
                    if (hasLiveData && currentGameweek) {
                        let gwPoints;
                        if (matchesInProgress) {
                            // Matches live: use live calculated points
                            gwPoints = live.netPoints;
                        } else {
                            // No matches: calculate from API total - prev total
                            gwPoints = player.total - prevTotal;
                        }

                        if (data.length >= currentGameweek) {
                            data[currentGameweek - 1] = gwPoints;
                        } else {
                            while (data.length < currentGameweek - 1) {
                                data.push(null);
                            }
                            data.push(gwPoints);
                        }
                    }
                } else if (chartType === 'rank') {
                    // Use pre-calculated positions
                    data = allPositions[player.entry] ? [...allPositions[player.entry]] : [];

                    // For current GW, use calculated position from livePositions
                    if (posData && currentGameweek) {
                        const currentPos = posData.position;
                        if (data.length >= currentGameweek) {
                            data[currentGameweek - 1] = currentPos;
                        } else {
                            while (data.length < currentGameweek - 1) {
                                data.push(data.length > 0 ? data[data.length - 1] : null);
                            }
                            data.push(currentPos);
                        }
                    }
                }

                // Pad data array to maxGameweeks so all labels align at the end
                while (data.length < maxGameweeks) {
                    data.push(data.length > 0 ? data[data.length - 1] : null);
                }

                // Slice data to week range (0-indexed: rangeStart-1 to rangeEnd)
                data = data.slice(rangeStart - 1, rangeEnd);

                const isHovered = hoveredEntry === player.entry;
                const isDimmed = hoveredEntry !== null && !isHovered;
                const baseColor = colors[playerIndex % colors.length];

                // Create point styles - highlight current GW point
                const isCurrentGwPoint = hasLiveData && currentGameweek;
                const pointRadii = data.map((_, idx) => {
                    if (isCurrentGwPoint && idx === data.length - 1) {
                        return matchesInProgress ? 10 : 7; // Larger when live
                    }
                    return isHovered ? 5 : (isDimmed ? 2 : 3);
                });

                const pointBgColors = data.map((_, idx) => {
                    if (isCurrentGwPoint && idx === data.length - 1) {
                        return matchesInProgress ? '#ff4757' : '#00ff88'; // Red when live, green when settled
                    }
                    return isDimmed ? baseColor + '40' : baseColor;
                });

                const pointBorderColors = data.map((_, idx) => {
                    if (isCurrentGwPoint && idx === data.length - 1) {
                        return '#ffffff';
                    }
                    return isDimmed ? baseColor + '40' : baseColor;
                });

                const pointBorderWidths = data.map((_, idx) => {
                    if (isCurrentGwPoint && idx === data.length - 1) {
                        return 2;
                    }
                    return 1;
                });

                return {
                    label: player.player_name,
                    data: data,
                    borderColor: isDimmed ? baseColor + '40' : baseColor,
                    backgroundColor: baseColor + '20',
                    fill: false,
                    tension: 0.2,
                    pointRadius: pointRadii,
                    pointBackgroundColor: pointBgColors,
                    pointBorderColor: pointBorderColors,
                    pointBorderWidth: pointBorderWidths,
                    pointHoverRadius: 8,
                    borderWidth: isHovered ? 4 : (isDimmed ? 1 : 2.5),
                    datalabels: {
                        display: false // Using custom endLabels plugin instead
                    }
                };
            }).filter(d => d !== null);

            if (datasets.length === 0) {
                console.warn('No valid datasets');
                return;
            }

            if (chart) chart.destroy();

            const ctx = document.getElementById('mainChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                plugins: [ChartDataLabels, {
                    id: 'endLabels',
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;

                        chart.data.datasets.forEach((dataset, i) => {
                            const meta = chart.getDatasetMeta(i);
                            if (!meta.hidden && meta.data.length > 0) {
                                // Find the last point with valid data
                                let lastPoint = null;
                                for (let j = meta.data.length - 1; j >= 0; j--) {
                                    const point = meta.data[j];
                                    const dataValue = dataset.data[j];
                                    if (point && dataValue !== null && dataValue !== undefined &&
                                        !isNaN(point.x) && !isNaN(point.y)) {
                                        lastPoint = point;
                                        break;
                                    }
                                }

                                if (lastPoint) {
                                    const x = lastPoint.x + 10;
                                    // Clamp y to stay within chart area with some padding
                                    let y = lastPoint.y;
                                    const minY = chartArea.top + 10;
                                    const maxY = chartArea.bottom - 10;
                                    if (y < minY) y = minY;
                                    if (y > maxY) y = maxY;

                                    const firstName = dataset.label.split(' ')[0];

                                    // Find player's position movement
                                    const player = selectedPlayers.find(p => p.player_name === dataset.label);
                                    const posData = player ? livePositions[player.entry] : null;
                                    let movementText = '';
                                    let movementColor = '';
                                    if (posData && posData.movement !== 0) {
                                        if (posData.movement > 0) {
                                            movementText = ' ▲' + posData.movement;
                                            movementColor = '#00ff85';
                                        } else {
                                            movementText = ' ▼' + Math.abs(posData.movement);
                                            movementColor = '#ff4757';
                                        }
                                    }

                                    ctx.save();
                                    ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';

                                    // Draw name with stroke for visibility
                                    ctx.fillStyle = dataset.borderColor;
                                    ctx.strokeStyle = '#37003c';
                                    ctx.lineWidth = 3;
                                    ctx.strokeText(firstName, x, y + 3);
                                    ctx.fillText(firstName, x, y + 3);

                                    // Draw movement indicator
                                    if (movementText) {
                                        const nameWidth = ctx.measureText(firstName).width;
                                        ctx.fillStyle = movementColor;
                                        ctx.strokeText(movementText, x + nameWidth, y + 3);
                                        ctx.fillText(movementText, x + nameWidth, y + 3);
                                    }

                                    ctx.restore();
                                }
                            }
                        });
                    }
                }],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            right: 100,
                            top: 10
                        }
                    },
                    clip: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: (items) => items[0].label,
                                label: (item) => `${item.dataset.label}: ${item.raw}`
                            }
                        },
                        datalabels: {
                            display: false // Using custom endLabels plugin
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#888', maxRotation: 45 },
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            clip: false
                        },
                        y: {
                            reverse: chartType === 'rank',
                            min: chartType === 'rank' ? 1 : undefined,
                            max: chartType === 'rank' ? allPlayers.length : undefined,
                            ticks: {
                                color: '#888',
                                stepSize: chartType === 'rank' ? 1 : undefined,
                                callback: function(value) {
                                    if (chartType === 'rank') {
                                        return Number.isInteger(value) ? value : '';
                                    }
                                    return value;
                                }
                            },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            title: {
                                display: true,
                                text: chartType === 'total' ? 'Total Points' :
                                      chartType === 'weekly' ? 'Weekly Points' : 'League Position',
                                color: '#888'
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }

        function selectAll() {
            selectedEntries = new Set(allPlayers.map(p => p.entry));
            renderPlayerToggles();
            if (currentFilter) filterPlayers(currentFilter);
            updateChart();
        }

        function clearAll() {
            selectedEntries = new Set();
            renderPlayerToggles();
            if (currentFilter) filterPlayers(currentFilter);
            updateChart();
        }

        function selectTop10() {
            // Reset slider to 10 when clicking Top 10 button
            const slider = document.getElementById('topNSlider');
            if (slider) slider.value = 10;
            updateSliderLabel(10);
            selectTopN(10);
        }

        function updateSliderLabel(n) {
            const label = document.getElementById('sliderValue');
            const maxPlayers = allPlayers.length || 100;
            // Show "All" if at or above league size
            if (n >= maxPlayers) {
                if (label) label.textContent = `All (${maxPlayers})`;
            } else {
                if (label) label.textContent = `Top ${n}`;
            }
        }

        function updateSliderMax() {
            const slider = document.getElementById('topNSlider');
            const maxLabel = document.getElementById('sliderMaxLabel');
            if (slider && allPlayers.length > 0) {
                // Set slider max to loaded player count (no arbitrary cap)
                slider.max = allPlayers.length;
                if (maxLabel) maxLabel.textContent = `All`;
            }
        }

        function selectTopN(n) {
            n = parseInt(n) || 10;
            // Cap at league size
            const maxPlayers = allPlayers.length || 100;
            n = Math.min(n, maxPlayers);
            selectedEntries = new Set(allPlayers.slice(0, n).map(p => p.entry));
            updateSliderLabel(n);
            renderPlayerToggles();
            if (currentFilter) filterPlayers(currentFilter);
            updateChart();
        }

        function filterPlayers(searchTerm) {
            currentFilter = searchTerm.toLowerCase().trim();
            const toggles = document.querySelectorAll('.player-toggle');
            let visibleCount = 0;

            toggles.forEach(toggle => {
                const playerName = toggle.querySelector('.player-name').textContent.toLowerCase();
                const teamName = toggle.querySelector('.player-name').title?.toLowerCase() || '';
                const matches = playerName.includes(currentFilter) || teamName.includes(currentFilter);
                toggle.style.display = matches ? '' : 'none';
                if (matches) visibleCount++;
            });

            // Show/hide "Select Filtered" button
            const selectFilteredBtn = document.getElementById('selectFilteredBtn');
            if (selectFilteredBtn) {
                selectFilteredBtn.style.display = currentFilter && visibleCount > 0 ? '' : 'none';
                selectFilteredBtn.textContent = `Select (${visibleCount})`;
            }
        }

        function selectFiltered() {
            if (!currentFilter) return;
            const filter = currentFilter;
            allPlayers.forEach(player => {
                const playerName = player.player_name.toLowerCase();
                const teamName = (player.entry_name || '').toLowerCase();
                if (playerName.includes(filter) || teamName.includes(filter)) {
                    selectedEntries.add(player.entry);
                }
            });
            renderPlayerToggles();
            filterPlayers(currentFilter); // Re-apply filter after render
            updateChart();
        }

        function populateWeekSelectors() {
            const maxGw = currentGameweek || 38;
            const startSelect = document.getElementById('weekStart');
            const endSelect = document.getElementById('weekEnd');

            startSelect.innerHTML = '';
            endSelect.innerHTML = '';

            for (let i = 1; i <= maxGw; i++) {
                startSelect.innerHTML += `<option value="${i}">${i}</option>`;
                endSelect.innerHTML += `<option value="${i}">${i}</option>`;
            }

            // Default to last 5 gameweeks for better chart readability
            if (weekRangeStart === 1 && maxGw > 5) {
                weekRangeStart = Math.max(1, maxGw - 4);
            }

            startSelect.value = weekRangeStart;
            endSelect.value = Math.min(weekRangeEnd, maxGw);
            weekRangeEnd = Math.min(weekRangeEnd, maxGw);
        }

        function updateWeekRange() {
            const start = parseInt(document.getElementById('weekStart').value);
            const end = parseInt(document.getElementById('weekEnd').value);

            if (start > end) {
                document.getElementById('weekEnd').value = start;
                weekRangeEnd = start;
            } else {
                weekRangeEnd = end;
            }
            weekRangeStart = start;
            updateChart();
        }

        function resetWeekRange() {
            weekRangeStart = 1;
            weekRangeEnd = currentGameweek || 38;
            document.getElementById('weekStart').value = 1;
            document.getElementById('weekEnd').value = weekRangeEnd;
            updateChart();
        }

        // Handle window resize and orientation change - debounced update
        let resizeTimeout;
        let lastWidth = window.innerWidth;

        function handleResize() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (chart) {
                    chart.resize();
                }
                // Re-render table on significant width change (orientation change)
                const widthChange = Math.abs(window.innerWidth - lastWidth);
                if (widthChange > 100 && currentDisplayMode === 'table') {
                    updateTableView();
                }
                lastWidth = window.innerWidth;
            }, 150);
        }

        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', () => {
            setTimeout(handleResize, 100); // Small delay for orientation to settle
        });

        // Infinite scroll detection for large leagues (both up and down)
        let scrollTimeout;
        function canLoadUp() {
            // Can load up if there are unloaded pages between top 100 (pages 1-2) and user's area
            // Find minimum page > 2 (i.e., first page after top 100)
            const pagesAboveTop100 = [...loadedPages].filter(p => p > 2);
            if (pagesAboveTop100.length === 0) return false;
            const minUserPage = Math.min(...pagesAboveTop100);
            // Can load up if there are pages between 2 and minUserPage
            return minUserPage > 3 && !isLoadingMore;
        }

        function setupScrollListener() {
            const tableContainer = document.getElementById('tableView');
            if (!tableContainer) return;

            tableContainer.addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    const scrollTop = tableContainer.scrollTop;
                    const scrollHeight = tableContainer.scrollHeight;
                    const clientHeight = tableContainer.clientHeight;

                    // Near bottom - load more down
                    if (scrollTop + clientHeight >= scrollHeight - 200) {
                        if (hasMorePages && !isLoadingMore && leagueTotalPlayers > allPlayers.length) {
                            console.log('Loading more (down) from container scroll');
                            loadMoreManagers('down');
                        }
                    }

                    // Near top - load more up (fill gap between top 100 and user's area)
                    if (scrollTop <= 200 && canLoadUp()) {
                        console.log('Loading more (up) from container scroll');
                        loadMoreManagers('up');
                    }
                }, 100);
            });
        }

        // Also detect window scroll for non-scrollable containers
        window.addEventListener('scroll', () => {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                const scrollTop = window.scrollY;
                const scrollHeight = document.documentElement.scrollHeight;
                const clientHeight = window.innerHeight;

                // Near bottom - load more down
                if (scrollTop + clientHeight >= scrollHeight - 300) {
                    if (hasMorePages && !isLoadingMore && leagueTotalPlayers > allPlayers.length) {
                        console.log('Loading more (down) from window scroll');
                        loadMoreManagers('down');
                    }
                }

                // Near top - load more up
                if (scrollTop <= 200 && canLoadUp()) {
                    console.log('Loading more (up) from window scroll');
                    loadMoreManagers('up');
                }
            }, 100);
        });

        // Start app
        initApp();
        setupScrollListener();

        // Event delegation for table buttons (fixes mobile touch issues)
        function handleLoadButtonClick(e) {
            const btn = e.target.closest('button');
            if (!btn) return;

            // Handle Load Previous button
            if (btn.textContent.includes('Load Previous')) {
                e.preventDefault();
                e.stopPropagation();
                loadMoreManagers('up');
            }
            // Handle Load More button
            if (btn.textContent.includes('Load More') || btn.textContent.includes('Load Next')) {
                e.preventDefault();
                e.stopPropagation();
                loadMoreManagers('down');
            }
        }
        // Add to table (for jump separator button)
        const leagueTable = document.querySelector('.league-table');
        leagueTable.addEventListener('click', handleLoadButtonClick);
        leagueTable.addEventListener('touchend', handleLoadButtonClick);

        // Add to loadMoreSection (for bottom button)
        const loadMoreSection = document.getElementById('loadMoreSection');
        if (loadMoreSection) {
            loadMoreSection.addEventListener('click', handleLoadButtonClick);
            loadMoreSection.addEventListener('touchend', handleLoadButtonClick);
        }
    </script>
    <!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "55d4f204731e4a7ebdf5456cc84d2154"}'></script><!-- End Cloudflare Web Analytics -->
</body>
</html>
